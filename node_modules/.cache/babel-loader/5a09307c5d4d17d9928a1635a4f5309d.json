{"remainingRequest":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js!/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseMultilineTokens.js","dependencies":[{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseMultilineTokens.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/babel.config.js","mtime":1668271197000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js","mtime":456789000000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gIi9Vc2Vycy95YW5qaWFqaWEvRGVza3RvcC93b3Jrc3BhY2UvYXZ1ZS1kYXRhLW5ldy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcyI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiL1VzZXJzL3lhbmppYWppYS9EZXNrdG9wL3dvcmtzcGFjZS9hdnVlLWRhdGEtbmV3L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjay5qcyI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiL1VzZXJzL3lhbmppYWppYS9EZXNrdG9wL3dvcmtzcGFjZS9hdnVlLWRhdGEtbmV3L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5wdXNoLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbi5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LWJ1ZmZlci5zbGljZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQzMi1hcnJheS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmF0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW4uanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5ldmVyeS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGwuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXIuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQtbGFzdC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQtbGFzdC1pbmRleC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5jbHVkZXMuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZi5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pbi5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2YuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXAuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmVycm9yLmNhdXNlLmpzIjsKLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi4KICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovCmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi4vY29yZS9wb3NpdGlvbi5qcyc7CmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vY29yZS9yYW5nZS5qcyc7CmltcG9ydCB7IGNvdW50RU9MIH0gZnJvbSAnLi4vY29yZS9lb2xDb3VudGVyLmpzJzsKLyoqCiAqIFJlcHJlc2VudHMgc3BhcnNlIHRva2VucyBvdmVyIGEgY29udGlndW91cyByYW5nZSBvZiBsaW5lcy4KICovCmV4cG9ydCB2YXIgU3BhcnNlTXVsdGlsaW5lVG9rZW5zID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICBmdW5jdGlvbiBTcGFyc2VNdWx0aWxpbmVUb2tlbnMoc3RhcnRMaW5lTnVtYmVyLCB0b2tlbnMpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcGFyc2VNdWx0aWxpbmVUb2tlbnMpOwogICAgdGhpcy5fc3RhcnRMaW5lTnVtYmVyID0gc3RhcnRMaW5lTnVtYmVyOwogICAgdGhpcy5fdG9rZW5zID0gdG9rZW5zOwogICAgdGhpcy5fZW5kTGluZU51bWJlciA9IHRoaXMuX3N0YXJ0TGluZU51bWJlciArIHRoaXMuX3Rva2Vucy5nZXRNYXhEZWx0YUxpbmUoKTsKICB9CiAgX2NyZWF0ZUNsYXNzKFNwYXJzZU11bHRpbGluZVRva2VucywgW3sKICAgIGtleTogInN0YXJ0TGluZU51bWJlciIsCiAgICBnZXQ6CiAgICAvKioKICAgICAqIChJbmNsdXNpdmUpIHN0YXJ0IGxpbmUgbnVtYmVyIGZvciB0aGVzZSB0b2tlbnMuCiAgICAgKi8KICAgIGZ1bmN0aW9uIGdldCgpIHsKICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0TGluZU51bWJlcjsKICAgIH0KICAgIC8qKgogICAgICogKEluY2x1c2l2ZSkgZW5kIGxpbmUgbnVtYmVyIGZvciB0aGVzZSB0b2tlbnMuCiAgICAgKi8KICB9LCB7CiAgICBrZXk6ICJlbmRMaW5lTnVtYmVyIiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy5fZW5kTGluZU51bWJlcjsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJ0b1N0cmluZyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7CiAgICAgIHJldHVybiB0aGlzLl90b2tlbnMudG9TdHJpbmcodGhpcy5fc3RhcnRMaW5lTnVtYmVyKTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJfdXBkYXRlRW5kTGluZU51bWJlciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUVuZExpbmVOdW1iZXIoKSB7CiAgICAgIHRoaXMuX2VuZExpbmVOdW1iZXIgPSB0aGlzLl9zdGFydExpbmVOdW1iZXIgKyB0aGlzLl90b2tlbnMuZ2V0TWF4RGVsdGFMaW5lKCk7CiAgICB9CiAgfSwgewogICAga2V5OiAiaXNFbXB0eSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbXB0eSgpIHsKICAgICAgcmV0dXJuIHRoaXMuX3Rva2Vucy5pc0VtcHR5KCk7CiAgICB9CiAgfSwgewogICAga2V5OiAiZ2V0TGluZVRva2VucyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGluZVRva2VucyhsaW5lTnVtYmVyKSB7CiAgICAgIGlmICh0aGlzLl9zdGFydExpbmVOdW1iZXIgPD0gbGluZU51bWJlciAmJiBsaW5lTnVtYmVyIDw9IHRoaXMuX2VuZExpbmVOdW1iZXIpIHsKICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5zLmdldExpbmVUb2tlbnMobGluZU51bWJlciAtIHRoaXMuX3N0YXJ0TGluZU51bWJlcik7CiAgICAgIH0KICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgfSwgewogICAga2V5OiAiZ2V0UmFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhbmdlKCkgewogICAgICB2YXIgZGVsdGFSYW5nZSA9IHRoaXMuX3Rva2Vucy5nZXRSYW5nZSgpOwogICAgICBpZiAoIWRlbHRhUmFuZ2UpIHsKICAgICAgICByZXR1cm4gZGVsdGFSYW5nZTsKICAgICAgfQogICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuX3N0YXJ0TGluZU51bWJlciArIGRlbHRhUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCBkZWx0YVJhbmdlLnN0YXJ0Q29sdW1uLCB0aGlzLl9zdGFydExpbmVOdW1iZXIgKyBkZWx0YVJhbmdlLmVuZExpbmVOdW1iZXIsIGRlbHRhUmFuZ2UuZW5kQ29sdW1uKTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJyZW1vdmVUb2tlbnMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVRva2VucyhyYW5nZSkgewogICAgICB2YXIgc3RhcnRMaW5lSW5kZXggPSByYW5nZS5zdGFydExpbmVOdW1iZXIgLSB0aGlzLl9zdGFydExpbmVOdW1iZXI7CiAgICAgIHZhciBlbmRMaW5lSW5kZXggPSByYW5nZS5lbmRMaW5lTnVtYmVyIC0gdGhpcy5fc3RhcnRMaW5lTnVtYmVyOwogICAgICB0aGlzLl9zdGFydExpbmVOdW1iZXIgKz0gdGhpcy5fdG9rZW5zLnJlbW92ZVRva2VucyhzdGFydExpbmVJbmRleCwgcmFuZ2Uuc3RhcnRDb2x1bW4gLSAxLCBlbmRMaW5lSW5kZXgsIHJhbmdlLmVuZENvbHVtbiAtIDEpOwogICAgICB0aGlzLl91cGRhdGVFbmRMaW5lTnVtYmVyKCk7CiAgICB9CiAgfSwgewogICAga2V5OiAic3BsaXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0KHJhbmdlKSB7CiAgICAgIC8vIHNwbGl0IHRva2VucyB0byB0d286CiAgICAgIC8vIGEpIGFsbCB0aGUgdG9rZW5zIGJlZm9yZSBgcmFuZ2VgCiAgICAgIC8vIGIpIGFsbCB0aGUgdG9rZW5zIGFmdGVyIGByYW5nZWAKICAgICAgdmFyIHN0YXJ0TGluZUluZGV4ID0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gdGhpcy5fc3RhcnRMaW5lTnVtYmVyOwogICAgICB2YXIgZW5kTGluZUluZGV4ID0gcmFuZ2UuZW5kTGluZU51bWJlciAtIHRoaXMuX3N0YXJ0TGluZU51bWJlcjsKICAgICAgdmFyIF90aGlzJF90b2tlbnMkc3BsaXQgPSB0aGlzLl90b2tlbnMuc3BsaXQoc3RhcnRMaW5lSW5kZXgsIHJhbmdlLnN0YXJ0Q29sdW1uIC0gMSwgZW5kTGluZUluZGV4LCByYW5nZS5lbmRDb2x1bW4gLSAxKSwKICAgICAgICBfdGhpcyRfdG9rZW5zJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF90b2tlbnMkc3BsaXQsIDMpLAogICAgICAgIGEgPSBfdGhpcyRfdG9rZW5zJHNwbGl0MlswXSwKICAgICAgICBiID0gX3RoaXMkX3Rva2VucyRzcGxpdDJbMV0sCiAgICAgICAgYkRlbHRhTGluZSA9IF90aGlzJF90b2tlbnMkc3BsaXQyWzJdOwogICAgICByZXR1cm4gW25ldyBTcGFyc2VNdWx0aWxpbmVUb2tlbnModGhpcy5fc3RhcnRMaW5lTnVtYmVyLCBhKSwgbmV3IFNwYXJzZU11bHRpbGluZVRva2Vucyh0aGlzLl9zdGFydExpbmVOdW1iZXIgKyBiRGVsdGFMaW5lLCBiKV07CiAgICB9CiAgfSwgewogICAga2V5OiAiYXBwbHlFZGl0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseUVkaXQocmFuZ2UsIHRleHQpIHsKICAgICAgdmFyIF9jb3VudEVPTCA9IGNvdW50RU9MKHRleHQpLAogICAgICAgIF9jb3VudEVPTDIgPSBfc2xpY2VkVG9BcnJheShfY291bnRFT0wsIDMpLAogICAgICAgIGVvbENvdW50ID0gX2NvdW50RU9MMlswXSwKICAgICAgICBmaXJzdExpbmVMZW5ndGggPSBfY291bnRFT0wyWzFdLAogICAgICAgIGxhc3RMaW5lTGVuZ3RoID0gX2NvdW50RU9MMlsyXTsKICAgICAgdGhpcy5hY2NlcHRFZGl0KHJhbmdlLCBlb2xDb3VudCwgZmlyc3RMaW5lTGVuZ3RoLCBsYXN0TGluZUxlbmd0aCwgdGV4dC5sZW5ndGggPiAwID8gdGV4dC5jaGFyQ29kZUF0KDApIDogMCAvKiBDaGFyQ29kZS5OdWxsICovKTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJhY2NlcHRFZGl0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRFZGl0KHJhbmdlLCBlb2xDb3VudCwgZmlyc3RMaW5lTGVuZ3RoLCBsYXN0TGluZUxlbmd0aCwgZmlyc3RDaGFyQ29kZSkgewogICAgICB0aGlzLl9hY2NlcHREZWxldGVSYW5nZShyYW5nZSk7CiAgICAgIHRoaXMuX2FjY2VwdEluc2VydFRleHQobmV3IFBvc2l0aW9uKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2Uuc3RhcnRDb2x1bW4pLCBlb2xDb3VudCwgZmlyc3RMaW5lTGVuZ3RoLCBsYXN0TGluZUxlbmd0aCwgZmlyc3RDaGFyQ29kZSk7CiAgICAgIHRoaXMuX3VwZGF0ZUVuZExpbmVOdW1iZXIoKTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJfYWNjZXB0RGVsZXRlUmFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9hY2NlcHREZWxldGVSYW5nZShyYW5nZSkgewogICAgICBpZiAocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID09PSByYW5nZS5lbmRMaW5lTnVtYmVyICYmIHJhbmdlLnN0YXJ0Q29sdW1uID09PSByYW5nZS5lbmRDb2x1bW4pIHsKICAgICAgICAvLyBOb3RoaW5nIHRvIGRlbGV0ZQogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICB2YXIgZmlyc3RMaW5lSW5kZXggPSByYW5nZS5zdGFydExpbmVOdW1iZXIgLSB0aGlzLl9zdGFydExpbmVOdW1iZXI7CiAgICAgIHZhciBsYXN0TGluZUluZGV4ID0gcmFuZ2UuZW5kTGluZU51bWJlciAtIHRoaXMuX3N0YXJ0TGluZU51bWJlcjsKICAgICAgaWYgKGxhc3RMaW5lSW5kZXggPCAwKSB7CiAgICAgICAgLy8gdGhpcyBkZWxldGlvbiBvY2N1cnMgZW50aXJlbHkgYmVmb3JlIHRoaXMgYmxvY2ssIHNvIHdlIG9ubHkgbmVlZCB0byBhZGp1c3QgbGluZSBudW1iZXJzCiAgICAgICAgdmFyIGRlbGV0ZWRMaW5lc0NvdW50ID0gbGFzdExpbmVJbmRleCAtIGZpcnN0TGluZUluZGV4OwogICAgICAgIHRoaXMuX3N0YXJ0TGluZU51bWJlciAtPSBkZWxldGVkTGluZXNDb3VudDsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgdmFyIHRva2VuTWF4RGVsdGFMaW5lID0gdGhpcy5fdG9rZW5zLmdldE1heERlbHRhTGluZSgpOwogICAgICBpZiAoZmlyc3RMaW5lSW5kZXggPj0gdG9rZW5NYXhEZWx0YUxpbmUgKyAxKSB7CiAgICAgICAgLy8gdGhpcyBkZWxldGlvbiBvY2N1cnMgZW50aXJlbHkgYWZ0ZXIgdGhpcyBibG9jaywgc28gdGhlcmUgaXMgbm90aGluZyB0byBkbwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBpZiAoZmlyc3RMaW5lSW5kZXggPCAwICYmIGxhc3RMaW5lSW5kZXggPj0gdG9rZW5NYXhEZWx0YUxpbmUgKyAxKSB7CiAgICAgICAgLy8gdGhpcyBkZWxldGlvbiBjb21wbGV0ZWx5IGVuY29tcGFzc2VzIHRoaXMgYmxvY2sKICAgICAgICB0aGlzLl9zdGFydExpbmVOdW1iZXIgPSAwOwogICAgICAgIHRoaXMuX3Rva2Vucy5jbGVhcigpOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBpZiAoZmlyc3RMaW5lSW5kZXggPCAwKSB7CiAgICAgICAgdmFyIGRlbGV0ZWRCZWZvcmUgPSAtZmlyc3RMaW5lSW5kZXg7CiAgICAgICAgdGhpcy5fc3RhcnRMaW5lTnVtYmVyIC09IGRlbGV0ZWRCZWZvcmU7CiAgICAgICAgdGhpcy5fdG9rZW5zLmFjY2VwdERlbGV0ZVJhbmdlKHJhbmdlLnN0YXJ0Q29sdW1uIC0gMSwgMCwgMCwgbGFzdExpbmVJbmRleCwgcmFuZ2UuZW5kQ29sdW1uIC0gMSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5fdG9rZW5zLmFjY2VwdERlbGV0ZVJhbmdlKDAsIGZpcnN0TGluZUluZGV4LCByYW5nZS5zdGFydENvbHVtbiAtIDEsIGxhc3RMaW5lSW5kZXgsIHJhbmdlLmVuZENvbHVtbiAtIDEpOwogICAgICB9CiAgICB9CiAgfSwgewogICAga2V5OiAiX2FjY2VwdEluc2VydFRleHQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9hY2NlcHRJbnNlcnRUZXh0KHBvc2l0aW9uLCBlb2xDb3VudCwgZmlyc3RMaW5lTGVuZ3RoLCBsYXN0TGluZUxlbmd0aCwgZmlyc3RDaGFyQ29kZSkgewogICAgICBpZiAoZW9sQ291bnQgPT09IDAgJiYgZmlyc3RMaW5lTGVuZ3RoID09PSAwKSB7CiAgICAgICAgLy8gTm90aGluZyB0byBpbnNlcnQKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgdmFyIGxpbmVJbmRleCA9IHBvc2l0aW9uLmxpbmVOdW1iZXIgLSB0aGlzLl9zdGFydExpbmVOdW1iZXI7CiAgICAgIGlmIChsaW5lSW5kZXggPCAwKSB7CiAgICAgICAgLy8gdGhpcyBpbnNlcnRpb24gb2NjdXJzIGJlZm9yZSB0aGlzIGJsb2NrLCBzbyB3ZSBvbmx5IG5lZWQgdG8gYWRqdXN0IGxpbmUgbnVtYmVycwogICAgICAgIHRoaXMuX3N0YXJ0TGluZU51bWJlciArPSBlb2xDb3VudDsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgdmFyIHRva2VuTWF4RGVsdGFMaW5lID0gdGhpcy5fdG9rZW5zLmdldE1heERlbHRhTGluZSgpOwogICAgICBpZiAobGluZUluZGV4ID49IHRva2VuTWF4RGVsdGFMaW5lICsgMSkgewogICAgICAgIC8vIHRoaXMgaW5zZXJ0aW9uIG9jY3VycyBhZnRlciB0aGlzIGJsb2NrLCBzbyB0aGVyZSBpcyBub3RoaW5nIHRvIGRvCiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIHRoaXMuX3Rva2Vucy5hY2NlcHRJbnNlcnRUZXh0KGxpbmVJbmRleCwgcG9zaXRpb24uY29sdW1uIC0gMSwgZW9sQ291bnQsIGZpcnN0TGluZUxlbmd0aCwgbGFzdExpbmVMZW5ndGgsIGZpcnN0Q2hhckNvZGUpOwogICAgfQogIH1dLCBbewogICAga2V5OiAiY3JlYXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoc3RhcnRMaW5lTnVtYmVyLCB0b2tlbnMpIHsKICAgICAgcmV0dXJuIG5ldyBTcGFyc2VNdWx0aWxpbmVUb2tlbnMoc3RhcnRMaW5lTnVtYmVyLCBuZXcgU3BhcnNlTXVsdGlsaW5lVG9rZW5zU3RvcmFnZSh0b2tlbnMpKTsKICAgIH0KICB9XSk7CiAgcmV0dXJuIFNwYXJzZU11bHRpbGluZVRva2VuczsKfSgpOwp2YXIgU3BhcnNlTXVsdGlsaW5lVG9rZW5zU3RvcmFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7CiAgZnVuY3Rpb24gU3BhcnNlTXVsdGlsaW5lVG9rZW5zU3RvcmFnZSh0b2tlbnMpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcGFyc2VNdWx0aWxpbmVUb2tlbnNTdG9yYWdlKTsKICAgIHRoaXMuX3Rva2VucyA9IHRva2VuczsKICAgIHRoaXMuX3Rva2VuQ291bnQgPSB0b2tlbnMubGVuZ3RoIC8gNDsKICB9CiAgX2NyZWF0ZUNsYXNzKFNwYXJzZU11bHRpbGluZVRva2Vuc1N0b3JhZ2UsIFt7CiAgICBrZXk6ICJ0b1N0cmluZyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoc3RhcnRMaW5lTnVtYmVyKSB7CiAgICAgIHZhciBwaWVjZXMgPSBbXTsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90b2tlbkNvdW50OyBpKyspIHsKICAgICAgICBwaWVjZXMucHVzaCgiKCIuY29uY2F0KHRoaXMuX2dldERlbHRhTGluZShpKSArIHN0YXJ0TGluZU51bWJlciwgIiwiKS5jb25jYXQodGhpcy5fZ2V0U3RhcnRDaGFyYWN0ZXIoaSksICItIikuY29uY2F0KHRoaXMuX2dldEVuZENoYXJhY3RlcihpKSwgIikiKSk7CiAgICAgIH0KICAgICAgcmV0dXJuICJbIi5jb25jYXQocGllY2VzLmpvaW4oJywnKSwgIl0iKTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJnZXRNYXhEZWx0YUxpbmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1heERlbHRhTGluZSgpIHsKICAgICAgdmFyIHRva2VuQ291bnQgPSB0aGlzLl9nZXRUb2tlbkNvdW50KCk7CiAgICAgIGlmICh0b2tlbkNvdW50ID09PSAwKSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLl9nZXREZWx0YUxpbmUodG9rZW5Db3VudCAtIDEpOwogICAgfQogIH0sIHsKICAgIGtleTogImdldFJhbmdlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSYW5nZSgpIHsKICAgICAgdmFyIHRva2VuQ291bnQgPSB0aGlzLl9nZXRUb2tlbkNvdW50KCk7CiAgICAgIGlmICh0b2tlbkNvdW50ID09PSAwKSB7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0KICAgICAgdmFyIHN0YXJ0Q2hhciA9IHRoaXMuX2dldFN0YXJ0Q2hhcmFjdGVyKDApOwogICAgICB2YXIgbWF4RGVsdGFMaW5lID0gdGhpcy5fZ2V0RGVsdGFMaW5lKHRva2VuQ291bnQgLSAxKTsKICAgICAgdmFyIGVuZENoYXIgPSB0aGlzLl9nZXRFbmRDaGFyYWN0ZXIodG9rZW5Db3VudCAtIDEpOwogICAgICByZXR1cm4gbmV3IFJhbmdlKDAsIHN0YXJ0Q2hhciArIDEsIG1heERlbHRhTGluZSwgZW5kQ2hhciArIDEpOwogICAgfQogIH0sIHsKICAgIGtleTogIl9nZXRUb2tlbkNvdW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VG9rZW5Db3VudCgpIHsKICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuQ291bnQ7CiAgICB9CiAgfSwgewogICAga2V5OiAiX2dldERlbHRhTGluZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlbHRhTGluZSh0b2tlbkluZGV4KSB7CiAgICAgIHJldHVybiB0aGlzLl90b2tlbnNbNCAqIHRva2VuSW5kZXhdOwogICAgfQogIH0sIHsKICAgIGtleTogIl9nZXRTdGFydENoYXJhY3RlciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0YXJ0Q2hhcmFjdGVyKHRva2VuSW5kZXgpIHsKICAgICAgcmV0dXJuIHRoaXMuX3Rva2Vuc1s0ICogdG9rZW5JbmRleCArIDFdOwogICAgfQogIH0sIHsKICAgIGtleTogIl9nZXRFbmRDaGFyYWN0ZXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRFbmRDaGFyYWN0ZXIodG9rZW5JbmRleCkgewogICAgICByZXR1cm4gdGhpcy5fdG9rZW5zWzQgKiB0b2tlbkluZGV4ICsgMl07CiAgICB9CiAgfSwgewogICAga2V5OiAiaXNFbXB0eSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbXB0eSgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2dldFRva2VuQ291bnQoKSA9PT0gMDsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJnZXRMaW5lVG9rZW5zIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMaW5lVG9rZW5zKGRlbHRhTGluZSkgewogICAgICB2YXIgbG93ID0gMDsKICAgICAgdmFyIGhpZ2ggPSB0aGlzLl9nZXRUb2tlbkNvdW50KCkgLSAxOwogICAgICB3aGlsZSAobG93IDwgaGlnaCkgewogICAgICAgIHZhciBtaWQgPSBsb3cgKyBNYXRoLmZsb29yKChoaWdoIC0gbG93KSAvIDIpOwogICAgICAgIHZhciBtaWREZWx0YUxpbmUgPSB0aGlzLl9nZXREZWx0YUxpbmUobWlkKTsKICAgICAgICBpZiAobWlkRGVsdGFMaW5lIDwgZGVsdGFMaW5lKSB7CiAgICAgICAgICBsb3cgPSBtaWQgKyAxOwogICAgICAgIH0gZWxzZSBpZiAobWlkRGVsdGFMaW5lID4gZGVsdGFMaW5lKSB7CiAgICAgICAgICBoaWdoID0gbWlkIC0gMTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdmFyIG1pbiA9IG1pZDsKICAgICAgICAgIHdoaWxlIChtaW4gPiBsb3cgJiYgdGhpcy5fZ2V0RGVsdGFMaW5lKG1pbiAtIDEpID09PSBkZWx0YUxpbmUpIHsKICAgICAgICAgICAgbWluLS07CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgbWF4ID0gbWlkOwogICAgICAgICAgd2hpbGUgKG1heCA8IGhpZ2ggJiYgdGhpcy5fZ2V0RGVsdGFMaW5lKG1heCArIDEpID09PSBkZWx0YUxpbmUpIHsKICAgICAgICAgICAgbWF4Kys7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZUxpbmVUb2tlbnModGhpcy5fdG9rZW5zLnN1YmFycmF5KDQgKiBtaW4sIDQgKiBtYXggKyA0KSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmICh0aGlzLl9nZXREZWx0YUxpbmUobG93KSA9PT0gZGVsdGFMaW5lKSB7CiAgICAgICAgcmV0dXJuIG5ldyBTcGFyc2VMaW5lVG9rZW5zKHRoaXMuX3Rva2Vucy5zdWJhcnJheSg0ICogbG93LCA0ICogbG93ICsgNCkpOwogICAgICB9CiAgICAgIHJldHVybiBudWxsOwogICAgfQogIH0sIHsKICAgIGtleTogImNsZWFyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHsKICAgICAgdGhpcy5fdG9rZW5Db3VudCA9IDA7CiAgICB9CiAgfSwgewogICAga2V5OiAicmVtb3ZlVG9rZW5zIiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVUb2tlbnMoc3RhcnREZWx0YUxpbmUsIHN0YXJ0Q2hhciwgZW5kRGVsdGFMaW5lLCBlbmRDaGFyKSB7CiAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl90b2tlbnM7CiAgICAgIHZhciB0b2tlbkNvdW50ID0gdGhpcy5fdG9rZW5Db3VudDsKICAgICAgdmFyIG5ld1Rva2VuQ291bnQgPSAwOwogICAgICB2YXIgaGFzRGVsZXRlZFRva2VucyA9IGZhbHNlOwogICAgICB2YXIgZmlyc3REZWx0YUxpbmUgPSAwOwogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2VuQ291bnQ7IGkrKykgewogICAgICAgIHZhciBzcmNPZmZzZXQgPSA0ICogaTsKICAgICAgICB2YXIgdG9rZW5EZWx0YUxpbmUgPSB0b2tlbnNbc3JjT2Zmc2V0XTsKICAgICAgICB2YXIgdG9rZW5TdGFydENoYXJhY3RlciA9IHRva2Vuc1tzcmNPZmZzZXQgKyAxXTsKICAgICAgICB2YXIgdG9rZW5FbmRDaGFyYWN0ZXIgPSB0b2tlbnNbc3JjT2Zmc2V0ICsgMl07CiAgICAgICAgdmFyIHRva2VuTWV0YWRhdGEgPSB0b2tlbnNbc3JjT2Zmc2V0ICsgM107CiAgICAgICAgaWYgKCh0b2tlbkRlbHRhTGluZSA+IHN0YXJ0RGVsdGFMaW5lIHx8IHRva2VuRGVsdGFMaW5lID09PSBzdGFydERlbHRhTGluZSAmJiB0b2tlbkVuZENoYXJhY3RlciA+PSBzdGFydENoYXIpICYmICh0b2tlbkRlbHRhTGluZSA8IGVuZERlbHRhTGluZSB8fCB0b2tlbkRlbHRhTGluZSA9PT0gZW5kRGVsdGFMaW5lICYmIHRva2VuU3RhcnRDaGFyYWN0ZXIgPD0gZW5kQ2hhcikpIHsKICAgICAgICAgIGhhc0RlbGV0ZWRUb2tlbnMgPSB0cnVlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAobmV3VG9rZW5Db3VudCA9PT0gMCkgewogICAgICAgICAgICBmaXJzdERlbHRhTGluZSA9IHRva2VuRGVsdGFMaW5lOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGhhc0RlbGV0ZWRUb2tlbnMpIHsKICAgICAgICAgICAgLy8gbXVzdCBtb3ZlIHRoZSB0b2tlbiB0byB0aGUgbGVmdAogICAgICAgICAgICB2YXIgZGVzdE9mZnNldCA9IDQgKiBuZXdUb2tlbkNvdW50OwogICAgICAgICAgICB0b2tlbnNbZGVzdE9mZnNldF0gPSB0b2tlbkRlbHRhTGluZSAtIGZpcnN0RGVsdGFMaW5lOwogICAgICAgICAgICB0b2tlbnNbZGVzdE9mZnNldCArIDFdID0gdG9rZW5TdGFydENoYXJhY3RlcjsKICAgICAgICAgICAgdG9rZW5zW2Rlc3RPZmZzZXQgKyAyXSA9IHRva2VuRW5kQ2hhcmFjdGVyOwogICAgICAgICAgICB0b2tlbnNbZGVzdE9mZnNldCArIDNdID0gdG9rZW5NZXRhZGF0YTsKICAgICAgICAgIH0KICAgICAgICAgIG5ld1Rva2VuQ291bnQrKzsKICAgICAgICB9CiAgICAgIH0KICAgICAgdGhpcy5fdG9rZW5Db3VudCA9IG5ld1Rva2VuQ291bnQ7CiAgICAgIHJldHVybiBmaXJzdERlbHRhTGluZTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJzcGxpdCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc3BsaXQoc3RhcnREZWx0YUxpbmUsIHN0YXJ0Q2hhciwgZW5kRGVsdGFMaW5lLCBlbmRDaGFyKSB7CiAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl90b2tlbnM7CiAgICAgIHZhciB0b2tlbkNvdW50ID0gdGhpcy5fdG9rZW5Db3VudDsKICAgICAgdmFyIGFUb2tlbnMgPSBbXTsKICAgICAgdmFyIGJUb2tlbnMgPSBbXTsKICAgICAgdmFyIGRlc3RUb2tlbnMgPSBhVG9rZW5zOwogICAgICB2YXIgZGVzdE9mZnNldCA9IDA7CiAgICAgIHZhciBkZXN0Rmlyc3REZWx0YUxpbmUgPSAwOwogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2VuQ291bnQ7IGkrKykgewogICAgICAgIHZhciBzcmNPZmZzZXQgPSA0ICogaTsKICAgICAgICB2YXIgdG9rZW5EZWx0YUxpbmUgPSB0b2tlbnNbc3JjT2Zmc2V0XTsKICAgICAgICB2YXIgdG9rZW5TdGFydENoYXJhY3RlciA9IHRva2Vuc1tzcmNPZmZzZXQgKyAxXTsKICAgICAgICB2YXIgdG9rZW5FbmRDaGFyYWN0ZXIgPSB0b2tlbnNbc3JjT2Zmc2V0ICsgMl07CiAgICAgICAgdmFyIHRva2VuTWV0YWRhdGEgPSB0b2tlbnNbc3JjT2Zmc2V0ICsgM107CiAgICAgICAgaWYgKHRva2VuRGVsdGFMaW5lID4gc3RhcnREZWx0YUxpbmUgfHwgdG9rZW5EZWx0YUxpbmUgPT09IHN0YXJ0RGVsdGFMaW5lICYmIHRva2VuRW5kQ2hhcmFjdGVyID49IHN0YXJ0Q2hhcikgewogICAgICAgICAgaWYgKHRva2VuRGVsdGFMaW5lIDwgZW5kRGVsdGFMaW5lIHx8IHRva2VuRGVsdGFMaW5lID09PSBlbmREZWx0YUxpbmUgJiYgdG9rZW5TdGFydENoYXJhY3RlciA8PSBlbmRDaGFyKSB7CiAgICAgICAgICAgIC8vIHRoaXMgdG9rZW4gaXMgdG91Y2hpbmcgdGhlIHJhbmdlCiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgLy8gdGhpcyB0b2tlbiBpcyBhZnRlciB0aGUgcmFuZ2UKICAgICAgICAgICAgaWYgKGRlc3RUb2tlbnMgIT09IGJUb2tlbnMpIHsKICAgICAgICAgICAgICAvLyB0aGlzIHRva2VuIGlzIHRoZSBmaXJzdCB0b2tlbiBhZnRlciB0aGUgcmFuZ2UKICAgICAgICAgICAgICBkZXN0VG9rZW5zID0gYlRva2VuczsKICAgICAgICAgICAgICBkZXN0T2Zmc2V0ID0gMDsKICAgICAgICAgICAgICBkZXN0Rmlyc3REZWx0YUxpbmUgPSB0b2tlbkRlbHRhTGluZTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBkZXN0VG9rZW5zW2Rlc3RPZmZzZXQrK10gPSB0b2tlbkRlbHRhTGluZSAtIGRlc3RGaXJzdERlbHRhTGluZTsKICAgICAgICBkZXN0VG9rZW5zW2Rlc3RPZmZzZXQrK10gPSB0b2tlblN0YXJ0Q2hhcmFjdGVyOwogICAgICAgIGRlc3RUb2tlbnNbZGVzdE9mZnNldCsrXSA9IHRva2VuRW5kQ2hhcmFjdGVyOwogICAgICAgIGRlc3RUb2tlbnNbZGVzdE9mZnNldCsrXSA9IHRva2VuTWV0YWRhdGE7CiAgICAgIH0KICAgICAgcmV0dXJuIFtuZXcgU3BhcnNlTXVsdGlsaW5lVG9rZW5zU3RvcmFnZShuZXcgVWludDMyQXJyYXkoYVRva2VucykpLCBuZXcgU3BhcnNlTXVsdGlsaW5lVG9rZW5zU3RvcmFnZShuZXcgVWludDMyQXJyYXkoYlRva2VucykpLCBkZXN0Rmlyc3REZWx0YUxpbmVdOwogICAgfQogIH0sIHsKICAgIGtleTogImFjY2VwdERlbGV0ZVJhbmdlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHREZWxldGVSYW5nZShob3Jpem9udGFsU2hpZnRGb3JGaXJzdExpbmVUb2tlbnMsIHN0YXJ0RGVsdGFMaW5lLCBzdGFydENoYXJhY3RlciwgZW5kRGVsdGFMaW5lLCBlbmRDaGFyYWN0ZXIpIHsKICAgICAgLy8gVGhpcyBpcyBhIGJpdCBjb21wbGV4LCBoZXJlIGFyZSB0aGUgY2FzZXMgSSB1c2VkIHRvIHRoaW5rIGFib3V0IHRoaXM6CiAgICAgIC8vCiAgICAgIC8vIDEuIFRoZSB0b2tlbiBzdGFydHMgYmVmb3JlIHRoZSBkZWxldGlvbiByYW5nZQogICAgICAvLyAxYS4gVGhlIHRva2VuIGlzIGNvbXBsZXRlbHkgYmVmb3JlIHRoZSBkZWxldGlvbiByYW5nZQogICAgICAvLyAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tCiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICB4eHh4eHh4eHh4eAogICAgICAvLyAxYi4gVGhlIHRva2VuIHN0YXJ0cyBiZWZvcmUsIHRoZSBkZWxldGlvbiByYW5nZSBlbmRzIGFmdGVyIHRoZSB0b2tlbgogICAgICAvLyAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tCiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHh4eHh4eHh4eHh4CiAgICAgIC8vIDFjLiBUaGUgdG9rZW4gc3RhcnRzIGJlZm9yZSwgdGhlIGRlbGV0aW9uIHJhbmdlIGVuZHMgcHJlY2lzZWx5IHdpdGggdGhlIHRva2VuCiAgICAgIC8vICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tCiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHh4eHh4eHh4CiAgICAgIC8vIDFkLiBUaGUgdG9rZW4gc3RhcnRzIGJlZm9yZSwgdGhlIGRlbGV0aW9uIHJhbmdlIGlzIGluc2lkZSB0aGUgdG9rZW4KICAgICAgLy8gICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0KICAgICAgLy8gICAgICAgICAgICAgICAgICAgIHh4eHh4CiAgICAgIC8vCiAgICAgIC8vIDIuIFRoZSB0b2tlbiBzdGFydHMgYXQgdGhlIHNhbWUgcG9zaXRpb24gd2l0aCB0aGUgZGVsZXRpb24gcmFuZ2UKICAgICAgLy8gMmEuIFRoZSB0b2tlbiBzdGFydHMgYXQgdGhlIHNhbWUgcG9zaXRpb24sIGFuZCBlbmRzIGluc2lkZSB0aGUgZGVsZXRpb24gcmFuZ2UKICAgICAgLy8gICAgICAgICAgICAgICAtLS0tLS0tCiAgICAgIC8vICAgICAgICAgICAgICAgeHh4eHh4eHh4eHgKICAgICAgLy8gMmIuIFRoZSB0b2tlbiBzdGFydHMgYXQgdGhlIHNhbWUgcG9zaXRpb24sIGFuZCBlbmRzIGF0IHRoZSBzYW1lIHBvc2l0aW9uIGFzIHRoZSBkZWxldGlvbiByYW5nZQogICAgICAvLyAgICAgICAgICAgICAgIC0tLS0tLS0tLS0KICAgICAgLy8gICAgICAgICAgICAgICB4eHh4eHh4eHh4CiAgICAgIC8vIDJjLiBUaGUgdG9rZW4gc3RhcnRzIGF0IHRoZSBzYW1lIHBvc2l0aW9uLCBhbmQgZW5kcyBhZnRlciB0aGUgZGVsZXRpb24gcmFuZ2UKICAgICAgLy8gICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tCiAgICAgIC8vICAgICAgICAgICAgICAgeHh4eHh4eAogICAgICAvLwogICAgICAvLyAzLiBUaGUgdG9rZW4gc3RhcnRzIGluc2lkZSB0aGUgZGVsZXRpb24gcmFuZ2UKICAgICAgLy8gM2EuIFRoZSB0b2tlbiBpcyBpbnNpZGUgdGhlIGRlbGV0aW9uIHJhbmdlCiAgICAgIC8vICAgICAgICAgICAgICAgIC0tLS0tLS0KICAgICAgLy8gICAgICAgICAgICAgeHh4eHh4eHh4eHh4eAogICAgICAvLyAzYi4gVGhlIHRva2VuIHN0YXJ0cyBpbnNpZGUgdGhlIGRlbGV0aW9uIHJhbmdlLCBhbmQgZW5kcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiBhcyB0aGUgZGVsZXRpb24gcmFuZ2UKICAgICAgLy8gICAgICAgICAgICAgICAgLS0tLS0tLS0tLQogICAgICAvLyAgICAgICAgICAgICB4eHh4eHh4eHh4eHh4CiAgICAgIC8vIDNjLiBUaGUgdG9rZW4gc3RhcnRzIGluc2lkZSB0aGUgZGVsZXRpb24gcmFuZ2UsIGFuZCBlbmRzIGFmdGVyIHRoZSBkZWxldGlvbiByYW5nZQogICAgICAvLyAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0KICAgICAgLy8gICAgICAgICAgICAgeHh4eHh4eHh4eHgKICAgICAgLy8KICAgICAgLy8gNC4gVGhlIHRva2VuIHN0YXJ0cyBhZnRlciB0aGUgZGVsZXRpb24gcmFuZ2UKICAgICAgLy8gICAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLQogICAgICAvLyAgICAgICAgICB4eHh4eHh4eAogICAgICAvLwogICAgICB2YXIgdG9rZW5zID0gdGhpcy5fdG9rZW5zOwogICAgICB2YXIgdG9rZW5Db3VudCA9IHRoaXMuX3Rva2VuQ291bnQ7CiAgICAgIHZhciBkZWxldGVkTGluZUNvdW50ID0gZW5kRGVsdGFMaW5lIC0gc3RhcnREZWx0YUxpbmU7CiAgICAgIHZhciBuZXdUb2tlbkNvdW50ID0gMDsKICAgICAgdmFyIGhhc0RlbGV0ZWRUb2tlbnMgPSBmYWxzZTsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbkNvdW50OyBpKyspIHsKICAgICAgICB2YXIgc3JjT2Zmc2V0ID0gNCAqIGk7CiAgICAgICAgdmFyIHRva2VuRGVsdGFMaW5lID0gdG9rZW5zW3NyY09mZnNldF07CiAgICAgICAgdmFyIHRva2VuU3RhcnRDaGFyYWN0ZXIgPSB0b2tlbnNbc3JjT2Zmc2V0ICsgMV07CiAgICAgICAgdmFyIHRva2VuRW5kQ2hhcmFjdGVyID0gdG9rZW5zW3NyY09mZnNldCArIDJdOwogICAgICAgIHZhciB0b2tlbk1ldGFkYXRhID0gdG9rZW5zW3NyY09mZnNldCArIDNdOwogICAgICAgIGlmICh0b2tlbkRlbHRhTGluZSA8IHN0YXJ0RGVsdGFMaW5lIHx8IHRva2VuRGVsdGFMaW5lID09PSBzdGFydERlbHRhTGluZSAmJiB0b2tlbkVuZENoYXJhY3RlciA8PSBzdGFydENoYXJhY3RlcikgewogICAgICAgICAgLy8gMWEuIFRoZSB0b2tlbiBpcyBjb21wbGV0ZWx5IGJlZm9yZSB0aGUgZGVsZXRpb24gcmFuZ2UKICAgICAgICAgIC8vID0+IG5vdGhpbmcgdG8gZG8KICAgICAgICAgIG5ld1Rva2VuQ291bnQrKzsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0gZWxzZSBpZiAodG9rZW5EZWx0YUxpbmUgPT09IHN0YXJ0RGVsdGFMaW5lICYmIHRva2VuU3RhcnRDaGFyYWN0ZXIgPCBzdGFydENoYXJhY3RlcikgewogICAgICAgICAgLy8gMWIsIDFjLCAxZAogICAgICAgICAgLy8gPT4gdGhlIHRva2VuIHN1cnZpdmVzLCBidXQgaXQgbmVlZHMgdG8gc2hyaW5rCiAgICAgICAgICBpZiAodG9rZW5EZWx0YUxpbmUgPT09IGVuZERlbHRhTGluZSAmJiB0b2tlbkVuZENoYXJhY3RlciA+IGVuZENoYXJhY3RlcikgewogICAgICAgICAgICAvLyAxZC4gVGhlIHRva2VuIHN0YXJ0cyBiZWZvcmUsIHRoZSBkZWxldGlvbiByYW5nZSBpcyBpbnNpZGUgdGhlIHRva2VuCiAgICAgICAgICAgIC8vID0+IHRoZSB0b2tlbiBzaHJpbmtzIGJ5IHRoZSBkZWxldGlvbiBjaGFyYWN0ZXIgY291bnQKICAgICAgICAgICAgdG9rZW5FbmRDaGFyYWN0ZXIgLT0gZW5kQ2hhcmFjdGVyIC0gc3RhcnRDaGFyYWN0ZXI7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAvLyAxYi4gVGhlIHRva2VuIHN0YXJ0cyBiZWZvcmUsIHRoZSBkZWxldGlvbiByYW5nZSBlbmRzIGFmdGVyIHRoZSB0b2tlbgogICAgICAgICAgICAvLyAxYy4gVGhlIHRva2VuIHN0YXJ0cyBiZWZvcmUsIHRoZSBkZWxldGlvbiByYW5nZSBlbmRzIHByZWNpc2VseSB3aXRoIHRoZSB0b2tlbgogICAgICAgICAgICAvLyA9PiB0aGUgdG9rZW4gc2hyaW5rcyBpdHMgZW5kaW5nIHRvIHRoZSBkZWxldGlvbiBzdGFydAogICAgICAgICAgICB0b2tlbkVuZENoYXJhY3RlciA9IHN0YXJ0Q2hhcmFjdGVyOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAodG9rZW5EZWx0YUxpbmUgPT09IHN0YXJ0RGVsdGFMaW5lICYmIHRva2VuU3RhcnRDaGFyYWN0ZXIgPT09IHN0YXJ0Q2hhcmFjdGVyKSB7CiAgICAgICAgICAvLyAyYSwgMmIsIDJjCiAgICAgICAgICBpZiAodG9rZW5EZWx0YUxpbmUgPT09IGVuZERlbHRhTGluZSAmJiB0b2tlbkVuZENoYXJhY3RlciA+IGVuZENoYXJhY3RlcikgewogICAgICAgICAgICAvLyAyYy4gVGhlIHRva2VuIHN0YXJ0cyBhdCB0aGUgc2FtZSBwb3NpdGlvbiwgYW5kIGVuZHMgYWZ0ZXIgdGhlIGRlbGV0aW9uIHJhbmdlCiAgICAgICAgICAgIC8vID0+IHRoZSB0b2tlbiBzaHJpbmtzIGJ5IHRoZSBkZWxldGlvbiBjaGFyYWN0ZXIgY291bnQKICAgICAgICAgICAgdG9rZW5FbmRDaGFyYWN0ZXIgLT0gZW5kQ2hhcmFjdGVyIC0gc3RhcnRDaGFyYWN0ZXI7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAvLyAyYS4gVGhlIHRva2VuIHN0YXJ0cyBhdCB0aGUgc2FtZSBwb3NpdGlvbiwgYW5kIGVuZHMgaW5zaWRlIHRoZSBkZWxldGlvbiByYW5nZQogICAgICAgICAgICAvLyAyYi4gVGhlIHRva2VuIHN0YXJ0cyBhdCB0aGUgc2FtZSBwb3NpdGlvbiwgYW5kIGVuZHMgYXQgdGhlIHNhbWUgcG9zaXRpb24gYXMgdGhlIGRlbGV0aW9uIHJhbmdlCiAgICAgICAgICAgIC8vID0+IHRoZSB0b2tlbiBpcyBkZWxldGVkCiAgICAgICAgICAgIGhhc0RlbGV0ZWRUb2tlbnMgPSB0cnVlOwogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHRva2VuRGVsdGFMaW5lIDwgZW5kRGVsdGFMaW5lIHx8IHRva2VuRGVsdGFMaW5lID09PSBlbmREZWx0YUxpbmUgJiYgdG9rZW5TdGFydENoYXJhY3RlciA8IGVuZENoYXJhY3RlcikgewogICAgICAgICAgLy8gM2EsIDNiLCAzYwogICAgICAgICAgaWYgKHRva2VuRGVsdGFMaW5lID09PSBlbmREZWx0YUxpbmUgJiYgdG9rZW5FbmRDaGFyYWN0ZXIgPiBlbmRDaGFyYWN0ZXIpIHsKICAgICAgICAgICAgLy8gM2MuIFRoZSB0b2tlbiBzdGFydHMgaW5zaWRlIHRoZSBkZWxldGlvbiByYW5nZSwgYW5kIGVuZHMgYWZ0ZXIgdGhlIGRlbGV0aW9uIHJhbmdlCiAgICAgICAgICAgIC8vID0+IHRoZSB0b2tlbiBtb3ZlcyBsZWZ0IGFuZCBzaHJpbmtzCiAgICAgICAgICAgIGlmICh0b2tlbkRlbHRhTGluZSA9PT0gc3RhcnREZWx0YUxpbmUpIHsKICAgICAgICAgICAgICAvLyB0aGUgZGVsZXRpb24gc3RhcnRlZCBvbiB0aGUgc2FtZSBsaW5lIGFzIHRoZSB0b2tlbgogICAgICAgICAgICAgIC8vID0+IHRoZSB0b2tlbiBtb3ZlcyBsZWZ0IGFuZCBzaHJpbmtzCiAgICAgICAgICAgICAgdG9rZW5TdGFydENoYXJhY3RlciA9IHN0YXJ0Q2hhcmFjdGVyOwogICAgICAgICAgICAgIHRva2VuRW5kQ2hhcmFjdGVyID0gdG9rZW5TdGFydENoYXJhY3RlciArICh0b2tlbkVuZENoYXJhY3RlciAtIGVuZENoYXJhY3Rlcik7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgLy8gdGhlIGRlbGV0aW9uIHN0YXJ0ZWQgb24gYSBsaW5lIGFib3ZlIHRoZSB0b2tlbgogICAgICAgICAgICAgIC8vID0+IHRoZSB0b2tlbiBtb3ZlcyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lCiAgICAgICAgICAgICAgdG9rZW5TdGFydENoYXJhY3RlciA9IDA7CiAgICAgICAgICAgICAgdG9rZW5FbmRDaGFyYWN0ZXIgPSB0b2tlblN0YXJ0Q2hhcmFjdGVyICsgKHRva2VuRW5kQ2hhcmFjdGVyIC0gZW5kQ2hhcmFjdGVyKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgLy8gM2EuIFRoZSB0b2tlbiBpcyBpbnNpZGUgdGhlIGRlbGV0aW9uIHJhbmdlCiAgICAgICAgICAgIC8vIDNiLiBUaGUgdG9rZW4gc3RhcnRzIGluc2lkZSB0aGUgZGVsZXRpb24gcmFuZ2UsIGFuZCBlbmRzIGF0IHRoZSBzYW1lIHBvc2l0aW9uIGFzIHRoZSBkZWxldGlvbiByYW5nZQogICAgICAgICAgICAvLyA9PiB0aGUgdG9rZW4gaXMgZGVsZXRlZAogICAgICAgICAgICBoYXNEZWxldGVkVG9rZW5zID0gdHJ1ZTsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmICh0b2tlbkRlbHRhTGluZSA+IGVuZERlbHRhTGluZSkgewogICAgICAgICAgLy8gNC4gKHBhcnRpYWwpIFRoZSB0b2tlbiBzdGFydHMgYWZ0ZXIgdGhlIGRlbGV0aW9uIHJhbmdlLCBvbiBhIGxpbmUgYmVsb3cuLi4KICAgICAgICAgIGlmIChkZWxldGVkTGluZUNvdW50ID09PSAwICYmICFoYXNEZWxldGVkVG9rZW5zKSB7CiAgICAgICAgICAgIC8vIGVhcmx5IHN0b3AsIHRoZXJlIGlzIG5vIG5lZWQgdG8gd2FsayBhbGwgdGhlIHRva2VucyBhbmQgZG8gbm90aGluZy4uLgogICAgICAgICAgICBuZXdUb2tlbkNvdW50ID0gdG9rZW5Db3VudDsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICB0b2tlbkRlbHRhTGluZSAtPSBkZWxldGVkTGluZUNvdW50OwogICAgICAgIH0gZWxzZSBpZiAodG9rZW5EZWx0YUxpbmUgPT09IGVuZERlbHRhTGluZSAmJiB0b2tlblN0YXJ0Q2hhcmFjdGVyID49IGVuZENoYXJhY3RlcikgewogICAgICAgICAgLy8gNC4gKGNvbnRpbnVlZCkgVGhlIHRva2VuIHN0YXJ0cyBhZnRlciB0aGUgZGVsZXRpb24gcmFuZ2UsIG9uIHRoZSBsYXN0IGxpbmUgd2hlcmUgYSBkZWxldGlvbiBvY2N1cnMKICAgICAgICAgIGlmIChob3Jpem9udGFsU2hpZnRGb3JGaXJzdExpbmVUb2tlbnMgJiYgdG9rZW5EZWx0YUxpbmUgPT09IDApIHsKICAgICAgICAgICAgdG9rZW5TdGFydENoYXJhY3RlciArPSBob3Jpem9udGFsU2hpZnRGb3JGaXJzdExpbmVUb2tlbnM7CiAgICAgICAgICAgIHRva2VuRW5kQ2hhcmFjdGVyICs9IGhvcml6b250YWxTaGlmdEZvckZpcnN0TGluZVRva2VuczsKICAgICAgICAgIH0KICAgICAgICAgIHRva2VuRGVsdGFMaW5lIC09IGRlbGV0ZWRMaW5lQ291bnQ7CiAgICAgICAgICB0b2tlblN0YXJ0Q2hhcmFjdGVyIC09IGVuZENoYXJhY3RlciAtIHN0YXJ0Q2hhcmFjdGVyOwogICAgICAgICAgdG9rZW5FbmRDaGFyYWN0ZXIgLT0gZW5kQ2hhcmFjdGVyIC0gc3RhcnRDaGFyYWN0ZXI7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiTm90IHBvc3NpYmxlISIpOwogICAgICAgIH0KICAgICAgICB2YXIgZGVzdE9mZnNldCA9IDQgKiBuZXdUb2tlbkNvdW50OwogICAgICAgIHRva2Vuc1tkZXN0T2Zmc2V0XSA9IHRva2VuRGVsdGFMaW5lOwogICAgICAgIHRva2Vuc1tkZXN0T2Zmc2V0ICsgMV0gPSB0b2tlblN0YXJ0Q2hhcmFjdGVyOwogICAgICAgIHRva2Vuc1tkZXN0T2Zmc2V0ICsgMl0gPSB0b2tlbkVuZENoYXJhY3RlcjsKICAgICAgICB0b2tlbnNbZGVzdE9mZnNldCArIDNdID0gdG9rZW5NZXRhZGF0YTsKICAgICAgICBuZXdUb2tlbkNvdW50Kys7CiAgICAgIH0KICAgICAgdGhpcy5fdG9rZW5Db3VudCA9IG5ld1Rva2VuQ291bnQ7CiAgICB9CiAgfSwgewogICAga2V5OiAiYWNjZXB0SW5zZXJ0VGV4dCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0SW5zZXJ0VGV4dChkZWx0YUxpbmUsIGNoYXJhY3RlciwgZW9sQ291bnQsIGZpcnN0TGluZUxlbmd0aCwgbGFzdExpbmVMZW5ndGgsIGZpcnN0Q2hhckNvZGUpIHsKICAgICAgLy8gSGVyZSBhcmUgdGhlIGNhc2VzIEkgdXNlZCB0byB0aGluayBhYm91dCB0aGlzOgogICAgICAvLwogICAgICAvLyAxLiBUaGUgdG9rZW4gaXMgY29tcGxldGVseSBiZWZvcmUgdGhlIGluc2VydGlvbiBwb2ludAogICAgICAvLyAgICAgICAgICAgIC0tLS0tLS0tLS0tICAgfAogICAgICAvLyAyLiBUaGUgdG9rZW4gZW5kcyBwcmVjaXNlbHkgYXQgdGhlIGluc2VydGlvbiBwb2ludAogICAgICAvLyAgICAgICAgICAgIC0tLS0tLS0tLS0tfAogICAgICAvLyAzLiBUaGUgdG9rZW4gY29udGFpbnMgdGhlIGluc2VydGlvbiBwb2ludAogICAgICAvLyAgICAgICAgICAgIC0tLS0tfC0tLS0tLQogICAgICAvLyA0LiBUaGUgdG9rZW4gc3RhcnRzIHByZWNpc2VseSBhdCB0aGUgaW5zZXJ0aW9uIHBvaW50CiAgICAgIC8vICAgICAgICAgICAgfC0tLS0tLS0tLS0tCiAgICAgIC8vIDUuIFRoZSB0b2tlbiBpcyBjb21wbGV0ZWx5IGFmdGVyIHRoZSBpbnNlcnRpb24gcG9pbnQKICAgICAgLy8gICAgICAgICAgICB8ICAgLS0tLS0tLS0tLS0KICAgICAgLy8KICAgICAgdmFyIGlzSW5zZXJ0aW5nUHJlY2lzZWx5T25lV29yZENoYXJhY3RlciA9IGVvbENvdW50ID09PSAwICYmIGZpcnN0TGluZUxlbmd0aCA9PT0gMSAmJiAoZmlyc3RDaGFyQ29kZSA+PSA0OCAvKiBDaGFyQ29kZS5EaWdpdDAgKi8gJiYgZmlyc3RDaGFyQ29kZSA8PSA1NyAvKiBDaGFyQ29kZS5EaWdpdDkgKi8gfHwgZmlyc3RDaGFyQ29kZSA+PSA2NSAvKiBDaGFyQ29kZS5BICovICYmIGZpcnN0Q2hhckNvZGUgPD0gOTAgLyogQ2hhckNvZGUuWiAqLyB8fCBmaXJzdENoYXJDb2RlID49IDk3IC8qIENoYXJDb2RlLmEgKi8gJiYgZmlyc3RDaGFyQ29kZSA8PSAxMjIgLyogQ2hhckNvZGUueiAqLyk7CiAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl90b2tlbnM7CiAgICAgIHZhciB0b2tlbkNvdW50ID0gdGhpcy5fdG9rZW5Db3VudDsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbkNvdW50OyBpKyspIHsKICAgICAgICB2YXIgb2Zmc2V0ID0gNCAqIGk7CiAgICAgICAgdmFyIHRva2VuRGVsdGFMaW5lID0gdG9rZW5zW29mZnNldF07CiAgICAgICAgdmFyIHRva2VuU3RhcnRDaGFyYWN0ZXIgPSB0b2tlbnNbb2Zmc2V0ICsgMV07CiAgICAgICAgdmFyIHRva2VuRW5kQ2hhcmFjdGVyID0gdG9rZW5zW29mZnNldCArIDJdOwogICAgICAgIGlmICh0b2tlbkRlbHRhTGluZSA8IGRlbHRhTGluZSB8fCB0b2tlbkRlbHRhTGluZSA9PT0gZGVsdGFMaW5lICYmIHRva2VuRW5kQ2hhcmFjdGVyIDwgY2hhcmFjdGVyKSB7CiAgICAgICAgICAvLyAxLiBUaGUgdG9rZW4gaXMgY29tcGxldGVseSBiZWZvcmUgdGhlIGluc2VydGlvbiBwb2ludAogICAgICAgICAgLy8gPT4gbm90aGluZyB0byBkbwogICAgICAgICAgY29udGludWU7CiAgICAgICAgfSBlbHNlIGlmICh0b2tlbkRlbHRhTGluZSA9PT0gZGVsdGFMaW5lICYmIHRva2VuRW5kQ2hhcmFjdGVyID09PSBjaGFyYWN0ZXIpIHsKICAgICAgICAgIC8vIDIuIFRoZSB0b2tlbiBlbmRzIHByZWNpc2VseSBhdCB0aGUgaW5zZXJ0aW9uIHBvaW50CiAgICAgICAgICAvLyA9PiBleHBhbmQgdGhlIGVuZCBjaGFyYWN0ZXIgb25seSBpZiBpbnNlcnRpbmcgcHJlY2lzZWx5IG9uZSBjaGFyYWN0ZXIgdGhhdCBpcyBhIHdvcmQgY2hhcmFjdGVyCiAgICAgICAgICBpZiAoaXNJbnNlcnRpbmdQcmVjaXNlbHlPbmVXb3JkQ2hhcmFjdGVyKSB7CiAgICAgICAgICAgIHRva2VuRW5kQ2hhcmFjdGVyICs9IDE7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHRva2VuRGVsdGFMaW5lID09PSBkZWx0YUxpbmUgJiYgdG9rZW5TdGFydENoYXJhY3RlciA8IGNoYXJhY3RlciAmJiBjaGFyYWN0ZXIgPCB0b2tlbkVuZENoYXJhY3RlcikgewogICAgICAgICAgLy8gMy4gVGhlIHRva2VuIGNvbnRhaW5zIHRoZSBpbnNlcnRpb24gcG9pbnQKICAgICAgICAgIGlmIChlb2xDb3VudCA9PT0gMCkgewogICAgICAgICAgICAvLyA9PiBqdXN0IGV4cGFuZCB0aGUgZW5kIGNoYXJhY3RlcgogICAgICAgICAgICB0b2tlbkVuZENoYXJhY3RlciArPSBmaXJzdExpbmVMZW5ndGg7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAvLyA9PiBjdXQgb2ZmIHRoZSB0b2tlbgogICAgICAgICAgICB0b2tlbkVuZENoYXJhY3RlciA9IGNoYXJhY3RlcjsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8gNC4gb3IgNS4KICAgICAgICAgIGlmICh0b2tlbkRlbHRhTGluZSA9PT0gZGVsdGFMaW5lICYmIHRva2VuU3RhcnRDaGFyYWN0ZXIgPT09IGNoYXJhY3RlcikgewogICAgICAgICAgICAvLyA0LiBUaGUgdG9rZW4gc3RhcnRzIHByZWNpc2VseSBhdCB0aGUgaW5zZXJ0aW9uIHBvaW50CiAgICAgICAgICAgIC8vID0+IGdyb3cgdGhlIHRva2VuIChieSBrZWVwaW5nIGl0cyBzdGFydCBjb25zdGFudCkgb25seSBpZiBpbnNlcnRpbmcgcHJlY2lzZWx5IG9uZSBjaGFyYWN0ZXIgdGhhdCBpcyBhIHdvcmQgY2hhcmFjdGVyCiAgICAgICAgICAgIC8vID0+IG90aGVyd2lzZSBiZWhhdmUgYXMgaW4gY2FzZSA1LgogICAgICAgICAgICBpZiAoaXNJbnNlcnRpbmdQcmVjaXNlbHlPbmVXb3JkQ2hhcmFjdGVyKSB7CiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIC8vID0+IHRoZSB0b2tlbiBtdXN0IG1vdmUgYW5kIGtlZXAgaXRzIHNpemUgY29uc3RhbnQKICAgICAgICAgIGlmICh0b2tlbkRlbHRhTGluZSA9PT0gZGVsdGFMaW5lKSB7CiAgICAgICAgICAgIHRva2VuRGVsdGFMaW5lICs9IGVvbENvdW50OwogICAgICAgICAgICAvLyB0aGlzIHRva2VuIGlzIG9uIHRoZSBsaW5lIHdoZXJlIHRoZSBpbnNlcnRpb24gaXMgdGFraW5nIHBsYWNlCiAgICAgICAgICAgIGlmIChlb2xDb3VudCA9PT0gMCkgewogICAgICAgICAgICAgIHRva2VuU3RhcnRDaGFyYWN0ZXIgKz0gZmlyc3RMaW5lTGVuZ3RoOwogICAgICAgICAgICAgIHRva2VuRW5kQ2hhcmFjdGVyICs9IGZpcnN0TGluZUxlbmd0aDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB2YXIgdG9rZW5MZW5ndGggPSB0b2tlbkVuZENoYXJhY3RlciAtIHRva2VuU3RhcnRDaGFyYWN0ZXI7CiAgICAgICAgICAgICAgdG9rZW5TdGFydENoYXJhY3RlciA9IGxhc3RMaW5lTGVuZ3RoICsgKHRva2VuU3RhcnRDaGFyYWN0ZXIgLSBjaGFyYWN0ZXIpOwogICAgICAgICAgICAgIHRva2VuRW5kQ2hhcmFjdGVyID0gdG9rZW5TdGFydENoYXJhY3RlciArIHRva2VuTGVuZ3RoOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0b2tlbkRlbHRhTGluZSArPSBlb2xDb3VudDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdG9rZW5zW29mZnNldF0gPSB0b2tlbkRlbHRhTGluZTsKICAgICAgICB0b2tlbnNbb2Zmc2V0ICsgMV0gPSB0b2tlblN0YXJ0Q2hhcmFjdGVyOwogICAgICAgIHRva2Vuc1tvZmZzZXQgKyAyXSA9IHRva2VuRW5kQ2hhcmFjdGVyOwogICAgICB9CiAgICB9CiAgfV0pOwogIHJldHVybiBTcGFyc2VNdWx0aWxpbmVUb2tlbnNTdG9yYWdlOwp9KCk7CmV4cG9ydCB2YXIgU3BhcnNlTGluZVRva2VucyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7CiAgZnVuY3Rpb24gU3BhcnNlTGluZVRva2Vucyh0b2tlbnMpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcGFyc2VMaW5lVG9rZW5zKTsKICAgIHRoaXMuX3Rva2VucyA9IHRva2VuczsKICB9CiAgX2NyZWF0ZUNsYXNzKFNwYXJzZUxpbmVUb2tlbnMsIFt7CiAgICBrZXk6ICJnZXRDb3VudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q291bnQoKSB7CiAgICAgIHJldHVybiB0aGlzLl90b2tlbnMubGVuZ3RoIC8gNDsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJnZXRTdGFydENoYXJhY3RlciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhcnRDaGFyYWN0ZXIodG9rZW5JbmRleCkgewogICAgICByZXR1cm4gdGhpcy5fdG9rZW5zWzQgKiB0b2tlbkluZGV4ICsgMV07CiAgICB9CiAgfSwgewogICAga2V5OiAiZ2V0RW5kQ2hhcmFjdGVyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbmRDaGFyYWN0ZXIodG9rZW5JbmRleCkgewogICAgICByZXR1cm4gdGhpcy5fdG9rZW5zWzQgKiB0b2tlbkluZGV4ICsgMl07CiAgICB9CiAgfSwgewogICAga2V5OiAiZ2V0TWV0YWRhdGEiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1ldGFkYXRhKHRva2VuSW5kZXgpIHsKICAgICAgcmV0dXJuIHRoaXMuX3Rva2Vuc1s0ICogdG9rZW5JbmRleCArIDNdOwogICAgfQogIH1dKTsKICByZXR1cm4gU3BhcnNlTGluZVRva2VuczsKfSgpOw=="},{"version":3,"names":["Position","Range","countEOL","SparseMultilineTokens","startLineNumber","tokens","_startLineNumber","_tokens","_endLineNumber","getMaxDeltaLine","toString","isEmpty","lineNumber","getLineTokens","deltaRange","getRange","startColumn","endLineNumber","endColumn","range","startLineIndex","endLineIndex","removeTokens","_updateEndLineNumber","split","a","b","bDeltaLine","text","eolCount","firstLineLength","lastLineLength","acceptEdit","length","charCodeAt","firstCharCode","_acceptDeleteRange","_acceptInsertText","firstLineIndex","lastLineIndex","deletedLinesCount","tokenMaxDeltaLine","clear","deletedBefore","acceptDeleteRange","position","lineIndex","acceptInsertText","column","SparseMultilineTokensStorage","_tokenCount","pieces","i","push","_getDeltaLine","_getStartCharacter","_getEndCharacter","join","tokenCount","_getTokenCount","startChar","maxDeltaLine","endChar","tokenIndex","deltaLine","low","high","mid","Math","floor","midDeltaLine","min","max","SparseLineTokens","subarray","startDeltaLine","endDeltaLine","newTokenCount","hasDeletedTokens","firstDeltaLine","srcOffset","tokenDeltaLine","tokenStartCharacter","tokenEndCharacter","tokenMetadata","destOffset","aTokens","bTokens","destTokens","destFirstDeltaLine","Uint32Array","horizontalShiftForFirstLineTokens","startCharacter","endCharacter","deletedLineCount","Error","character","isInsertingPreciselyOneWordCharacter","offset","tokenLength"],"sources":["/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseMultilineTokens.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { countEOL } from '../core/eolCounter.js';\n/**\n * Represents sparse tokens over a contiguous range of lines.\n */\nexport class SparseMultilineTokens {\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    static create(startLineNumber, tokens) {\n        return new SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));\n    }\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._endLineNumber;\n    }\n    toString() {\n        return this._tokens.toString(this._startLineNumber);\n    }\n    _updateEndLineNumber() {\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    isEmpty() {\n        return this._tokens.isEmpty();\n    }\n    getLineTokens(lineNumber) {\n        if (this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber) {\n            return this._tokens.getLineTokens(lineNumber - this._startLineNumber);\n        }\n        return null;\n    }\n    getRange() {\n        const deltaRange = this._tokens.getRange();\n        if (!deltaRange) {\n            return deltaRange;\n        }\n        return new Range(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n    }\n    removeTokens(range) {\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        this._startLineNumber += this._tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        this._updateEndLineNumber();\n    }\n    split(range) {\n        // split tokens to two:\n        // a) all the tokens before `range`\n        // b) all the tokens after `range`\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        const [a, b, bDeltaLine] = this._tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        return [new SparseMultilineTokens(this._startLineNumber, a), new SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];\n    }\n    applyEdit(range, text) {\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* CharCode.Null */);\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n        this._updateEndLineNumber();\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            // Nothing to delete\n            return;\n        }\n        const firstLineIndex = range.startLineNumber - this._startLineNumber;\n        const lastLineIndex = range.endLineNumber - this._startLineNumber;\n        if (lastLineIndex < 0) {\n            // this deletion occurs entirely before this block, so we only need to adjust line numbers\n            const deletedLinesCount = lastLineIndex - firstLineIndex;\n            this._startLineNumber -= deletedLinesCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (firstLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion occurs entirely after this block, so there is nothing to do\n            return;\n        }\n        if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion completely encompasses this block\n            this._startLineNumber = 0;\n            this._tokens.clear();\n            return;\n        }\n        if (firstLineIndex < 0) {\n            const deletedBefore = -firstLineIndex;\n            this._startLineNumber -= deletedBefore;\n            this._tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n        }\n        else {\n            this._tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n        }\n    }\n    _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - this._startLineNumber;\n        if (lineIndex < 0) {\n            // this insertion occurs before this block, so we only need to adjust line numbers\n            this._startLineNumber += eolCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (lineIndex >= tokenMaxDeltaLine + 1) {\n            // this insertion occurs after this block, so there is nothing to do\n            return;\n        }\n        this._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n    }\n}\nclass SparseMultilineTokensStorage {\n    constructor(tokens) {\n        this._tokens = tokens;\n        this._tokenCount = tokens.length / 4;\n    }\n    toString(startLineNumber) {\n        const pieces = [];\n        for (let i = 0; i < this._tokenCount; i++) {\n            pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\n        }\n        return `[${pieces.join(',')}]`;\n    }\n    getMaxDeltaLine() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return -1;\n        }\n        return this._getDeltaLine(tokenCount - 1);\n    }\n    getRange() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return null;\n        }\n        const startChar = this._getStartCharacter(0);\n        const maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n        const endChar = this._getEndCharacter(tokenCount - 1);\n        return new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n    }\n    _getTokenCount() {\n        return this._tokenCount;\n    }\n    _getDeltaLine(tokenIndex) {\n        return this._tokens[4 * tokenIndex];\n    }\n    _getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    _getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    isEmpty() {\n        return (this._getTokenCount() === 0);\n    }\n    getLineTokens(deltaLine) {\n        let low = 0;\n        let high = this._getTokenCount() - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const midDeltaLine = this._getDeltaLine(mid);\n            if (midDeltaLine < deltaLine) {\n                low = mid + 1;\n            }\n            else if (midDeltaLine > deltaLine) {\n                high = mid - 1;\n            }\n            else {\n                let min = mid;\n                while (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n                    min--;\n                }\n                let max = mid;\n                while (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n                    max++;\n                }\n                return new SparseLineTokens(this._tokens.subarray(4 * min, 4 * max + 4));\n            }\n        }\n        if (this._getDeltaLine(low) === deltaLine) {\n            return new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4));\n        }\n        return null;\n    }\n    clear() {\n        this._tokenCount = 0;\n    }\n    removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        let firstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))\n                && (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                hasDeletedTokens = true;\n            }\n            else {\n                if (newTokenCount === 0) {\n                    firstDeltaLine = tokenDeltaLine;\n                }\n                if (hasDeletedTokens) {\n                    // must move the token to the left\n                    const destOffset = 4 * newTokenCount;\n                    tokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n                    tokens[destOffset + 1] = tokenStartCharacter;\n                    tokens[destOffset + 2] = tokenEndCharacter;\n                    tokens[destOffset + 3] = tokenMetadata;\n                }\n                newTokenCount++;\n            }\n        }\n        this._tokenCount = newTokenCount;\n        return firstDeltaLine;\n    }\n    split(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const aTokens = [];\n        const bTokens = [];\n        let destTokens = aTokens;\n        let destOffset = 0;\n        let destFirstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {\n                if ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                    // this token is touching the range\n                    continue;\n                }\n                else {\n                    // this token is after the range\n                    if (destTokens !== bTokens) {\n                        // this token is the first token after the range\n                        destTokens = bTokens;\n                        destOffset = 0;\n                        destFirstDeltaLine = tokenDeltaLine;\n                    }\n                }\n            }\n            destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n            destTokens[destOffset++] = tokenStartCharacter;\n            destTokens[destOffset++] = tokenEndCharacter;\n            destTokens[destOffset++] = tokenMetadata;\n        }\n        return [new SparseMultilineTokensStorage(new Uint32Array(aTokens)), new SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];\n    }\n    acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\n        // This is a bit complex, here are the cases I used to think about this:\n        //\n        // 1. The token starts before the deletion range\n        // 1a. The token is completely before the deletion range\n        //               -----------\n        //                          xxxxxxxxxxx\n        // 1b. The token starts before, the deletion range ends after the token\n        //               -----------\n        //                      xxxxxxxxxxx\n        // 1c. The token starts before, the deletion range ends precisely with the token\n        //               ---------------\n        //                      xxxxxxxx\n        // 1d. The token starts before, the deletion range is inside the token\n        //               ---------------\n        //                    xxxxx\n        //\n        // 2. The token starts at the same position with the deletion range\n        // 2a. The token starts at the same position, and ends inside the deletion range\n        //               -------\n        //               xxxxxxxxxxx\n        // 2b. The token starts at the same position, and ends at the same position as the deletion range\n        //               ----------\n        //               xxxxxxxxxx\n        // 2c. The token starts at the same position, and ends after the deletion range\n        //               -------------\n        //               xxxxxxx\n        //\n        // 3. The token starts inside the deletion range\n        // 3a. The token is inside the deletion range\n        //                -------\n        //             xxxxxxxxxxxxx\n        // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n        //                ----------\n        //             xxxxxxxxxxxxx\n        // 3c. The token starts inside the deletion range, and ends after the deletion range\n        //                ------------\n        //             xxxxxxxxxxx\n        //\n        // 4. The token starts after the deletion range\n        //                  -----------\n        //          xxxxxxxx\n        //\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const deletedLineCount = (endDeltaLine - startDeltaLine);\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            let tokenDeltaLine = tokens[srcOffset];\n            let tokenStartCharacter = tokens[srcOffset + 1];\n            let tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\n                // 1a. The token is completely before the deletion range\n                // => nothing to do\n                newTokenCount++;\n                continue;\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n                // 1b, 1c, 1d\n                // => the token survives, but it needs to shrink\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 1d. The token starts before, the deletion range is inside the token\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 1b. The token starts before, the deletion range ends after the token\n                    // 1c. The token starts before, the deletion range ends precisely with the token\n                    // => the token shrinks its ending to the deletion start\n                    tokenEndCharacter = startCharacter;\n                }\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n                // 2a, 2b, 2c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 2c. The token starts at the same position, and ends after the deletion range\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 2a. The token starts at the same position, and ends inside the deletion range\n                    // 2b. The token starts at the same position, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\n                // 3a, 3b, 3c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 3c. The token starts inside the deletion range, and ends after the deletion range\n                    // => the token moves left and shrinks\n                    if (tokenDeltaLine === startDeltaLine) {\n                        // the deletion started on the same line as the token\n                        // => the token moves left and shrinks\n                        tokenStartCharacter = startCharacter;\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n                    }\n                    else {\n                        // the deletion started on a line above the token\n                        // => the token moves to the beginning of the line\n                        tokenStartCharacter = 0;\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n                    }\n                }\n                else {\n                    // 3a. The token is inside the deletion range\n                    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine > endDeltaLine) {\n                // 4. (partial) The token starts after the deletion range, on a line below...\n                if (deletedLineCount === 0 && !hasDeletedTokens) {\n                    // early stop, there is no need to walk all the tokens and do nothing...\n                    newTokenCount = tokenCount;\n                    break;\n                }\n                tokenDeltaLine -= deletedLineCount;\n            }\n            else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n                // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n                if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n                    tokenStartCharacter += horizontalShiftForFirstLineTokens;\n                    tokenEndCharacter += horizontalShiftForFirstLineTokens;\n                }\n                tokenDeltaLine -= deletedLineCount;\n                tokenStartCharacter -= (endCharacter - startCharacter);\n                tokenEndCharacter -= (endCharacter - startCharacter);\n            }\n            else {\n                throw new Error(`Not possible!`);\n            }\n            const destOffset = 4 * newTokenCount;\n            tokens[destOffset] = tokenDeltaLine;\n            tokens[destOffset + 1] = tokenStartCharacter;\n            tokens[destOffset + 2] = tokenEndCharacter;\n            tokens[destOffset + 3] = tokenMetadata;\n            newTokenCount++;\n        }\n        this._tokenCount = newTokenCount;\n    }\n    acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        // Here are the cases I used to think about this:\n        //\n        // 1. The token is completely before the insertion point\n        //            -----------   |\n        // 2. The token ends precisely at the insertion point\n        //            -----------|\n        // 3. The token contains the insertion point\n        //            -----|------\n        // 4. The token starts precisely at the insertion point\n        //            |-----------\n        // 5. The token is completely after the insertion point\n        //            |   -----------\n        //\n        const isInsertingPreciselyOneWordCharacter = (eolCount === 0\n            && firstLineLength === 1\n            && ((firstCharCode >= 48 /* CharCode.Digit0 */ && firstCharCode <= 57 /* CharCode.Digit9 */)\n                || (firstCharCode >= 65 /* CharCode.A */ && firstCharCode <= 90 /* CharCode.Z */)\n                || (firstCharCode >= 97 /* CharCode.a */ && firstCharCode <= 122 /* CharCode.z */)));\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        for (let i = 0; i < tokenCount; i++) {\n            const offset = 4 * i;\n            let tokenDeltaLine = tokens[offset];\n            let tokenStartCharacter = tokens[offset + 1];\n            let tokenEndCharacter = tokens[offset + 2];\n            if (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\n                // 1. The token is completely before the insertion point\n                // => nothing to do\n                continue;\n            }\n            else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n                // 2. The token ends precisely at the insertion point\n                // => expand the end character only if inserting precisely one character that is a word character\n                if (isInsertingPreciselyOneWordCharacter) {\n                    tokenEndCharacter += 1;\n                }\n                else {\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n                // 3. The token contains the insertion point\n                if (eolCount === 0) {\n                    // => just expand the end character\n                    tokenEndCharacter += firstLineLength;\n                }\n                else {\n                    // => cut off the token\n                    tokenEndCharacter = character;\n                }\n            }\n            else {\n                // 4. or 5.\n                if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n                    // 4. The token starts precisely at the insertion point\n                    // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n                    // => otherwise behave as in case 5.\n                    if (isInsertingPreciselyOneWordCharacter) {\n                        continue;\n                    }\n                }\n                // => the token must move and keep its size constant\n                if (tokenDeltaLine === deltaLine) {\n                    tokenDeltaLine += eolCount;\n                    // this token is on the line where the insertion is taking place\n                    if (eolCount === 0) {\n                        tokenStartCharacter += firstLineLength;\n                        tokenEndCharacter += firstLineLength;\n                    }\n                    else {\n                        const tokenLength = tokenEndCharacter - tokenStartCharacter;\n                        tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n                        tokenEndCharacter = tokenStartCharacter + tokenLength;\n                    }\n                }\n                else {\n                    tokenDeltaLine += eolCount;\n                }\n            }\n            tokens[offset] = tokenDeltaLine;\n            tokens[offset + 1] = tokenStartCharacter;\n            tokens[offset + 2] = tokenEndCharacter;\n        }\n    }\n}\nexport class SparseLineTokens {\n    constructor(tokens) {\n        this._tokens = tokens;\n    }\n    getCount() {\n        return this._tokens.length / 4;\n    }\n    getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    getMetadata(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 3];\n    }\n}\n"],"mappings":"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"}]}