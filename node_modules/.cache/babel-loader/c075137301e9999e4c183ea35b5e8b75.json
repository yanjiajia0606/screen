{"remainingRequest":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/thread-loader/dist/cjs.js!/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js!/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js","dependencies":[{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/babel.config.js","mtime":1668271197000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js","mtime":456789000000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9Vc2Vycy95YW5qaWFqaWEvRGVza3RvcC93b3Jrc3BhY2UvYXZ1ZS1kYXRhLW5ldy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlci5qcyI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiL1VzZXJzL3lhbmppYWppYS9EZXNrdG9wL3dvcmtzcGFjZS9hdnVlLWRhdGEtbmV3L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjay5qcyI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiL1VzZXJzL3lhbmppYWppYS9EZXNrdG9wL3dvcmtzcGFjZS9hdnVlLWRhdGEtbmV3L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNvcnQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS1idWZmZXIuc2xpY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDMyLWFycmF5LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuYXQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5jb3B5LXdpdGhpbi5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsbC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbHRlci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWluZGV4LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1sYXN0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1sYXN0LWluZGV4LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZm9yLWVhY2guanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlcy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluZGV4LW9mLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubGFzdC1pbmRleC1vZi5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lm1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZS1yaWdodC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJldmVyc2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zbGljZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvbWUuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc3ViYXJyYXkuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1sb2NhbGUtc3RyaW5nLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucHVzaC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5wYWQtc3RhcnQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzIjsKLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi4KICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovCmltcG9ydCAqIGFzIHN0cmluZ3MgZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vc3RyaW5ncy5qcyc7CmltcG9ydCB7IGNyZWF0ZVN0cmluZ0J1aWxkZXIgfSBmcm9tICcuLi9jb3JlL3N0cmluZ0J1aWxkZXIuanMnOwppbXBvcnQgeyBMaW5lRGVjb3JhdGlvbiwgTGluZURlY29yYXRpb25zTm9ybWFsaXplciB9IGZyb20gJy4vbGluZURlY29yYXRpb25zLmpzJzsKaW1wb3J0IHsgTGluZVBhcnQgfSBmcm9tICcuL2xpbmVQYXJ0LmpzJzsKZXhwb3J0IHZhciBMaW5lUmFuZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIGZ1bmN0aW9uIExpbmVSYW5nZShzdGFydEluZGV4LCBlbmRJbmRleCkgewogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmVSYW5nZSk7CiAgICB0aGlzLnN0YXJ0T2Zmc2V0ID0gc3RhcnRJbmRleDsKICAgIHRoaXMuZW5kT2Zmc2V0ID0gZW5kSW5kZXg7CiAgfQogIF9jcmVhdGVDbGFzcyhMaW5lUmFuZ2UsIFt7CiAgICBrZXk6ICJlcXVhbHMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhvdGhlckxpbmVSYW5nZSkgewogICAgICByZXR1cm4gdGhpcy5zdGFydE9mZnNldCA9PT0gb3RoZXJMaW5lUmFuZ2Uuc3RhcnRPZmZzZXQgJiYgdGhpcy5lbmRPZmZzZXQgPT09IG90aGVyTGluZVJhbmdlLmVuZE9mZnNldDsKICAgIH0KICB9XSk7CiAgcmV0dXJuIExpbmVSYW5nZTsKfSgpOwpleHBvcnQgdmFyIFJlbmRlckxpbmVJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7CiAgZnVuY3Rpb24gUmVuZGVyTGluZUlucHV0KHVzZU1vbm9zcGFjZU9wdGltaXphdGlvbnMsIGNhblVzZUhhbGZ3aWR0aFJpZ2h0d2FyZHNBcnJvdywgbGluZUNvbnRlbnQsIGNvbnRpbnVlc1dpdGhXcmFwcGVkTGluZSwgaXNCYXNpY0FTQ0lJLCBjb250YWluc1JUTCwgZmF1eEluZGVudExlbmd0aCwgbGluZVRva2VucywgbGluZURlY29yYXRpb25zLCB0YWJTaXplLCBzdGFydFZpc2libGVDb2x1bW4sIHNwYWNlV2lkdGgsIG1pZGRvdFdpZHRoLCB3c21pZGRvdFdpZHRoLCBzdG9wUmVuZGVyaW5nTGluZUFmdGVyLCByZW5kZXJXaGl0ZXNwYWNlLCByZW5kZXJDb250cm9sQ2hhcmFjdGVycywgZm9udExpZ2F0dXJlcywgc2VsZWN0aW9uc09uTGluZSkgewogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbmRlckxpbmVJbnB1dCk7CiAgICB0aGlzLnVzZU1vbm9zcGFjZU9wdGltaXphdGlvbnMgPSB1c2VNb25vc3BhY2VPcHRpbWl6YXRpb25zOwogICAgdGhpcy5jYW5Vc2VIYWxmd2lkdGhSaWdodHdhcmRzQXJyb3cgPSBjYW5Vc2VIYWxmd2lkdGhSaWdodHdhcmRzQXJyb3c7CiAgICB0aGlzLmxpbmVDb250ZW50ID0gbGluZUNvbnRlbnQ7CiAgICB0aGlzLmNvbnRpbnVlc1dpdGhXcmFwcGVkTGluZSA9IGNvbnRpbnVlc1dpdGhXcmFwcGVkTGluZTsKICAgIHRoaXMuaXNCYXNpY0FTQ0lJID0gaXNCYXNpY0FTQ0lJOwogICAgdGhpcy5jb250YWluc1JUTCA9IGNvbnRhaW5zUlRMOwogICAgdGhpcy5mYXV4SW5kZW50TGVuZ3RoID0gZmF1eEluZGVudExlbmd0aDsKICAgIHRoaXMubGluZVRva2VucyA9IGxpbmVUb2tlbnM7CiAgICB0aGlzLmxpbmVEZWNvcmF0aW9ucyA9IGxpbmVEZWNvcmF0aW9ucy5zb3J0KExpbmVEZWNvcmF0aW9uLmNvbXBhcmUpOwogICAgdGhpcy50YWJTaXplID0gdGFiU2l6ZTsKICAgIHRoaXMuc3RhcnRWaXNpYmxlQ29sdW1uID0gc3RhcnRWaXNpYmxlQ29sdW1uOwogICAgdGhpcy5zcGFjZVdpZHRoID0gc3BhY2VXaWR0aDsKICAgIHRoaXMuc3RvcFJlbmRlcmluZ0xpbmVBZnRlciA9IHN0b3BSZW5kZXJpbmdMaW5lQWZ0ZXI7CiAgICB0aGlzLnJlbmRlcldoaXRlc3BhY2UgPSByZW5kZXJXaGl0ZXNwYWNlID09PSAnYWxsJyA/IDQgLyogUmVuZGVyV2hpdGVzcGFjZS5BbGwgKi8gOiByZW5kZXJXaGl0ZXNwYWNlID09PSAnYm91bmRhcnknID8gMSAvKiBSZW5kZXJXaGl0ZXNwYWNlLkJvdW5kYXJ5ICovIDogcmVuZGVyV2hpdGVzcGFjZSA9PT0gJ3NlbGVjdGlvbicgPyAyIC8qIFJlbmRlcldoaXRlc3BhY2UuU2VsZWN0aW9uICovIDogcmVuZGVyV2hpdGVzcGFjZSA9PT0gJ3RyYWlsaW5nJyA/IDMgLyogUmVuZGVyV2hpdGVzcGFjZS5UcmFpbGluZyAqLyA6IDAgLyogUmVuZGVyV2hpdGVzcGFjZS5Ob25lICovOwogICAgdGhpcy5yZW5kZXJDb250cm9sQ2hhcmFjdGVycyA9IHJlbmRlckNvbnRyb2xDaGFyYWN0ZXJzOwogICAgdGhpcy5mb250TGlnYXR1cmVzID0gZm9udExpZ2F0dXJlczsKICAgIHRoaXMuc2VsZWN0aW9uc09uTGluZSA9IHNlbGVjdGlvbnNPbkxpbmUgJiYgc2VsZWN0aW9uc09uTGluZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7CiAgICAgIHJldHVybiBhLnN0YXJ0T2Zmc2V0IDwgYi5zdGFydE9mZnNldCA/IC0xIDogMTsKICAgIH0pOwogICAgdmFyIHdzbWlkZG90RGlmZiA9IE1hdGguYWJzKHdzbWlkZG90V2lkdGggLSBzcGFjZVdpZHRoKTsKICAgIHZhciBtaWRkb3REaWZmID0gTWF0aC5hYnMobWlkZG90V2lkdGggLSBzcGFjZVdpZHRoKTsKICAgIGlmICh3c21pZGRvdERpZmYgPCBtaWRkb3REaWZmKSB7CiAgICAgIHRoaXMucmVuZGVyU3BhY2VXaWR0aCA9IHdzbWlkZG90V2lkdGg7CiAgICAgIHRoaXMucmVuZGVyU3BhY2VDaGFyQ29kZSA9IDB4MkUzMTsgLy8gVSsyRTMxIC0gV09SRCBTRVBBUkFUT1IgTUlERExFIERPVAogICAgfSBlbHNlIHsKICAgICAgdGhpcy5yZW5kZXJTcGFjZVdpZHRoID0gbWlkZG90V2lkdGg7CiAgICAgIHRoaXMucmVuZGVyU3BhY2VDaGFyQ29kZSA9IDB4Qjc7IC8vIFUrMDBCNyAtIE1JRERMRSBET1QKICAgIH0KICB9CiAgX2NyZWF0ZUNsYXNzKFJlbmRlckxpbmVJbnB1dCwgW3sKICAgIGtleTogInNhbWVTZWxlY3Rpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNhbWVTZWxlY3Rpb24ob3RoZXJTZWxlY3Rpb25zKSB7CiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbnNPbkxpbmUgPT09IG51bGwpIHsKICAgICAgICByZXR1cm4gb3RoZXJTZWxlY3Rpb25zID09PSBudWxsOwogICAgICB9CiAgICAgIGlmIChvdGhlclNlbGVjdGlvbnMgPT09IG51bGwpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgICAgaWYgKG90aGVyU2VsZWN0aW9ucy5sZW5ndGggIT09IHRoaXMuc2VsZWN0aW9uc09uTGluZS5sZW5ndGgpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNlbGVjdGlvbnNPbkxpbmUubGVuZ3RoOyBpKyspIHsKICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uc09uTGluZVtpXS5lcXVhbHMob3RoZXJTZWxlY3Rpb25zW2ldKSkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJlcXVhbHMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikgewogICAgICByZXR1cm4gdGhpcy51c2VNb25vc3BhY2VPcHRpbWl6YXRpb25zID09PSBvdGhlci51c2VNb25vc3BhY2VPcHRpbWl6YXRpb25zICYmIHRoaXMuY2FuVXNlSGFsZndpZHRoUmlnaHR3YXJkc0Fycm93ID09PSBvdGhlci5jYW5Vc2VIYWxmd2lkdGhSaWdodHdhcmRzQXJyb3cgJiYgdGhpcy5saW5lQ29udGVudCA9PT0gb3RoZXIubGluZUNvbnRlbnQgJiYgdGhpcy5jb250aW51ZXNXaXRoV3JhcHBlZExpbmUgPT09IG90aGVyLmNvbnRpbnVlc1dpdGhXcmFwcGVkTGluZSAmJiB0aGlzLmlzQmFzaWNBU0NJSSA9PT0gb3RoZXIuaXNCYXNpY0FTQ0lJICYmIHRoaXMuY29udGFpbnNSVEwgPT09IG90aGVyLmNvbnRhaW5zUlRMICYmIHRoaXMuZmF1eEluZGVudExlbmd0aCA9PT0gb3RoZXIuZmF1eEluZGVudExlbmd0aCAmJiB0aGlzLnRhYlNpemUgPT09IG90aGVyLnRhYlNpemUgJiYgdGhpcy5zdGFydFZpc2libGVDb2x1bW4gPT09IG90aGVyLnN0YXJ0VmlzaWJsZUNvbHVtbiAmJiB0aGlzLnNwYWNlV2lkdGggPT09IG90aGVyLnNwYWNlV2lkdGggJiYgdGhpcy5yZW5kZXJTcGFjZVdpZHRoID09PSBvdGhlci5yZW5kZXJTcGFjZVdpZHRoICYmIHRoaXMucmVuZGVyU3BhY2VDaGFyQ29kZSA9PT0gb3RoZXIucmVuZGVyU3BhY2VDaGFyQ29kZSAmJiB0aGlzLnN0b3BSZW5kZXJpbmdMaW5lQWZ0ZXIgPT09IG90aGVyLnN0b3BSZW5kZXJpbmdMaW5lQWZ0ZXIgJiYgdGhpcy5yZW5kZXJXaGl0ZXNwYWNlID09PSBvdGhlci5yZW5kZXJXaGl0ZXNwYWNlICYmIHRoaXMucmVuZGVyQ29udHJvbENoYXJhY3RlcnMgPT09IG90aGVyLnJlbmRlckNvbnRyb2xDaGFyYWN0ZXJzICYmIHRoaXMuZm9udExpZ2F0dXJlcyA9PT0gb3RoZXIuZm9udExpZ2F0dXJlcyAmJiBMaW5lRGVjb3JhdGlvbi5lcXVhbHNBcnIodGhpcy5saW5lRGVjb3JhdGlvbnMsIG90aGVyLmxpbmVEZWNvcmF0aW9ucykgJiYgdGhpcy5saW5lVG9rZW5zLmVxdWFscyhvdGhlci5saW5lVG9rZW5zKSAmJiB0aGlzLnNhbWVTZWxlY3Rpb24ob3RoZXIuc2VsZWN0aW9uc09uTGluZSk7CiAgICB9CiAgfV0pOwogIHJldHVybiBSZW5kZXJMaW5lSW5wdXQ7Cn0oKTsKZXhwb3J0IHZhciBEb21Qb3NpdGlvbiA9IC8qI19fUFVSRV9fKi9fY3JlYXRlQ2xhc3MoZnVuY3Rpb24gRG9tUG9zaXRpb24ocGFydEluZGV4LCBjaGFySW5kZXgpIHsKICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9tUG9zaXRpb24pOwogIHRoaXMucGFydEluZGV4ID0gcGFydEluZGV4OwogIHRoaXMuY2hhckluZGV4ID0gY2hhckluZGV4Owp9KTsKLyoqCiAqIFByb3ZpZGVzIGEgYm90aCBkaXJlY3Rpb24gbWFwcGluZyBiZXR3ZWVuIGEgbGluZSdzIGNoYXJhY3RlciBhbmQgaXRzIHJlbmRlcmVkIHBvc2l0aW9uLgogKi8KZXhwb3J0IHZhciBDaGFyYWN0ZXJNYXBwaW5nID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICBmdW5jdGlvbiBDaGFyYWN0ZXJNYXBwaW5nKGxlbmd0aCwgcGFydENvdW50KSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hhcmFjdGVyTWFwcGluZyk7CiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDsKICAgIHRoaXMuX2RhdGEgPSBuZXcgVWludDMyQXJyYXkodGhpcy5sZW5ndGgpOwogICAgdGhpcy5faG9yaXpvbnRhbE9mZnNldCA9IG5ldyBVaW50MzJBcnJheSh0aGlzLmxlbmd0aCk7CiAgfQogIF9jcmVhdGVDbGFzcyhDaGFyYWN0ZXJNYXBwaW5nLCBbewogICAga2V5OiAic2V0Q29sdW1uSW5mbyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29sdW1uSW5mbyhjb2x1bW4sIHBhcnRJbmRleCwgY2hhckluZGV4LCBob3Jpem9udGFsT2Zmc2V0KSB7CiAgICAgIHZhciBwYXJ0RGF0YSA9IChwYXJ0SW5kZXggPDwgMTYgLyogQ2hhcmFjdGVyTWFwcGluZ0NvbnN0YW50cy5QQVJUX0lOREVYX09GRlNFVCAqLyB8IGNoYXJJbmRleCA8PCAwIC8qIENoYXJhY3Rlck1hcHBpbmdDb25zdGFudHMuQ0hBUl9JTkRFWF9PRkZTRVQgKi8pID4+PiAwOwogICAgICB0aGlzLl9kYXRhW2NvbHVtbiAtIDFdID0gcGFydERhdGE7CiAgICAgIHRoaXMuX2hvcml6b250YWxPZmZzZXRbY29sdW1uIC0gMV0gPSBob3Jpem9udGFsT2Zmc2V0OwogICAgfQogIH0sIHsKICAgIGtleTogImdldEhvcml6b250YWxPZmZzZXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhvcml6b250YWxPZmZzZXQoY29sdW1uKSB7CiAgICAgIGlmICh0aGlzLl9ob3Jpem9udGFsT2Zmc2V0Lmxlbmd0aCA9PT0gMCkgewogICAgICAgIC8vIE5vIGNoYXJhY3RlcnMgb24gdGhpcyBsaW5lCiAgICAgICAgcmV0dXJuIDA7CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMuX2hvcml6b250YWxPZmZzZXRbY29sdW1uIC0gMV07CiAgICB9CiAgfSwgewogICAga2V5OiAiY2hhck9mZnNldFRvUGFydERhdGEiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNoYXJPZmZzZXRUb1BhcnREYXRhKGNoYXJPZmZzZXQpIHsKICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgcmV0dXJuIDA7CiAgICAgIH0KICAgICAgaWYgKGNoYXJPZmZzZXQgPCAwKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbMF07CiAgICAgIH0KICAgICAgaWYgKGNoYXJPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHsKICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVt0aGlzLmxlbmd0aCAtIDFdOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLl9kYXRhW2NoYXJPZmZzZXRdOwogICAgfQogIH0sIHsKICAgIGtleTogImdldERvbVBvc2l0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREb21Qb3NpdGlvbihjb2x1bW4pIHsKICAgICAgdmFyIHBhcnREYXRhID0gdGhpcy5jaGFyT2Zmc2V0VG9QYXJ0RGF0YShjb2x1bW4gLSAxKTsKICAgICAgdmFyIHBhcnRJbmRleCA9IENoYXJhY3Rlck1hcHBpbmcuZ2V0UGFydEluZGV4KHBhcnREYXRhKTsKICAgICAgdmFyIGNoYXJJbmRleCA9IENoYXJhY3Rlck1hcHBpbmcuZ2V0Q2hhckluZGV4KHBhcnREYXRhKTsKICAgICAgcmV0dXJuIG5ldyBEb21Qb3NpdGlvbihwYXJ0SW5kZXgsIGNoYXJJbmRleCk7CiAgICB9CiAgfSwgewogICAga2V5OiAiZ2V0Q29sdW1uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb2x1bW4oZG9tUG9zaXRpb24sIHBhcnRMZW5ndGgpIHsKICAgICAgdmFyIGNoYXJPZmZzZXQgPSB0aGlzLnBhcnREYXRhVG9DaGFyT2Zmc2V0KGRvbVBvc2l0aW9uLnBhcnRJbmRleCwgcGFydExlbmd0aCwgZG9tUG9zaXRpb24uY2hhckluZGV4KTsKICAgICAgcmV0dXJuIGNoYXJPZmZzZXQgKyAxOwogICAgfQogIH0sIHsKICAgIGtleTogInBhcnREYXRhVG9DaGFyT2Zmc2V0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJ0RGF0YVRvQ2hhck9mZnNldChwYXJ0SW5kZXgsIHBhcnRMZW5ndGgsIGNoYXJJbmRleCkgewogICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHsKICAgICAgICByZXR1cm4gMDsKICAgICAgfQogICAgICB2YXIgc2VhcmNoRW50cnkgPSAocGFydEluZGV4IDw8IDE2IC8qIENoYXJhY3Rlck1hcHBpbmdDb25zdGFudHMuUEFSVF9JTkRFWF9PRkZTRVQgKi8gfCBjaGFySW5kZXggPDwgMCAvKiBDaGFyYWN0ZXJNYXBwaW5nQ29uc3RhbnRzLkNIQVJfSU5ERVhfT0ZGU0VUICovKSA+Pj4gMDsKICAgICAgdmFyIG1pbiA9IDA7CiAgICAgIHZhciBtYXggPSB0aGlzLmxlbmd0aCAtIDE7CiAgICAgIHdoaWxlIChtaW4gKyAxIDwgbWF4KSB7CiAgICAgICAgdmFyIG1pZCA9IG1pbiArIG1heCA+Pj4gMTsKICAgICAgICB2YXIgbWlkRW50cnkgPSB0aGlzLl9kYXRhW21pZF07CiAgICAgICAgaWYgKG1pZEVudHJ5ID09PSBzZWFyY2hFbnRyeSkgewogICAgICAgICAgcmV0dXJuIG1pZDsKICAgICAgICB9IGVsc2UgaWYgKG1pZEVudHJ5ID4gc2VhcmNoRW50cnkpIHsKICAgICAgICAgIG1heCA9IG1pZDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbWluID0gbWlkOwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAobWluID09PSBtYXgpIHsKICAgICAgICByZXR1cm4gbWluOwogICAgICB9CiAgICAgIHZhciBtaW5FbnRyeSA9IHRoaXMuX2RhdGFbbWluXTsKICAgICAgdmFyIG1heEVudHJ5ID0gdGhpcy5fZGF0YVttYXhdOwogICAgICBpZiAobWluRW50cnkgPT09IHNlYXJjaEVudHJ5KSB7CiAgICAgICAgcmV0dXJuIG1pbjsKICAgICAgfQogICAgICBpZiAobWF4RW50cnkgPT09IHNlYXJjaEVudHJ5KSB7CiAgICAgICAgcmV0dXJuIG1heDsKICAgICAgfQogICAgICB2YXIgbWluUGFydEluZGV4ID0gQ2hhcmFjdGVyTWFwcGluZy5nZXRQYXJ0SW5kZXgobWluRW50cnkpOwogICAgICB2YXIgbWluQ2hhckluZGV4ID0gQ2hhcmFjdGVyTWFwcGluZy5nZXRDaGFySW5kZXgobWluRW50cnkpOwogICAgICB2YXIgbWF4UGFydEluZGV4ID0gQ2hhcmFjdGVyTWFwcGluZy5nZXRQYXJ0SW5kZXgobWF4RW50cnkpOwogICAgICB2YXIgbWF4Q2hhckluZGV4OwogICAgICBpZiAobWluUGFydEluZGV4ICE9PSBtYXhQYXJ0SW5kZXgpIHsKICAgICAgICAvLyBzaXR0aW5nIGJldHdlZW4gcGFydHMKICAgICAgICBtYXhDaGFySW5kZXggPSBwYXJ0TGVuZ3RoOwogICAgICB9IGVsc2UgewogICAgICAgIG1heENoYXJJbmRleCA9IENoYXJhY3Rlck1hcHBpbmcuZ2V0Q2hhckluZGV4KG1heEVudHJ5KTsKICAgICAgfQogICAgICB2YXIgbWluRW50cnlEaXN0YW5jZSA9IGNoYXJJbmRleCAtIG1pbkNoYXJJbmRleDsKICAgICAgdmFyIG1heEVudHJ5RGlzdGFuY2UgPSBtYXhDaGFySW5kZXggLSBjaGFySW5kZXg7CiAgICAgIGlmIChtaW5FbnRyeURpc3RhbmNlIDw9IG1heEVudHJ5RGlzdGFuY2UpIHsKICAgICAgICByZXR1cm4gbWluOwogICAgICB9CiAgICAgIHJldHVybiBtYXg7CiAgICB9CiAgfV0sIFt7CiAgICBrZXk6ICJnZXRQYXJ0SW5kZXgiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhcnRJbmRleChwYXJ0RGF0YSkgewogICAgICByZXR1cm4gKHBhcnREYXRhICYgNDI5NDkwMTc2MCAvKiBDaGFyYWN0ZXJNYXBwaW5nQ29uc3RhbnRzLlBBUlRfSU5ERVhfTUFTSyAqLykgPj4+IDE2IC8qIENoYXJhY3Rlck1hcHBpbmdDb25zdGFudHMuUEFSVF9JTkRFWF9PRkZTRVQgKi87CiAgICB9CiAgfSwgewogICAga2V5OiAiZ2V0Q2hhckluZGV4IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGFySW5kZXgocGFydERhdGEpIHsKICAgICAgcmV0dXJuIChwYXJ0RGF0YSAmIDY1NTM1IC8qIENoYXJhY3Rlck1hcHBpbmdDb25zdGFudHMuQ0hBUl9JTkRFWF9NQVNLICovKSA+Pj4gMCAvKiBDaGFyYWN0ZXJNYXBwaW5nQ29uc3RhbnRzLkNIQVJfSU5ERVhfT0ZGU0VUICovOwogICAgfQogIH1dKTsKICByZXR1cm4gQ2hhcmFjdGVyTWFwcGluZzsKfSgpOwpleHBvcnQgdmFyIFJlbmRlckxpbmVPdXRwdXQgPSAvKiNfX1BVUkVfXyovX2NyZWF0ZUNsYXNzKGZ1bmN0aW9uIFJlbmRlckxpbmVPdXRwdXQoY2hhcmFjdGVyTWFwcGluZywgY29udGFpbnNSVEwsIGNvbnRhaW5zRm9yZWlnbkVsZW1lbnRzKSB7CiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbmRlckxpbmVPdXRwdXQpOwogIHRoaXMuX3JlbmRlckxpbmVPdXRwdXRCcmFuZCA9IHVuZGVmaW5lZDsKICB0aGlzLmNoYXJhY3Rlck1hcHBpbmcgPSBjaGFyYWN0ZXJNYXBwaW5nOwogIHRoaXMuY29udGFpbnNSVEwgPSBjb250YWluc1JUTDsKICB0aGlzLmNvbnRhaW5zRm9yZWlnbkVsZW1lbnRzID0gY29udGFpbnNGb3JlaWduRWxlbWVudHM7Cn0pOwpleHBvcnQgZnVuY3Rpb24gcmVuZGVyVmlld0xpbmUoaW5wdXQsIHNiKSB7CiAgaWYgKGlucHV0LmxpbmVDb250ZW50Lmxlbmd0aCA9PT0gMCkgewogICAgaWYgKGlucHV0LmxpbmVEZWNvcmF0aW9ucy5sZW5ndGggPiAwKSB7CiAgICAgIC8vIFRoaXMgbGluZSBpcyBlbXB0eSwgYnV0IGl0IGNvbnRhaW5zIGlubGluZSBkZWNvcmF0aW9ucwogICAgICBzYi5hcHBlbmRBU0NJSVN0cmluZygiPHNwYW4+Iik7CiAgICAgIHZhciBiZWZvcmVDb3VudCA9IDA7CiAgICAgIHZhciBhZnRlckNvdW50ID0gMDsKICAgICAgdmFyIGNvbnRhaW5zRm9yZWlnbkVsZW1lbnRzID0gMCAvKiBGb3JlaWduRWxlbWVudFR5cGUuTm9uZSAqLzsKICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGlucHV0LmxpbmVEZWNvcmF0aW9ucyksCiAgICAgICAgX3N0ZXA7CiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBsaW5lRGVjb3JhdGlvbiA9IF9zdGVwLnZhbHVlOwogICAgICAgICAgaWYgKGxpbmVEZWNvcmF0aW9uLnR5cGUgPT09IDEgLyogSW5saW5lRGVjb3JhdGlvblR5cGUuQmVmb3JlICovIHx8IGxpbmVEZWNvcmF0aW9uLnR5cGUgPT09IDIgLyogSW5saW5lRGVjb3JhdGlvblR5cGUuQWZ0ZXIgKi8pIHsKICAgICAgICAgICAgc2IuYXBwZW5kQVNDSUlTdHJpbmcoIjxzcGFuIGNsYXNzPVwiIik7CiAgICAgICAgICAgIHNiLmFwcGVuZEFTQ0lJU3RyaW5nKGxpbmVEZWNvcmF0aW9uLmNsYXNzTmFtZSk7CiAgICAgICAgICAgIHNiLmFwcGVuZEFTQ0lJU3RyaW5nKCJcIj48L3NwYW4+Iik7CiAgICAgICAgICAgIGlmIChsaW5lRGVjb3JhdGlvbi50eXBlID09PSAxIC8qIElubGluZURlY29yYXRpb25UeXBlLkJlZm9yZSAqLykgewogICAgICAgICAgICAgIGNvbnRhaW5zRm9yZWlnbkVsZW1lbnRzIHw9IDEgLyogRm9yZWlnbkVsZW1lbnRUeXBlLkJlZm9yZSAqLzsKICAgICAgICAgICAgICBiZWZvcmVDb3VudCsrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChsaW5lRGVjb3JhdGlvbi50eXBlID09PSAyIC8qIElubGluZURlY29yYXRpb25UeXBlLkFmdGVyICovKSB7CiAgICAgICAgICAgICAgY29udGFpbnNGb3JlaWduRWxlbWVudHMgfD0gMiAvKiBGb3JlaWduRWxlbWVudFR5cGUuQWZ0ZXIgKi87CiAgICAgICAgICAgICAgYWZ0ZXJDb3VudCsrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3IuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvci5mKCk7CiAgICAgIH0KICAgICAgc2IuYXBwZW5kQVNDSUlTdHJpbmcoIjwvc3Bhbj4iKTsKICAgICAgdmFyIGNoYXJhY3Rlck1hcHBpbmcgPSBuZXcgQ2hhcmFjdGVyTWFwcGluZygxLCBiZWZvcmVDb3VudCArIGFmdGVyQ291bnQpOwogICAgICBjaGFyYWN0ZXJNYXBwaW5nLnNldENvbHVtbkluZm8oMSwgYmVmb3JlQ291bnQsIDAsIDApOwogICAgICByZXR1cm4gbmV3IFJlbmRlckxpbmVPdXRwdXQoY2hhcmFjdGVyTWFwcGluZywgZmFsc2UsIGNvbnRhaW5zRm9yZWlnbkVsZW1lbnRzKTsKICAgIH0KICAgIC8vIGNvbXBsZXRlbHkgZW1wdHkgbGluZQogICAgc2IuYXBwZW5kQVNDSUlTdHJpbmcoJzxzcGFuPjxzcGFuPjwvc3Bhbj48L3NwYW4+Jyk7CiAgICByZXR1cm4gbmV3IFJlbmRlckxpbmVPdXRwdXQobmV3IENoYXJhY3Rlck1hcHBpbmcoMCwgMCksIGZhbHNlLCAwIC8qIEZvcmVpZ25FbGVtZW50VHlwZS5Ob25lICovKTsKICB9CgogIHJldHVybiBfcmVuZGVyTGluZShyZXNvbHZlUmVuZGVyTGluZUlucHV0KGlucHV0KSwgc2IpOwp9CmV4cG9ydCB2YXIgUmVuZGVyTGluZU91dHB1dDIgPSAvKiNfX1BVUkVfXyovX2NyZWF0ZUNsYXNzKGZ1bmN0aW9uIFJlbmRlckxpbmVPdXRwdXQyKGNoYXJhY3Rlck1hcHBpbmcsIGh0bWwsIGNvbnRhaW5zUlRMLCBjb250YWluc0ZvcmVpZ25FbGVtZW50cykgewogIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZW5kZXJMaW5lT3V0cHV0Mik7CiAgdGhpcy5jaGFyYWN0ZXJNYXBwaW5nID0gY2hhcmFjdGVyTWFwcGluZzsKICB0aGlzLmh0bWwgPSBodG1sOwogIHRoaXMuY29udGFpbnNSVEwgPSBjb250YWluc1JUTDsKICB0aGlzLmNvbnRhaW5zRm9yZWlnbkVsZW1lbnRzID0gY29udGFpbnNGb3JlaWduRWxlbWVudHM7Cn0pOwpleHBvcnQgZnVuY3Rpb24gcmVuZGVyVmlld0xpbmUyKGlucHV0KSB7CiAgdmFyIHNiID0gY3JlYXRlU3RyaW5nQnVpbGRlcigxMDAwMCk7CiAgdmFyIG91dCA9IHJlbmRlclZpZXdMaW5lKGlucHV0LCBzYik7CiAgcmV0dXJuIG5ldyBSZW5kZXJMaW5lT3V0cHV0MihvdXQuY2hhcmFjdGVyTWFwcGluZywgc2IuYnVpbGQoKSwgb3V0LmNvbnRhaW5zUlRMLCBvdXQuY29udGFpbnNGb3JlaWduRWxlbWVudHMpOwp9CnZhciBSZXNvbHZlZFJlbmRlckxpbmVJbnB1dCA9IC8qI19fUFVSRV9fKi9fY3JlYXRlQ2xhc3MoZnVuY3Rpb24gUmVzb2x2ZWRSZW5kZXJMaW5lSW5wdXQoZm9udElzTW9ub3NwYWNlLCBjYW5Vc2VIYWxmd2lkdGhSaWdodHdhcmRzQXJyb3csIGxpbmVDb250ZW50LCBsZW4sIGlzT3ZlcmZsb3dpbmcsIHBhcnRzLCBjb250YWluc0ZvcmVpZ25FbGVtZW50cywgZmF1eEluZGVudExlbmd0aCwgdGFiU2l6ZSwgc3RhcnRWaXNpYmxlQ29sdW1uLCBjb250YWluc1JUTCwgc3BhY2VXaWR0aCwgcmVuZGVyU3BhY2VDaGFyQ29kZSwgcmVuZGVyV2hpdGVzcGFjZSwgcmVuZGVyQ29udHJvbENoYXJhY3RlcnMpIHsKICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzb2x2ZWRSZW5kZXJMaW5lSW5wdXQpOwogIHRoaXMuZm9udElzTW9ub3NwYWNlID0gZm9udElzTW9ub3NwYWNlOwogIHRoaXMuY2FuVXNlSGFsZndpZHRoUmlnaHR3YXJkc0Fycm93ID0gY2FuVXNlSGFsZndpZHRoUmlnaHR3YXJkc0Fycm93OwogIHRoaXMubGluZUNvbnRlbnQgPSBsaW5lQ29udGVudDsKICB0aGlzLmxlbiA9IGxlbjsKICB0aGlzLmlzT3ZlcmZsb3dpbmcgPSBpc092ZXJmbG93aW5nOwogIHRoaXMucGFydHMgPSBwYXJ0czsKICB0aGlzLmNvbnRhaW5zRm9yZWlnbkVsZW1lbnRzID0gY29udGFpbnNGb3JlaWduRWxlbWVudHM7CiAgdGhpcy5mYXV4SW5kZW50TGVuZ3RoID0gZmF1eEluZGVudExlbmd0aDsKICB0aGlzLnRhYlNpemUgPSB0YWJTaXplOwogIHRoaXMuc3RhcnRWaXNpYmxlQ29sdW1uID0gc3RhcnRWaXNpYmxlQ29sdW1uOwogIHRoaXMuY29udGFpbnNSVEwgPSBjb250YWluc1JUTDsKICB0aGlzLnNwYWNlV2lkdGggPSBzcGFjZVdpZHRoOwogIHRoaXMucmVuZGVyU3BhY2VDaGFyQ29kZSA9IHJlbmRlclNwYWNlQ2hhckNvZGU7CiAgdGhpcy5yZW5kZXJXaGl0ZXNwYWNlID0gcmVuZGVyV2hpdGVzcGFjZTsKICB0aGlzLnJlbmRlckNvbnRyb2xDaGFyYWN0ZXJzID0gcmVuZGVyQ29udHJvbENoYXJhY3RlcnM7CiAgLy8KfSk7CgpmdW5jdGlvbiByZXNvbHZlUmVuZGVyTGluZUlucHV0KGlucHV0KSB7CiAgdmFyIGxpbmVDb250ZW50ID0gaW5wdXQubGluZUNvbnRlbnQ7CiAgdmFyIGlzT3ZlcmZsb3dpbmc7CiAgdmFyIGxlbjsKICBpZiAoaW5wdXQuc3RvcFJlbmRlcmluZ0xpbmVBZnRlciAhPT0gLTEgJiYgaW5wdXQuc3RvcFJlbmRlcmluZ0xpbmVBZnRlciA8IGxpbmVDb250ZW50Lmxlbmd0aCkgewogICAgaXNPdmVyZmxvd2luZyA9IHRydWU7CiAgICBsZW4gPSBpbnB1dC5zdG9wUmVuZGVyaW5nTGluZUFmdGVyOwogIH0gZWxzZSB7CiAgICBpc092ZXJmbG93aW5nID0gZmFsc2U7CiAgICBsZW4gPSBsaW5lQ29udGVudC5sZW5ndGg7CiAgfQogIHZhciB0b2tlbnMgPSB0cmFuc2Zvcm1BbmRSZW1vdmVPdmVyZmxvd2luZyhsaW5lQ29udGVudCwgaW5wdXQuY29udGFpbnNSVEwsIGlucHV0LmxpbmVUb2tlbnMsIGlucHV0LmZhdXhJbmRlbnRMZW5ndGgsIGxlbik7CiAgaWYgKGlucHV0LnJlbmRlckNvbnRyb2xDaGFyYWN0ZXJzICYmICFpbnB1dC5pc0Jhc2ljQVNDSUkpIHsKICAgIC8vIENhbGxpbmcgYGV4dHJhY3RDb250cm9sQ2hhcmFjdGVyc2AgYmVmb3JlIGFkZGluZyAocG9zc2libHkgZW1wdHkpIGxpbmUgcGFydHMKICAgIC8vIGZvciBpbmxpbmUgZGVjb3JhdGlvbnMuIGBleHRyYWN0Q29udHJvbENoYXJhY3RlcnNgIHJlbW92ZXMgZW1wdHkgbGluZSBwYXJ0cy4KICAgIHRva2VucyA9IGV4dHJhY3RDb250cm9sQ2hhcmFjdGVycyhsaW5lQ29udGVudCwgdG9rZW5zKTsKICB9CiAgaWYgKGlucHV0LnJlbmRlcldoaXRlc3BhY2UgPT09IDQgLyogUmVuZGVyV2hpdGVzcGFjZS5BbGwgKi8gfHwgaW5wdXQucmVuZGVyV2hpdGVzcGFjZSA9PT0gMSAvKiBSZW5kZXJXaGl0ZXNwYWNlLkJvdW5kYXJ5ICovIHx8IGlucHV0LnJlbmRlcldoaXRlc3BhY2UgPT09IDIgLyogUmVuZGVyV2hpdGVzcGFjZS5TZWxlY3Rpb24gKi8gJiYgISFpbnB1dC5zZWxlY3Rpb25zT25MaW5lIHx8IGlucHV0LnJlbmRlcldoaXRlc3BhY2UgPT09IDMgLyogUmVuZGVyV2hpdGVzcGFjZS5UcmFpbGluZyAqLykgewogICAgdG9rZW5zID0gX2FwcGx5UmVuZGVyV2hpdGVzcGFjZShpbnB1dCwgbGluZUNvbnRlbnQsIGxlbiwgdG9rZW5zKTsKICB9CiAgdmFyIGNvbnRhaW5zRm9yZWlnbkVsZW1lbnRzID0gMCAvKiBGb3JlaWduRWxlbWVudFR5cGUuTm9uZSAqLzsKICBpZiAoaW5wdXQubGluZURlY29yYXRpb25zLmxlbmd0aCA+IDApIHsKICAgIGZvciAodmFyIGkgPSAwLCBfbGVuID0gaW5wdXQubGluZURlY29yYXRpb25zLmxlbmd0aDsgaSA8IF9sZW47IGkrKykgewogICAgICB2YXIgbGluZURlY29yYXRpb24gPSBpbnB1dC5saW5lRGVjb3JhdGlvbnNbaV07CiAgICAgIGlmIChsaW5lRGVjb3JhdGlvbi50eXBlID09PSAzIC8qIElubGluZURlY29yYXRpb25UeXBlLlJlZ3VsYXJBZmZlY3RpbmdMZXR0ZXJTcGFjaW5nICovKSB7CiAgICAgICAgLy8gUHJldGVuZCB0aGVyZSBhcmUgZm9yZWlnbiBlbGVtZW50cy4uLiBhbHRob3VnaCBub3QgMTAwJSBhY2N1cmF0ZS4KICAgICAgICBjb250YWluc0ZvcmVpZ25FbGVtZW50cyB8PSAxIC8qIEZvcmVpZ25FbGVtZW50VHlwZS5CZWZvcmUgKi87CiAgICAgIH0gZWxzZSBpZiAobGluZURlY29yYXRpb24udHlwZSA9PT0gMSAvKiBJbmxpbmVEZWNvcmF0aW9uVHlwZS5CZWZvcmUgKi8pIHsKICAgICAgICBjb250YWluc0ZvcmVpZ25FbGVtZW50cyB8PSAxIC8qIEZvcmVpZ25FbGVtZW50VHlwZS5CZWZvcmUgKi87CiAgICAgIH0gZWxzZSBpZiAobGluZURlY29yYXRpb24udHlwZSA9PT0gMiAvKiBJbmxpbmVEZWNvcmF0aW9uVHlwZS5BZnRlciAqLykgewogICAgICAgIGNvbnRhaW5zRm9yZWlnbkVsZW1lbnRzIHw9IDIgLyogRm9yZWlnbkVsZW1lbnRUeXBlLkFmdGVyICovOwogICAgICB9CiAgICB9CgogICAgdG9rZW5zID0gX2FwcGx5SW5saW5lRGVjb3JhdGlvbnMobGluZUNvbnRlbnQsIGxlbiwgdG9rZW5zLCBpbnB1dC5saW5lRGVjb3JhdGlvbnMpOwogIH0KICBpZiAoIWlucHV0LmNvbnRhaW5zUlRMKSB7CiAgICAvLyBXZSBjYW4gbmV2ZXIgc3BsaXQgUlRMIHRleHQsIGFzIGl0IHJ1aW5zIHRoZSByZW5kZXJpbmcKICAgIHRva2VucyA9IHNwbGl0TGFyZ2VUb2tlbnMobGluZUNvbnRlbnQsIHRva2VucywgIWlucHV0LmlzQmFzaWNBU0NJSSB8fCBpbnB1dC5mb250TGlnYXR1cmVzKTsKICB9CiAgcmV0dXJuIG5ldyBSZXNvbHZlZFJlbmRlckxpbmVJbnB1dChpbnB1dC51c2VNb25vc3BhY2VPcHRpbWl6YXRpb25zLCBpbnB1dC5jYW5Vc2VIYWxmd2lkdGhSaWdodHdhcmRzQXJyb3csIGxpbmVDb250ZW50LCBsZW4sIGlzT3ZlcmZsb3dpbmcsIHRva2VucywgY29udGFpbnNGb3JlaWduRWxlbWVudHMsIGlucHV0LmZhdXhJbmRlbnRMZW5ndGgsIGlucHV0LnRhYlNpemUsIGlucHV0LnN0YXJ0VmlzaWJsZUNvbHVtbiwgaW5wdXQuY29udGFpbnNSVEwsIGlucHV0LnNwYWNlV2lkdGgsIGlucHV0LnJlbmRlclNwYWNlQ2hhckNvZGUsIGlucHV0LnJlbmRlcldoaXRlc3BhY2UsIGlucHV0LnJlbmRlckNvbnRyb2xDaGFyYWN0ZXJzKTsKfQovKioKICogSW4gdGhlIHJlbmRlcmluZyBwaGFzZSwgY2hhcmFjdGVycyBhcmUgYWx3YXlzIGxvb3BlZCB1bnRpbCB0b2tlbi5lbmRJbmRleC4KICogRW5zdXJlIHRoYXQgYWxsIHRva2VucyBlbmQgYmVmb3JlIGBsZW5gIGFuZCB0aGUgbGFzdCBvbmUgZW5kcyBwcmVjaXNlbHkgYXQgYGxlbmAuCiAqLwpmdW5jdGlvbiB0cmFuc2Zvcm1BbmRSZW1vdmVPdmVyZmxvd2luZyhsaW5lQ29udGVudCwgbGluZUNvbnRhaW5zUlRMLCB0b2tlbnMsIGZhdXhJbmRlbnRMZW5ndGgsIGxlbikgewogIHZhciByZXN1bHQgPSBbXTsKICB2YXIgcmVzdWx0TGVuID0gMDsKICAvLyBUaGUgZmF1eCBpbmRlbnQgcGFydCBvZiB0aGUgbGluZSBzaG91bGQgaGF2ZSBubyB0b2tlbiB0eXBlCiAgaWYgKGZhdXhJbmRlbnRMZW5ndGggPiAwKSB7CiAgICByZXN1bHRbcmVzdWx0TGVuKytdID0gbmV3IExpbmVQYXJ0KGZhdXhJbmRlbnRMZW5ndGgsICcnLCAwLCBmYWxzZSk7CiAgfQogIHZhciBzdGFydE9mZnNldCA9IGZhdXhJbmRlbnRMZW5ndGg7CiAgZm9yICh2YXIgdG9rZW5JbmRleCA9IDAsIHRva2Vuc0xlbiA9IHRva2Vucy5nZXRDb3VudCgpOyB0b2tlbkluZGV4IDwgdG9rZW5zTGVuOyB0b2tlbkluZGV4KyspIHsKICAgIHZhciBlbmRJbmRleCA9IHRva2Vucy5nZXRFbmRPZmZzZXQodG9rZW5JbmRleCk7CiAgICBpZiAoZW5kSW5kZXggPD0gZmF1eEluZGVudExlbmd0aCkgewogICAgICAvLyBUaGUgZmF1eCBpbmRlbnQgcGFydCBvZiB0aGUgbGluZSBzaG91bGQgaGF2ZSBubyB0b2tlbiB0eXBlCiAgICAgIGNvbnRpbnVlOwogICAgfQogICAgdmFyIHR5cGUgPSB0b2tlbnMuZ2V0Q2xhc3NOYW1lKHRva2VuSW5kZXgpOwogICAgaWYgKGVuZEluZGV4ID49IGxlbikgewogICAgICB2YXIgX3Rva2VuQ29udGFpbnNSVEwgPSBsaW5lQ29udGFpbnNSVEwgPyBzdHJpbmdzLmNvbnRhaW5zUlRMKGxpbmVDb250ZW50LnN1YnN0cmluZyhzdGFydE9mZnNldCwgbGVuKSkgOiBmYWxzZTsKICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IG5ldyBMaW5lUGFydChsZW4sIHR5cGUsIDAsIF90b2tlbkNvbnRhaW5zUlRMKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICB2YXIgdG9rZW5Db250YWluc1JUTCA9IGxpbmVDb250YWluc1JUTCA/IHN0cmluZ3MuY29udGFpbnNSVEwobGluZUNvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0T2Zmc2V0LCBlbmRJbmRleCkpIDogZmFsc2U7CiAgICByZXN1bHRbcmVzdWx0TGVuKytdID0gbmV3IExpbmVQYXJ0KGVuZEluZGV4LCB0eXBlLCAwLCB0b2tlbkNvbnRhaW5zUlRMKTsKICAgIHN0YXJ0T2Zmc2V0ID0gZW5kSW5kZXg7CiAgfQogIHJldHVybiByZXN1bHQ7Cn0KLyoqCiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L3ZzY29kZS9pc3N1ZXMvNjg4NS4KICogSXQgYXBwZWFycyB0aGF0IGhhdmluZyB2ZXJ5IGxhcmdlIHNwYW5zIGNhdXNlcyB2ZXJ5IHNsb3cgcmVhZGluZyBvZiBjaGFyYWN0ZXIgcG9zaXRpb25zLgogKiBTbyBoZXJlIHdlIHRyeSB0byBhdm9pZCB0aGF0LgogKi8KZnVuY3Rpb24gc3BsaXRMYXJnZVRva2VucyhsaW5lQ29udGVudCwgdG9rZW5zLCBvbmx5QXRTcGFjZXMpIHsKICB2YXIgbGFzdFRva2VuRW5kSW5kZXggPSAwOwogIHZhciByZXN1bHQgPSBbXTsKICB2YXIgcmVzdWx0TGVuID0gMDsKICBpZiAob25seUF0U3BhY2VzKSB7CiAgICAvLyBTcGxpdCBvbmx5IGF0IHNwYWNlcyA9PiB3ZSBuZWVkIHRvIHdhbGsgZWFjaCBjaGFyYWN0ZXIKICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsKICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldOwogICAgICB2YXIgdG9rZW5FbmRJbmRleCA9IHRva2VuLmVuZEluZGV4OwogICAgICBpZiAobGFzdFRva2VuRW5kSW5kZXggKyA1MCAvKiBDb25zdGFudHMuTG9uZ1Rva2VuICovIDwgdG9rZW5FbmRJbmRleCkgewogICAgICAgIHZhciB0b2tlblR5cGUgPSB0b2tlbi50eXBlOwogICAgICAgIHZhciB0b2tlbk1ldGFkYXRhID0gdG9rZW4ubWV0YWRhdGE7CiAgICAgICAgdmFyIHRva2VuQ29udGFpbnNSVEwgPSB0b2tlbi5jb250YWluc1JUTDsKICAgICAgICB2YXIgbGFzdFNwYWNlT2Zmc2V0ID0gLTE7CiAgICAgICAgdmFyIGN1cnJUb2tlblN0YXJ0ID0gbGFzdFRva2VuRW5kSW5kZXg7CiAgICAgICAgZm9yICh2YXIgaiA9IGxhc3RUb2tlbkVuZEluZGV4OyBqIDwgdG9rZW5FbmRJbmRleDsgaisrKSB7CiAgICAgICAgICBpZiAobGluZUNvbnRlbnQuY2hhckNvZGVBdChqKSA9PT0gMzIgLyogQ2hhckNvZGUuU3BhY2UgKi8pIHsKICAgICAgICAgICAgbGFzdFNwYWNlT2Zmc2V0ID0gajsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChsYXN0U3BhY2VPZmZzZXQgIT09IC0xICYmIGogLSBjdXJyVG9rZW5TdGFydCA+PSA1MCAvKiBDb25zdGFudHMuTG9uZ1Rva2VuICovKSB7CiAgICAgICAgICAgIC8vIFNwbGl0IGF0IGBsYXN0U3BhY2VPZmZzZXRgICsgMQogICAgICAgICAgICByZXN1bHRbcmVzdWx0TGVuKytdID0gbmV3IExpbmVQYXJ0KGxhc3RTcGFjZU9mZnNldCArIDEsIHRva2VuVHlwZSwgdG9rZW5NZXRhZGF0YSwgdG9rZW5Db250YWluc1JUTCk7CiAgICAgICAgICAgIGN1cnJUb2tlblN0YXJ0ID0gbGFzdFNwYWNlT2Zmc2V0ICsgMTsKICAgICAgICAgICAgbGFzdFNwYWNlT2Zmc2V0ID0gLTE7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChjdXJyVG9rZW5TdGFydCAhPT0gdG9rZW5FbmRJbmRleCkgewogICAgICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IG5ldyBMaW5lUGFydCh0b2tlbkVuZEluZGV4LCB0b2tlblR5cGUsIHRva2VuTWV0YWRhdGEsIHRva2VuQ29udGFpbnNSVEwpOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICByZXN1bHRbcmVzdWx0TGVuKytdID0gdG9rZW47CiAgICAgIH0KICAgICAgbGFzdFRva2VuRW5kSW5kZXggPSB0b2tlbkVuZEluZGV4OwogICAgfQogIH0gZWxzZSB7CiAgICAvLyBTcGxpdCBhbnl3aGVyZSA9PiB3ZSBkb24ndCBuZWVkIHRvIHdhbGsgZWFjaCBjaGFyYWN0ZXIKICAgIGZvciAodmFyIF9pID0gMCwgX2xlbjIgPSB0b2tlbnMubGVuZ3RoOyBfaSA8IF9sZW4yOyBfaSsrKSB7CiAgICAgIHZhciBfdG9rZW4gPSB0b2tlbnNbX2ldOwogICAgICB2YXIgX3Rva2VuRW5kSW5kZXggPSBfdG9rZW4uZW5kSW5kZXg7CiAgICAgIHZhciBkaWZmID0gX3Rva2VuRW5kSW5kZXggLSBsYXN0VG9rZW5FbmRJbmRleDsKICAgICAgaWYgKGRpZmYgPiA1MCAvKiBDb25zdGFudHMuTG9uZ1Rva2VuICovKSB7CiAgICAgICAgdmFyIF90b2tlblR5cGUgPSBfdG9rZW4udHlwZTsKICAgICAgICB2YXIgX3Rva2VuTWV0YWRhdGEgPSBfdG9rZW4ubWV0YWRhdGE7CiAgICAgICAgdmFyIF90b2tlbkNvbnRhaW5zUlRMMiA9IF90b2tlbi5jb250YWluc1JUTDsKICAgICAgICB2YXIgcGllY2VzQ291bnQgPSBNYXRoLmNlaWwoZGlmZiAvIDUwIC8qIENvbnN0YW50cy5Mb25nVG9rZW4gKi8pOwogICAgICAgIGZvciAodmFyIF9qID0gMTsgX2ogPCBwaWVjZXNDb3VudDsgX2orKykgewogICAgICAgICAgdmFyIHBpZWNlRW5kSW5kZXggPSBsYXN0VG9rZW5FbmRJbmRleCArIF9qICogNTAgLyogQ29uc3RhbnRzLkxvbmdUb2tlbiAqLzsKICAgICAgICAgIHJlc3VsdFtyZXN1bHRMZW4rK10gPSBuZXcgTGluZVBhcnQocGllY2VFbmRJbmRleCwgX3Rva2VuVHlwZSwgX3Rva2VuTWV0YWRhdGEsIF90b2tlbkNvbnRhaW5zUlRMMik7CiAgICAgICAgfQogICAgICAgIHJlc3VsdFtyZXN1bHRMZW4rK10gPSBuZXcgTGluZVBhcnQoX3Rva2VuRW5kSW5kZXgsIF90b2tlblR5cGUsIF90b2tlbk1ldGFkYXRhLCBfdG9rZW5Db250YWluc1JUTDIpOwogICAgICB9IGVsc2UgewogICAgICAgIHJlc3VsdFtyZXN1bHRMZW4rK10gPSBfdG9rZW47CiAgICAgIH0KICAgICAgbGFzdFRva2VuRW5kSW5kZXggPSBfdG9rZW5FbmRJbmRleDsKICAgIH0KICB9CiAgcmV0dXJuIHJlc3VsdDsKfQpmdW5jdGlvbiBpc0NvbnRyb2xDaGFyYWN0ZXIoY2hhckNvZGUpIHsKICBpZiAoY2hhckNvZGUgPCAzMikgewogICAgcmV0dXJuIGNoYXJDb2RlICE9PSA5IC8qIENoYXJDb2RlLlRhYiAqLzsKICB9CgogIGlmIChjaGFyQ29kZSA9PT0gMTI3KSB7CiAgICAvLyBERUwKICAgIHJldHVybiB0cnVlOwogIH0KICBpZiAoY2hhckNvZGUgPj0gMHgyMDJBICYmIGNoYXJDb2RlIDw9IDB4MjAyRSB8fCBjaGFyQ29kZSA+PSAweDIwNjYgJiYgY2hhckNvZGUgPD0gMHgyMDY5IHx8IGNoYXJDb2RlID49IDB4MjAwRSAmJiBjaGFyQ29kZSA8PSAweDIwMEYgfHwgY2hhckNvZGUgPT09IDB4MDYxQykgewogICAgLy8gVW5pY29kZSBEaXJlY3Rpb25hbCBGb3JtYXR0aW5nIENoYXJhY3RlcnMKICAgIC8vIExSRQlVKzIwMkEJTEVGVC1UTy1SSUdIVCBFTUJFRERJTkcKICAgIC8vIFJMRQlVKzIwMkIJUklHSFQtVE8tTEVGVCBFTUJFRERJTkcKICAgIC8vIFBERglVKzIwMkMJUE9QIERJUkVDVElPTkFMIEZPUk1BVFRJTkcKICAgIC8vIExSTwlVKzIwMkQJTEVGVC1UTy1SSUdIVCBPVkVSUklERQogICAgLy8gUkxPCVUrMjAyRQlSSUdIVC1UTy1MRUZUIE9WRVJSSURFCiAgICAvLyBMUkkJVSsyMDY2CUxFRlQtVE8tUklHSFQgSVNPTEFURQogICAgLy8gUkxJCVUrMjA2NwlSSUdIVC1UTy1MRUZUIElTT0xBVEUKICAgIC8vIEZTSQlVKzIwNjgJRklSU1QgU1RST05HIElTT0xBVEUKICAgIC8vIFBESQlVKzIwNjkJUE9QIERJUkVDVElPTkFMIElTT0xBVEUKICAgIC8vIExSTQlVKzIwMEUJTEVGVC1UTy1SSUdIVCBNQVJLCiAgICAvLyBSTE0JVSsyMDBGCVJJR0hULVRPLUxFRlQgTUFSSwogICAgLy8gQUxNCVUrMDYxQwlBUkFCSUMgTEVUVEVSIE1BUksKICAgIHJldHVybiB0cnVlOwogIH0KICByZXR1cm4gZmFsc2U7Cn0KZnVuY3Rpb24gZXh0cmFjdENvbnRyb2xDaGFyYWN0ZXJzKGxpbmVDb250ZW50LCB0b2tlbnMpIHsKICB2YXIgcmVzdWx0ID0gW107CiAgdmFyIGxhc3RMaW5lUGFydCA9IG5ldyBMaW5lUGFydCgwLCAnJywgMCwgZmFsc2UpOwogIHZhciBjaGFyT2Zmc2V0ID0gMDsKICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRva2VucyksCiAgICBfc3RlcDI7CiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciB0b2tlbiA9IF9zdGVwMi52YWx1ZTsKICAgICAgdmFyIHRva2VuRW5kSW5kZXggPSB0b2tlbi5lbmRJbmRleDsKICAgICAgZm9yICg7IGNoYXJPZmZzZXQgPCB0b2tlbkVuZEluZGV4OyBjaGFyT2Zmc2V0KyspIHsKICAgICAgICB2YXIgY2hhckNvZGUgPSBsaW5lQ29udGVudC5jaGFyQ29kZUF0KGNoYXJPZmZzZXQpOwogICAgICAgIGlmIChpc0NvbnRyb2xDaGFyYWN0ZXIoY2hhckNvZGUpKSB7CiAgICAgICAgICBpZiAoY2hhck9mZnNldCA+IGxhc3RMaW5lUGFydC5lbmRJbmRleCkgewogICAgICAgICAgICAvLyBlbWl0IHByZXZpb3VzIHBhcnQgaWYgaXQgaGFzIHRleHQKICAgICAgICAgICAgbGFzdExpbmVQYXJ0ID0gbmV3IExpbmVQYXJ0KGNoYXJPZmZzZXQsIHRva2VuLnR5cGUsIHRva2VuLm1ldGFkYXRhLCB0b2tlbi5jb250YWluc1JUTCk7CiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxhc3RMaW5lUGFydCk7CiAgICAgICAgICB9CiAgICAgICAgICBsYXN0TGluZVBhcnQgPSBuZXcgTGluZVBhcnQoY2hhck9mZnNldCArIDEsICdtdGtjb250cm9sJywgdG9rZW4ubWV0YWRhdGEsIGZhbHNlKTsKICAgICAgICAgIHJlc3VsdC5wdXNoKGxhc3RMaW5lUGFydCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmIChjaGFyT2Zmc2V0ID4gbGFzdExpbmVQYXJ0LmVuZEluZGV4KSB7CiAgICAgICAgLy8gZW1pdCBwcmV2aW91cyBwYXJ0IGlmIGl0IGhhcyB0ZXh0CiAgICAgICAgbGFzdExpbmVQYXJ0ID0gbmV3IExpbmVQYXJ0KHRva2VuRW5kSW5kZXgsIHRva2VuLnR5cGUsIHRva2VuLm1ldGFkYXRhLCB0b2tlbi5jb250YWluc1JUTCk7CiAgICAgICAgcmVzdWx0LnB1c2gobGFzdExpbmVQYXJ0KTsKICAgICAgfQogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2l0ZXJhdG9yMi5lKGVycik7CiAgfSBmaW5hbGx5IHsKICAgIF9pdGVyYXRvcjIuZigpOwogIH0KICByZXR1cm4gcmVzdWx0Owp9Ci8qKgogKiBXaGl0ZXNwYWNlIGlzIHJlbmRlcmVkIGJ5ICJyZXBsYWNpbmciIHRva2VucyB3aXRoIGEgc3BlY2lhbC1wdXJwb3NlIGBtdGt3YCB0eXBlIHRoYXQgaXMgbGF0ZXIgcmVjb2duaXplZCBpbiB0aGUgcmVuZGVyaW5nIHBoYXNlLgogKiBNb3Jlb3ZlciwgYSB0b2tlbiBpcyBjcmVhdGVkIGZvciBldmVyeSB2aXN1YWwgaW5kZW50IGJlY2F1c2Ugb24gc29tZSBmb250cyB0aGUgZ2x5cGhzIHVzZWQgZm9yIHJlbmRlcmluZyB3aGl0ZXNwYWNlICgmcmFycjsgb3IgJm1pZGRvdDspIGRvIG5vdCBoYXZlIHRoZSBzYW1lIHdpZHRoIGFzICZuYnNwOy4KICogVGhlIHJlbmRlcmluZyBwaGFzZSB3aWxsIGdlbmVyYXRlIGBzdHlsZT0id2lkdGg6Li4uImAgZm9yIHRoZXNlIHRva2Vucy4KICovCmZ1bmN0aW9uIF9hcHBseVJlbmRlcldoaXRlc3BhY2UoaW5wdXQsIGxpbmVDb250ZW50LCBsZW4sIHRva2VucykgewogIHZhciBjb250aW51ZXNXaXRoV3JhcHBlZExpbmUgPSBpbnB1dC5jb250aW51ZXNXaXRoV3JhcHBlZExpbmU7CiAgdmFyIGZhdXhJbmRlbnRMZW5ndGggPSBpbnB1dC5mYXV4SW5kZW50TGVuZ3RoOwogIHZhciB0YWJTaXplID0gaW5wdXQudGFiU2l6ZTsKICB2YXIgc3RhcnRWaXNpYmxlQ29sdW1uID0gaW5wdXQuc3RhcnRWaXNpYmxlQ29sdW1uOwogIHZhciB1c2VNb25vc3BhY2VPcHRpbWl6YXRpb25zID0gaW5wdXQudXNlTW9ub3NwYWNlT3B0aW1pemF0aW9uczsKICB2YXIgc2VsZWN0aW9ucyA9IGlucHV0LnNlbGVjdGlvbnNPbkxpbmU7CiAgdmFyIG9ubHlCb3VuZGFyeSA9IGlucHV0LnJlbmRlcldoaXRlc3BhY2UgPT09IDEgLyogUmVuZGVyV2hpdGVzcGFjZS5Cb3VuZGFyeSAqLzsKICB2YXIgb25seVRyYWlsaW5nID0gaW5wdXQucmVuZGVyV2hpdGVzcGFjZSA9PT0gMyAvKiBSZW5kZXJXaGl0ZXNwYWNlLlRyYWlsaW5nICovOwogIHZhciBnZW5lcmF0ZUxpbmVQYXJ0Rm9yRWFjaFdoaXRlc3BhY2UgPSBpbnB1dC5yZW5kZXJTcGFjZVdpZHRoICE9PSBpbnB1dC5zcGFjZVdpZHRoOwogIHZhciByZXN1bHQgPSBbXTsKICB2YXIgcmVzdWx0TGVuID0gMDsKICB2YXIgdG9rZW5JbmRleCA9IDA7CiAgdmFyIHRva2VuVHlwZSA9IHRva2Vuc1t0b2tlbkluZGV4XS50eXBlOwogIHZhciB0b2tlbkNvbnRhaW5zUlRMID0gdG9rZW5zW3Rva2VuSW5kZXhdLmNvbnRhaW5zUlRMOwogIHZhciB0b2tlbkVuZEluZGV4ID0gdG9rZW5zW3Rva2VuSW5kZXhdLmVuZEluZGV4OwogIHZhciB0b2tlbnNMZW5ndGggPSB0b2tlbnMubGVuZ3RoOwogIHZhciBsaW5lSXNFbXB0eU9yV2hpdGVzcGFjZSA9IGZhbHNlOwogIHZhciBmaXJzdE5vbldoaXRlc3BhY2VJbmRleCA9IHN0cmluZ3MuZmlyc3ROb25XaGl0ZXNwYWNlSW5kZXgobGluZUNvbnRlbnQpOwogIHZhciBsYXN0Tm9uV2hpdGVzcGFjZUluZGV4OwogIGlmIChmaXJzdE5vbldoaXRlc3BhY2VJbmRleCA9PT0gLTEpIHsKICAgIGxpbmVJc0VtcHR5T3JXaGl0ZXNwYWNlID0gdHJ1ZTsKICAgIGZpcnN0Tm9uV2hpdGVzcGFjZUluZGV4ID0gbGVuOwogICAgbGFzdE5vbldoaXRlc3BhY2VJbmRleCA9IGxlbjsKICB9IGVsc2UgewogICAgbGFzdE5vbldoaXRlc3BhY2VJbmRleCA9IHN0cmluZ3MubGFzdE5vbldoaXRlc3BhY2VJbmRleChsaW5lQ29udGVudCk7CiAgfQogIHZhciB3YXNJbldoaXRlc3BhY2UgPSBmYWxzZTsKICB2YXIgY3VycmVudFNlbGVjdGlvbkluZGV4ID0gMDsKICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IHNlbGVjdGlvbnMgJiYgc2VsZWN0aW9uc1tjdXJyZW50U2VsZWN0aW9uSW5kZXhdOwogIHZhciB0bXBJbmRlbnQgPSBzdGFydFZpc2libGVDb2x1bW4gJSB0YWJTaXplOwogIGZvciAodmFyIGNoYXJJbmRleCA9IGZhdXhJbmRlbnRMZW5ndGg7IGNoYXJJbmRleCA8IGxlbjsgY2hhckluZGV4KyspIHsKICAgIHZhciBjaENvZGUgPSBsaW5lQ29udGVudC5jaGFyQ29kZUF0KGNoYXJJbmRleCk7CiAgICBpZiAoY3VycmVudFNlbGVjdGlvbiAmJiBjaGFySW5kZXggPj0gY3VycmVudFNlbGVjdGlvbi5lbmRPZmZzZXQpIHsKICAgICAgY3VycmVudFNlbGVjdGlvbkluZGV4Kys7CiAgICAgIGN1cnJlbnRTZWxlY3Rpb24gPSBzZWxlY3Rpb25zICYmIHNlbGVjdGlvbnNbY3VycmVudFNlbGVjdGlvbkluZGV4XTsKICAgIH0KICAgIHZhciBpc0luV2hpdGVzcGFjZSA9IHZvaWQgMDsKICAgIGlmIChjaGFySW5kZXggPCBmaXJzdE5vbldoaXRlc3BhY2VJbmRleCB8fCBjaGFySW5kZXggPiBsYXN0Tm9uV2hpdGVzcGFjZUluZGV4KSB7CiAgICAgIC8vIGluIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZQogICAgICBpc0luV2hpdGVzcGFjZSA9IHRydWU7CiAgICB9IGVsc2UgaWYgKGNoQ29kZSA9PT0gOSAvKiBDaGFyQ29kZS5UYWIgKi8pIHsKICAgICAgLy8gYSB0YWIgY2hhcmFjdGVyIGlzIHJlbmRlcmVkIGJvdGggaW4gYWxsIGFuZCBib3VuZGFyeSBjYXNlcwogICAgICBpc0luV2hpdGVzcGFjZSA9IHRydWU7CiAgICB9IGVsc2UgaWYgKGNoQ29kZSA9PT0gMzIgLyogQ2hhckNvZGUuU3BhY2UgKi8pIHsKICAgICAgLy8gaGl0IGEgc3BhY2UgY2hhcmFjdGVyCiAgICAgIGlmIChvbmx5Qm91bmRhcnkpIHsKICAgICAgICAvLyByZW5kZXJpbmcgb25seSBib3VuZGFyeSB3aGl0ZXNwYWNlCiAgICAgICAgaWYgKHdhc0luV2hpdGVzcGFjZSkgewogICAgICAgICAgaXNJbldoaXRlc3BhY2UgPSB0cnVlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgbmV4dENoQ29kZSA9IGNoYXJJbmRleCArIDEgPCBsZW4gPyBsaW5lQ29udGVudC5jaGFyQ29kZUF0KGNoYXJJbmRleCArIDEpIDogMCAvKiBDaGFyQ29kZS5OdWxsICovOwogICAgICAgICAgaXNJbldoaXRlc3BhY2UgPSBuZXh0Q2hDb2RlID09PSAzMiAvKiBDaGFyQ29kZS5TcGFjZSAqLyB8fCBuZXh0Q2hDb2RlID09PSA5IC8qIENoYXJDb2RlLlRhYiAqLzsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgaXNJbldoaXRlc3BhY2UgPSB0cnVlOwogICAgICB9CiAgICB9IGVsc2UgewogICAgICBpc0luV2hpdGVzcGFjZSA9IGZhbHNlOwogICAgfQogICAgLy8gSWYgcmVuZGVyaW5nIHdoaXRlc3BhY2Ugb24gc2VsZWN0aW9uLCBjaGVjayB0aGF0IHRoZSBjaGFySW5kZXggZmFsbHMgd2l0aGluIGEgc2VsZWN0aW9uCiAgICBpZiAoaXNJbldoaXRlc3BhY2UgJiYgc2VsZWN0aW9ucykgewogICAgICBpc0luV2hpdGVzcGFjZSA9ICEhY3VycmVudFNlbGVjdGlvbiAmJiBjdXJyZW50U2VsZWN0aW9uLnN0YXJ0T2Zmc2V0IDw9IGNoYXJJbmRleCAmJiBjdXJyZW50U2VsZWN0aW9uLmVuZE9mZnNldCA+IGNoYXJJbmRleDsKICAgIH0KICAgIC8vIElmIHJlbmRlcmluZyBvbmx5IHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNoZWNrIHRoYXQgdGhlIGNoYXJJbmRleCBwb2ludHMgdG8gdHJhaWxpbmcgd2hpdGVzcGFjZS4KICAgIGlmIChpc0luV2hpdGVzcGFjZSAmJiBvbmx5VHJhaWxpbmcpIHsKICAgICAgaXNJbldoaXRlc3BhY2UgPSBsaW5lSXNFbXB0eU9yV2hpdGVzcGFjZSB8fCBjaGFySW5kZXggPiBsYXN0Tm9uV2hpdGVzcGFjZUluZGV4OwogICAgfQogICAgaWYgKGlzSW5XaGl0ZXNwYWNlICYmIHRva2VuQ29udGFpbnNSVEwpIHsKICAgICAgLy8gSWYgdGhlIHRva2VuIGNvbnRhaW5zIFJUTCB0ZXh0LCBicmVha2luZyBpdCB1cCBpbnRvIG11bHRpcGxlIGxpbmUgcGFydHMKICAgICAgLy8gdG8gcmVuZGVyIHdoaXRlc3BhY2UgbWlnaHQgYWZmZWN0IHRoZSBicm93c2VyJ3MgYmlkaSBsYXlvdXQuCiAgICAgIC8vCiAgICAgIC8vIFdlIHJlbmRlciB3aGl0ZXNwYWNlIGluIHN1Y2ggdG9rZW5zIG9ubHkgaWYgdGhlIHdoaXRlc3BhY2UKICAgICAgLy8gaXMgdGhlIGxlYWRpbmcgb3IgdGhlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb2YgdGhlIGxpbmUsCiAgICAgIC8vIHdoaWNoIGRvZXNuJ3QgYWZmZWN0IHRoZSBicm93c2VyJ3MgYmlkaSBsYXlvdXQuCiAgICAgIGlmIChjaGFySW5kZXggPj0gZmlyc3ROb25XaGl0ZXNwYWNlSW5kZXggJiYgY2hhckluZGV4IDw9IGxhc3ROb25XaGl0ZXNwYWNlSW5kZXgpIHsKICAgICAgICBpc0luV2hpdGVzcGFjZSA9IGZhbHNlOwogICAgICB9CiAgICB9CiAgICBpZiAod2FzSW5XaGl0ZXNwYWNlKSB7CiAgICAgIC8vIHdhcyBpbiB3aGl0ZXNwYWNlIHRva2VuCiAgICAgIGlmICghaXNJbldoaXRlc3BhY2UgfHwgIXVzZU1vbm9zcGFjZU9wdGltaXphdGlvbnMgJiYgdG1wSW5kZW50ID49IHRhYlNpemUpIHsKICAgICAgICAvLyBsZWF2aW5nIHdoaXRlc3BhY2UgdG9rZW4gb3IgZW50ZXJpbmcgYSBuZXcgaW5kZW50CiAgICAgICAgaWYgKGdlbmVyYXRlTGluZVBhcnRGb3JFYWNoV2hpdGVzcGFjZSkgewogICAgICAgICAgdmFyIGxhc3RFbmRJbmRleCA9IHJlc3VsdExlbiA+IDAgPyByZXN1bHRbcmVzdWx0TGVuIC0gMV0uZW5kSW5kZXggOiBmYXV4SW5kZW50TGVuZ3RoOwogICAgICAgICAgZm9yICh2YXIgaSA9IGxhc3RFbmRJbmRleCArIDE7IGkgPD0gY2hhckluZGV4OyBpKyspIHsKICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IG5ldyBMaW5lUGFydChpLCAnbXRrdycsIDEgLyogTGluZVBhcnRNZXRhZGF0YS5JU19XSElURVNQQUNFICovLCBmYWxzZSk7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJlc3VsdFtyZXN1bHRMZW4rK10gPSBuZXcgTGluZVBhcnQoY2hhckluZGV4LCAnbXRrdycsIDEgLyogTGluZVBhcnRNZXRhZGF0YS5JU19XSElURVNQQUNFICovLCBmYWxzZSk7CiAgICAgICAgfQogICAgICAgIHRtcEluZGVudCA9IHRtcEluZGVudCAlIHRhYlNpemU7CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIC8vIHdhcyBpbiByZWd1bGFyIHRva2VuCiAgICAgIGlmIChjaGFySW5kZXggPT09IHRva2VuRW5kSW5kZXggfHwgaXNJbldoaXRlc3BhY2UgJiYgY2hhckluZGV4ID4gZmF1eEluZGVudExlbmd0aCkgewogICAgICAgIHJlc3VsdFtyZXN1bHRMZW4rK10gPSBuZXcgTGluZVBhcnQoY2hhckluZGV4LCB0b2tlblR5cGUsIDAsIHRva2VuQ29udGFpbnNSVEwpOwogICAgICAgIHRtcEluZGVudCA9IHRtcEluZGVudCAlIHRhYlNpemU7CiAgICAgIH0KICAgIH0KICAgIGlmIChjaENvZGUgPT09IDkgLyogQ2hhckNvZGUuVGFiICovKSB7CiAgICAgIHRtcEluZGVudCA9IHRhYlNpemU7CiAgICB9IGVsc2UgaWYgKHN0cmluZ3MuaXNGdWxsV2lkdGhDaGFyYWN0ZXIoY2hDb2RlKSkgewogICAgICB0bXBJbmRlbnQgKz0gMjsKICAgIH0gZWxzZSB7CiAgICAgIHRtcEluZGVudCsrOwogICAgfQogICAgd2FzSW5XaGl0ZXNwYWNlID0gaXNJbldoaXRlc3BhY2U7CiAgICB3aGlsZSAoY2hhckluZGV4ID09PSB0b2tlbkVuZEluZGV4KSB7CiAgICAgIHRva2VuSW5kZXgrKzsKICAgICAgaWYgKHRva2VuSW5kZXggPCB0b2tlbnNMZW5ndGgpIHsKICAgICAgICB0b2tlblR5cGUgPSB0b2tlbnNbdG9rZW5JbmRleF0udHlwZTsKICAgICAgICB0b2tlbkNvbnRhaW5zUlRMID0gdG9rZW5zW3Rva2VuSW5kZXhdLmNvbnRhaW5zUlRMOwogICAgICAgIHRva2VuRW5kSW5kZXggPSB0b2tlbnNbdG9rZW5JbmRleF0uZW5kSW5kZXg7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0KICB9CiAgdmFyIGdlbmVyYXRlV2hpdGVzcGFjZSA9IGZhbHNlOwogIGlmICh3YXNJbldoaXRlc3BhY2UpIHsKICAgIC8vIHdhcyBpbiB3aGl0ZXNwYWNlIHRva2VuCiAgICBpZiAoY29udGludWVzV2l0aFdyYXBwZWRMaW5lICYmIG9ubHlCb3VuZGFyeSkgewogICAgICB2YXIgbGFzdENoYXJDb2RlID0gbGVuID4gMCA/IGxpbmVDb250ZW50LmNoYXJDb2RlQXQobGVuIC0gMSkgOiAwIC8qIENoYXJDb2RlLk51bGwgKi87CiAgICAgIHZhciBwcmV2Q2hhckNvZGUgPSBsZW4gPiAxID8gbGluZUNvbnRlbnQuY2hhckNvZGVBdChsZW4gLSAyKSA6IDAgLyogQ2hhckNvZGUuTnVsbCAqLzsKICAgICAgdmFyIGlzU2luZ2xlVHJhaWxpbmdTcGFjZSA9IGxhc3RDaGFyQ29kZSA9PT0gMzIgLyogQ2hhckNvZGUuU3BhY2UgKi8gJiYgcHJldkNoYXJDb2RlICE9PSAzMiAvKiBDaGFyQ29kZS5TcGFjZSAqLyAmJiBwcmV2Q2hhckNvZGUgIT09IDkgLyogQ2hhckNvZGUuVGFiICovOwogICAgICBpZiAoIWlzU2luZ2xlVHJhaWxpbmdTcGFjZSkgewogICAgICAgIGdlbmVyYXRlV2hpdGVzcGFjZSA9IHRydWU7CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIGdlbmVyYXRlV2hpdGVzcGFjZSA9IHRydWU7CiAgICB9CiAgfQogIGlmIChnZW5lcmF0ZVdoaXRlc3BhY2UpIHsKICAgIGlmIChnZW5lcmF0ZUxpbmVQYXJ0Rm9yRWFjaFdoaXRlc3BhY2UpIHsKICAgICAgdmFyIF9sYXN0RW5kSW5kZXggPSByZXN1bHRMZW4gPiAwID8gcmVzdWx0W3Jlc3VsdExlbiAtIDFdLmVuZEluZGV4IDogZmF1eEluZGVudExlbmd0aDsKICAgICAgZm9yICh2YXIgX2kyID0gX2xhc3RFbmRJbmRleCArIDE7IF9pMiA8PSBsZW47IF9pMisrKSB7CiAgICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IG5ldyBMaW5lUGFydChfaTIsICdtdGt3JywgMSAvKiBMaW5lUGFydE1ldGFkYXRhLklTX1dISVRFU1BBQ0UgKi8sIGZhbHNlKTsKICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IG5ldyBMaW5lUGFydChsZW4sICdtdGt3JywgMSAvKiBMaW5lUGFydE1ldGFkYXRhLklTX1dISVRFU1BBQ0UgKi8sIGZhbHNlKTsKICAgIH0KICB9IGVsc2UgewogICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IG5ldyBMaW5lUGFydChsZW4sIHRva2VuVHlwZSwgMCwgdG9rZW5Db250YWluc1JUTCk7CiAgfQogIHJldHVybiByZXN1bHQ7Cn0KLyoqCiAqIElubGluZSBkZWNvcmF0aW9ucyBhcmUgIm1lcmdlZCIgb24gdG9wIG9mIHRva2Vucy4KICogU3BlY2lhbCBjYXJlIG11c3QgYmUgdGFrZW4gd2hlbiBtdWx0aXBsZSBpbmxpbmUgZGVjb3JhdGlvbnMgYXJlIGF0IHBsYXkgYW5kIHRoZXkgb3ZlcmxhcC4KICovCmZ1bmN0aW9uIF9hcHBseUlubGluZURlY29yYXRpb25zKGxpbmVDb250ZW50LCBsZW4sIHRva2VucywgX2xpbmVEZWNvcmF0aW9ucykgewogIF9saW5lRGVjb3JhdGlvbnMuc29ydChMaW5lRGVjb3JhdGlvbi5jb21wYXJlKTsKICB2YXIgbGluZURlY29yYXRpb25zID0gTGluZURlY29yYXRpb25zTm9ybWFsaXplci5ub3JtYWxpemUobGluZUNvbnRlbnQsIF9saW5lRGVjb3JhdGlvbnMpOwogIHZhciBsaW5lRGVjb3JhdGlvbnNMZW4gPSBsaW5lRGVjb3JhdGlvbnMubGVuZ3RoOwogIHZhciBsaW5lRGVjb3JhdGlvbkluZGV4ID0gMDsKICB2YXIgcmVzdWx0ID0gW107CiAgdmFyIHJlc3VsdExlbiA9IDA7CiAgdmFyIGxhc3RSZXN1bHRFbmRJbmRleCA9IDA7CiAgZm9yICh2YXIgdG9rZW5JbmRleCA9IDAsIF9sZW4zID0gdG9rZW5zLmxlbmd0aDsgdG9rZW5JbmRleCA8IF9sZW4zOyB0b2tlbkluZGV4KyspIHsKICAgIHZhciB0b2tlbiA9IHRva2Vuc1t0b2tlbkluZGV4XTsKICAgIHZhciB0b2tlbkVuZEluZGV4ID0gdG9rZW4uZW5kSW5kZXg7CiAgICB2YXIgdG9rZW5UeXBlID0gdG9rZW4udHlwZTsKICAgIHZhciB0b2tlbk1ldGFkYXRhID0gdG9rZW4ubWV0YWRhdGE7CiAgICB2YXIgdG9rZW5Db250YWluc1JUTCA9IHRva2VuLmNvbnRhaW5zUlRMOwogICAgd2hpbGUgKGxpbmVEZWNvcmF0aW9uSW5kZXggPCBsaW5lRGVjb3JhdGlvbnNMZW4gJiYgbGluZURlY29yYXRpb25zW2xpbmVEZWNvcmF0aW9uSW5kZXhdLnN0YXJ0T2Zmc2V0IDwgdG9rZW5FbmRJbmRleCkgewogICAgICB2YXIgbGluZURlY29yYXRpb24gPSBsaW5lRGVjb3JhdGlvbnNbbGluZURlY29yYXRpb25JbmRleF07CiAgICAgIGlmIChsaW5lRGVjb3JhdGlvbi5zdGFydE9mZnNldCA+IGxhc3RSZXN1bHRFbmRJbmRleCkgewogICAgICAgIGxhc3RSZXN1bHRFbmRJbmRleCA9IGxpbmVEZWNvcmF0aW9uLnN0YXJ0T2Zmc2V0OwogICAgICAgIHJlc3VsdFtyZXN1bHRMZW4rK10gPSBuZXcgTGluZVBhcnQobGFzdFJlc3VsdEVuZEluZGV4LCB0b2tlblR5cGUsIHRva2VuTWV0YWRhdGEsIHRva2VuQ29udGFpbnNSVEwpOwogICAgICB9CiAgICAgIGlmIChsaW5lRGVjb3JhdGlvbi5lbmRPZmZzZXQgKyAxIDw9IHRva2VuRW5kSW5kZXgpIHsKICAgICAgICAvLyBUaGlzIGxpbmUgZGVjb3JhdGlvbiBlbmRzIGJlZm9yZSB0aGlzIHRva2VuIGVuZHMKICAgICAgICBsYXN0UmVzdWx0RW5kSW5kZXggPSBsaW5lRGVjb3JhdGlvbi5lbmRPZmZzZXQgKyAxOwogICAgICAgIHJlc3VsdFtyZXN1bHRMZW4rK10gPSBuZXcgTGluZVBhcnQobGFzdFJlc3VsdEVuZEluZGV4LCB0b2tlblR5cGUgKyAnICcgKyBsaW5lRGVjb3JhdGlvbi5jbGFzc05hbWUsIHRva2VuTWV0YWRhdGEgfCBsaW5lRGVjb3JhdGlvbi5tZXRhZGF0YSwgdG9rZW5Db250YWluc1JUTCk7CiAgICAgICAgbGluZURlY29yYXRpb25JbmRleCsrOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIFRoaXMgbGluZSBkZWNvcmF0aW9uIGNvbnRpbnVlcyBvbiB0byB0aGUgbmV4dCB0b2tlbgogICAgICAgIGxhc3RSZXN1bHRFbmRJbmRleCA9IHRva2VuRW5kSW5kZXg7CiAgICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IG5ldyBMaW5lUGFydChsYXN0UmVzdWx0RW5kSW5kZXgsIHRva2VuVHlwZSArICcgJyArIGxpbmVEZWNvcmF0aW9uLmNsYXNzTmFtZSwgdG9rZW5NZXRhZGF0YSB8IGxpbmVEZWNvcmF0aW9uLm1ldGFkYXRhLCB0b2tlbkNvbnRhaW5zUlRMKTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgfQogICAgaWYgKHRva2VuRW5kSW5kZXggPiBsYXN0UmVzdWx0RW5kSW5kZXgpIHsKICAgICAgbGFzdFJlc3VsdEVuZEluZGV4ID0gdG9rZW5FbmRJbmRleDsKICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IG5ldyBMaW5lUGFydChsYXN0UmVzdWx0RW5kSW5kZXgsIHRva2VuVHlwZSwgdG9rZW5NZXRhZGF0YSwgdG9rZW5Db250YWluc1JUTCk7CiAgICB9CiAgfQogIHZhciBsYXN0VG9rZW5FbmRJbmRleCA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0uZW5kSW5kZXg7CiAgaWYgKGxpbmVEZWNvcmF0aW9uSW5kZXggPCBsaW5lRGVjb3JhdGlvbnNMZW4gJiYgbGluZURlY29yYXRpb25zW2xpbmVEZWNvcmF0aW9uSW5kZXhdLnN0YXJ0T2Zmc2V0ID09PSBsYXN0VG9rZW5FbmRJbmRleCkgewogICAgd2hpbGUgKGxpbmVEZWNvcmF0aW9uSW5kZXggPCBsaW5lRGVjb3JhdGlvbnNMZW4gJiYgbGluZURlY29yYXRpb25zW2xpbmVEZWNvcmF0aW9uSW5kZXhdLnN0YXJ0T2Zmc2V0ID09PSBsYXN0VG9rZW5FbmRJbmRleCkgewogICAgICB2YXIgX2xpbmVEZWNvcmF0aW9uID0gbGluZURlY29yYXRpb25zW2xpbmVEZWNvcmF0aW9uSW5kZXhdOwogICAgICByZXN1bHRbcmVzdWx0TGVuKytdID0gbmV3IExpbmVQYXJ0KGxhc3RSZXN1bHRFbmRJbmRleCwgX2xpbmVEZWNvcmF0aW9uLmNsYXNzTmFtZSwgX2xpbmVEZWNvcmF0aW9uLm1ldGFkYXRhLCBmYWxzZSk7CiAgICAgIGxpbmVEZWNvcmF0aW9uSW5kZXgrKzsKICAgIH0KICB9CiAgcmV0dXJuIHJlc3VsdDsKfQovKioKICogVGhpcyBmdW5jdGlvbiBpcyBvbiBwdXJwb3NlIG5vdCBzcGxpdCB1cCBpbnRvIG11bHRpcGxlIGZ1bmN0aW9ucyB0byBhbGxvdyBydW50aW1lIHR5cGUgaW5mZXJlbmNlIChpLmUuIHBlcmZvcm1hbmNlIHJlYXNvbnMpLgogKiBOb3RpY2UgaG93IGFsbCB0aGUgbmVlZGVkIGRhdGEgaXMgZnVsbHkgcmVzb2x2ZWQgYW5kIHBhc3NlZCBpbiAoaS5lLiBubyBvdGhlciBjYWxscykuCiAqLwpmdW5jdGlvbiBfcmVuZGVyTGluZShpbnB1dCwgc2IpIHsKICB2YXIgZm9udElzTW9ub3NwYWNlID0gaW5wdXQuZm9udElzTW9ub3NwYWNlOwogIHZhciBjYW5Vc2VIYWxmd2lkdGhSaWdodHdhcmRzQXJyb3cgPSBpbnB1dC5jYW5Vc2VIYWxmd2lkdGhSaWdodHdhcmRzQXJyb3c7CiAgdmFyIGNvbnRhaW5zRm9yZWlnbkVsZW1lbnRzID0gaW5wdXQuY29udGFpbnNGb3JlaWduRWxlbWVudHM7CiAgdmFyIGxpbmVDb250ZW50ID0gaW5wdXQubGluZUNvbnRlbnQ7CiAgdmFyIGxlbiA9IGlucHV0LmxlbjsKICB2YXIgaXNPdmVyZmxvd2luZyA9IGlucHV0LmlzT3ZlcmZsb3dpbmc7CiAgdmFyIHBhcnRzID0gaW5wdXQucGFydHM7CiAgdmFyIGZhdXhJbmRlbnRMZW5ndGggPSBpbnB1dC5mYXV4SW5kZW50TGVuZ3RoOwogIHZhciB0YWJTaXplID0gaW5wdXQudGFiU2l6ZTsKICB2YXIgc3RhcnRWaXNpYmxlQ29sdW1uID0gaW5wdXQuc3RhcnRWaXNpYmxlQ29sdW1uOwogIHZhciBjb250YWluc1JUTCA9IGlucHV0LmNvbnRhaW5zUlRMOwogIHZhciBzcGFjZVdpZHRoID0gaW5wdXQuc3BhY2VXaWR0aDsKICB2YXIgcmVuZGVyU3BhY2VDaGFyQ29kZSA9IGlucHV0LnJlbmRlclNwYWNlQ2hhckNvZGU7CiAgdmFyIHJlbmRlcldoaXRlc3BhY2UgPSBpbnB1dC5yZW5kZXJXaGl0ZXNwYWNlOwogIHZhciByZW5kZXJDb250cm9sQ2hhcmFjdGVycyA9IGlucHV0LnJlbmRlckNvbnRyb2xDaGFyYWN0ZXJzOwogIHZhciBjaGFyYWN0ZXJNYXBwaW5nID0gbmV3IENoYXJhY3Rlck1hcHBpbmcobGVuICsgMSwgcGFydHMubGVuZ3RoKTsKICB2YXIgbGFzdENoYXJhY3Rlck1hcHBpbmdEZWZpbmVkID0gZmFsc2U7CiAgdmFyIGNoYXJJbmRleCA9IDA7CiAgdmFyIHZpc2libGVDb2x1bW4gPSBzdGFydFZpc2libGVDb2x1bW47CiAgdmFyIGNoYXJPZmZzZXRJblBhcnQgPSAwOyAvLyB0aGUgY2hhcmFjdGVyIG9mZnNldCBpbiB0aGUgY3VycmVudCBwYXJ0CiAgdmFyIGNoYXJIb3Jpem9udGFsT2Zmc2V0ID0gMDsgLy8gdGhlIGNoYXJhY3RlciBob3Jpem9udGFsIHBvc2l0aW9uIGluIHRlcm1zIG9mIGNoYXJzIHJlbGF0aXZlIHRvIGxpbmUgc3RhcnQKICB2YXIgcGFydERpc3BsYWNlbWVudCA9IDA7CiAgaWYgKGNvbnRhaW5zUlRMKSB7CiAgICBzYi5hcHBlbmRBU0NJSVN0cmluZygnPHNwYW4gZGlyPSJsdHIiPicpOwogIH0gZWxzZSB7CiAgICBzYi5hcHBlbmRBU0NJSVN0cmluZygnPHNwYW4+Jyk7CiAgfQogIGZvciAodmFyIHBhcnRJbmRleCA9IDAsIHRva2Vuc0xlbiA9IHBhcnRzLmxlbmd0aDsgcGFydEluZGV4IDwgdG9rZW5zTGVuOyBwYXJ0SW5kZXgrKykgewogICAgdmFyIHBhcnQgPSBwYXJ0c1twYXJ0SW5kZXhdOwogICAgdmFyIHBhcnRFbmRJbmRleCA9IHBhcnQuZW5kSW5kZXg7CiAgICB2YXIgcGFydFR5cGUgPSBwYXJ0LnR5cGU7CiAgICB2YXIgcGFydENvbnRhaW5zUlRMID0gcGFydC5jb250YWluc1JUTDsKICAgIHZhciBwYXJ0UmVuZGVyc1doaXRlc3BhY2UgPSByZW5kZXJXaGl0ZXNwYWNlICE9PSAwIC8qIFJlbmRlcldoaXRlc3BhY2UuTm9uZSAqLyAmJiBwYXJ0LmlzV2hpdGVzcGFjZSgpOwogICAgdmFyIHBhcnRSZW5kZXJzV2hpdGVzcGFjZVdpdGhXaWR0aCA9IHBhcnRSZW5kZXJzV2hpdGVzcGFjZSAmJiAhZm9udElzTW9ub3NwYWNlICYmIChwYXJ0VHlwZSA9PT0gJ210a3cnIC8qb25seSB3aGl0ZXNwYWNlKi8gfHwgIWNvbnRhaW5zRm9yZWlnbkVsZW1lbnRzKTsKICAgIHZhciBwYXJ0SXNFbXB0eUFuZEhhc1BzZXVkb0FmdGVyID0gY2hhckluZGV4ID09PSBwYXJ0RW5kSW5kZXggJiYgcGFydC5pc1BzZXVkb0FmdGVyKCk7CiAgICBjaGFyT2Zmc2V0SW5QYXJ0ID0gMDsKICAgIHNiLmFwcGVuZEFTQ0lJU3RyaW5nKCc8c3BhbiAnKTsKICAgIGlmIChwYXJ0Q29udGFpbnNSVEwpIHsKICAgICAgc2IuYXBwZW5kQVNDSUlTdHJpbmcoJ3N0eWxlPSJ1bmljb2RlLWJpZGk6aXNvbGF0ZSIgJyk7CiAgICB9CiAgICBzYi5hcHBlbmRBU0NJSVN0cmluZygnY2xhc3M9IicpOwogICAgc2IuYXBwZW5kQVNDSUlTdHJpbmcocGFydFJlbmRlcnNXaGl0ZXNwYWNlV2l0aFdpZHRoID8gJ210a3onIDogcGFydFR5cGUpOwogICAgc2IuYXBwZW5kQVNDSUkoMzQgLyogQ2hhckNvZGUuRG91YmxlUXVvdGUgKi8pOwogICAgaWYgKHBhcnRSZW5kZXJzV2hpdGVzcGFjZSkgewogICAgICB2YXIgcGFydFdpZHRoID0gMDsKICAgICAgewogICAgICAgIHZhciBfY2hhckluZGV4ID0gY2hhckluZGV4OwogICAgICAgIHZhciBfdmlzaWJsZUNvbHVtbiA9IHZpc2libGVDb2x1bW47CiAgICAgICAgZm9yICg7IF9jaGFySW5kZXggPCBwYXJ0RW5kSW5kZXg7IF9jaGFySW5kZXgrKykgewogICAgICAgICAgdmFyIGNoYXJDb2RlID0gbGluZUNvbnRlbnQuY2hhckNvZGVBdChfY2hhckluZGV4KTsKICAgICAgICAgIHZhciBjaGFyV2lkdGggPSAoY2hhckNvZGUgPT09IDkgLyogQ2hhckNvZGUuVGFiICovID8gdGFiU2l6ZSAtIF92aXNpYmxlQ29sdW1uICUgdGFiU2l6ZSA6IDEpIHwgMDsKICAgICAgICAgIHBhcnRXaWR0aCArPSBjaGFyV2lkdGg7CiAgICAgICAgICBpZiAoX2NoYXJJbmRleCA+PSBmYXV4SW5kZW50TGVuZ3RoKSB7CiAgICAgICAgICAgIF92aXNpYmxlQ29sdW1uICs9IGNoYXJXaWR0aDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKHBhcnRSZW5kZXJzV2hpdGVzcGFjZVdpdGhXaWR0aCkgewogICAgICAgIHNiLmFwcGVuZEFTQ0lJU3RyaW5nKCcgc3R5bGU9IndpZHRoOicpOwogICAgICAgIHNiLmFwcGVuZEFTQ0lJU3RyaW5nKFN0cmluZyhzcGFjZVdpZHRoICogcGFydFdpZHRoKSk7CiAgICAgICAgc2IuYXBwZW5kQVNDSUlTdHJpbmcoJ3B4IicpOwogICAgICB9CiAgICAgIHNiLmFwcGVuZEFTQ0lJKDYyIC8qIENoYXJDb2RlLkdyZWF0ZXJUaGFuICovKTsKICAgICAgZm9yICg7IGNoYXJJbmRleCA8IHBhcnRFbmRJbmRleDsgY2hhckluZGV4KyspIHsKICAgICAgICBjaGFyYWN0ZXJNYXBwaW5nLnNldENvbHVtbkluZm8oY2hhckluZGV4ICsgMSwgcGFydEluZGV4IC0gcGFydERpc3BsYWNlbWVudCwgY2hhck9mZnNldEluUGFydCwgY2hhckhvcml6b250YWxPZmZzZXQpOwogICAgICAgIHBhcnREaXNwbGFjZW1lbnQgPSAwOwogICAgICAgIHZhciBfY2hhckNvZGUgPSBsaW5lQ29udGVudC5jaGFyQ29kZUF0KGNoYXJJbmRleCk7CiAgICAgICAgdmFyIHByb2R1Y2VkQ2hhcmFjdGVycyA9IHZvaWQgMDsKICAgICAgICB2YXIgX2NoYXJXaWR0aCA9IHZvaWQgMDsKICAgICAgICBpZiAoX2NoYXJDb2RlID09PSA5IC8qIENoYXJDb2RlLlRhYiAqLykgewogICAgICAgICAgcHJvZHVjZWRDaGFyYWN0ZXJzID0gdGFiU2l6ZSAtIHZpc2libGVDb2x1bW4gJSB0YWJTaXplIHwgMDsKICAgICAgICAgIF9jaGFyV2lkdGggPSBwcm9kdWNlZENoYXJhY3RlcnM7CiAgICAgICAgICBpZiAoIWNhblVzZUhhbGZ3aWR0aFJpZ2h0d2FyZHNBcnJvdyB8fCBfY2hhcldpZHRoID4gMSkgewogICAgICAgICAgICBzYi53cml0ZTEoMHgyMTkyKTsgLy8gUklHSFRXQVJEUyBBUlJPVwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgc2Iud3JpdGUxKDB4RkZFQik7IC8vIEhBTEZXSURUSCBSSUdIVFdBUkRTIEFSUk9XCiAgICAgICAgICB9CgogICAgICAgICAgZm9yICh2YXIgc3BhY2UgPSAyOyBzcGFjZSA8PSBfY2hhcldpZHRoOyBzcGFjZSsrKSB7CiAgICAgICAgICAgIHNiLndyaXRlMSgweEEwKTsgLy8gJm5ic3A7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIG11c3QgYmUgQ2hhckNvZGUuU3BhY2UKICAgICAgICAgIHByb2R1Y2VkQ2hhcmFjdGVycyA9IDI7CiAgICAgICAgICBfY2hhcldpZHRoID0gMTsKICAgICAgICAgIHNiLndyaXRlMShyZW5kZXJTcGFjZUNoYXJDb2RlKTsgLy8gJm1pZGRvdDsgb3Igd29yZCBzZXBhcmF0b3IgbWlkZGxlIGRvdAogICAgICAgICAgc2Iud3JpdGUxKDB4MjAwQyk7IC8vIFpFUk8gV0lEVEggTk9OLUpPSU5FUgogICAgICAgIH0KCiAgICAgICAgY2hhck9mZnNldEluUGFydCArPSBwcm9kdWNlZENoYXJhY3RlcnM7CiAgICAgICAgY2hhckhvcml6b250YWxPZmZzZXQgKz0gX2NoYXJXaWR0aDsKICAgICAgICBpZiAoY2hhckluZGV4ID49IGZhdXhJbmRlbnRMZW5ndGgpIHsKICAgICAgICAgIHZpc2libGVDb2x1bW4gKz0gX2NoYXJXaWR0aDsKICAgICAgICB9CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIHNiLmFwcGVuZEFTQ0lJKDYyIC8qIENoYXJDb2RlLkdyZWF0ZXJUaGFuICovKTsKICAgICAgZm9yICg7IGNoYXJJbmRleCA8IHBhcnRFbmRJbmRleDsgY2hhckluZGV4KyspIHsKICAgICAgICBjaGFyYWN0ZXJNYXBwaW5nLnNldENvbHVtbkluZm8oY2hhckluZGV4ICsgMSwgcGFydEluZGV4IC0gcGFydERpc3BsYWNlbWVudCwgY2hhck9mZnNldEluUGFydCwgY2hhckhvcml6b250YWxPZmZzZXQpOwogICAgICAgIHBhcnREaXNwbGFjZW1lbnQgPSAwOwogICAgICAgIHZhciBfY2hhckNvZGUyID0gbGluZUNvbnRlbnQuY2hhckNvZGVBdChjaGFySW5kZXgpOwogICAgICAgIHZhciBfcHJvZHVjZWRDaGFyYWN0ZXJzID0gMTsKICAgICAgICB2YXIgX2NoYXJXaWR0aDIgPSAxOwogICAgICAgIHN3aXRjaCAoX2NoYXJDb2RlMikgewogICAgICAgICAgY2FzZSA5IC8qIENoYXJDb2RlLlRhYiAqLzoKICAgICAgICAgICAgX3Byb2R1Y2VkQ2hhcmFjdGVycyA9IHRhYlNpemUgLSB2aXNpYmxlQ29sdW1uICUgdGFiU2l6ZTsKICAgICAgICAgICAgX2NoYXJXaWR0aDIgPSBfcHJvZHVjZWRDaGFyYWN0ZXJzOwogICAgICAgICAgICBmb3IgKHZhciBfc3BhY2UgPSAxOyBfc3BhY2UgPD0gX3Byb2R1Y2VkQ2hhcmFjdGVyczsgX3NwYWNlKyspIHsKICAgICAgICAgICAgICBzYi53cml0ZTEoMHhBMCk7IC8vICZuYnNwOwogICAgICAgICAgICB9CgogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgMzIgLyogQ2hhckNvZGUuU3BhY2UgKi86CiAgICAgICAgICAgIHNiLndyaXRlMSgweEEwKTsgLy8gJm5ic3A7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSA2MCAvKiBDaGFyQ29kZS5MZXNzVGhhbiAqLzoKICAgICAgICAgICAgc2IuYXBwZW5kQVNDSUlTdHJpbmcoJyZsdDsnKTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlIDYyIC8qIENoYXJDb2RlLkdyZWF0ZXJUaGFuICovOgogICAgICAgICAgICBzYi5hcHBlbmRBU0NJSVN0cmluZygnJmd0OycpOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgMzggLyogQ2hhckNvZGUuQW1wZXJzYW5kICovOgogICAgICAgICAgICBzYi5hcHBlbmRBU0NJSVN0cmluZygnJmFtcDsnKTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlIDAgLyogQ2hhckNvZGUuTnVsbCAqLzoKICAgICAgICAgICAgaWYgKHJlbmRlckNvbnRyb2xDaGFyYWN0ZXJzKSB7CiAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vdW5pY29kZS10YWJsZS5jb20vZW4vYmxvY2tzL2NvbnRyb2wtcGljdHVyZXMvCiAgICAgICAgICAgICAgc2Iud3JpdGUxKDkyMTYpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHNiLmFwcGVuZEFTQ0lJU3RyaW5nKCcmIzAwOycpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSA2NTI3OSAvKiBDaGFyQ29kZS5VVEY4X0JPTSAqLzoKICAgICAgICAgIGNhc2UgODIzMiAvKiBDaGFyQ29kZS5MSU5FX1NFUEFSQVRPUiAqLzoKICAgICAgICAgIGNhc2UgODIzMyAvKiBDaGFyQ29kZS5QQVJBR1JBUEhfU0VQQVJBVE9SICovOgogICAgICAgICAgY2FzZSAxMzMgLyogQ2hhckNvZGUuTkVYVF9MSU5FICovOgogICAgICAgICAgICBzYi53cml0ZTEoMHhGRkZEKTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICBpZiAoc3RyaW5ncy5pc0Z1bGxXaWR0aENoYXJhY3RlcihfY2hhckNvZGUyKSkgewogICAgICAgICAgICAgIF9jaGFyV2lkdGgyKys7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vdW5pY29kZS10YWJsZS5jb20vZW4vYmxvY2tzL2NvbnRyb2wtcGljdHVyZXMvCiAgICAgICAgICAgIGlmIChyZW5kZXJDb250cm9sQ2hhcmFjdGVycyAmJiBfY2hhckNvZGUyIDwgMzIpIHsKICAgICAgICAgICAgICBzYi53cml0ZTEoOTIxNiArIF9jaGFyQ29kZTIpOwogICAgICAgICAgICB9IGVsc2UgaWYgKHJlbmRlckNvbnRyb2xDaGFyYWN0ZXJzICYmIF9jaGFyQ29kZTIgPT09IDEyNykgewogICAgICAgICAgICAgIC8vIERFTAogICAgICAgICAgICAgIHNiLndyaXRlMSg5MjQ5KTsKICAgICAgICAgICAgfSBlbHNlIGlmIChyZW5kZXJDb250cm9sQ2hhcmFjdGVycyAmJiBpc0NvbnRyb2xDaGFyYWN0ZXIoX2NoYXJDb2RlMikpIHsKICAgICAgICAgICAgICBzYi5hcHBlbmRBU0NJSVN0cmluZygnW1UrJyk7CiAgICAgICAgICAgICAgc2IuYXBwZW5kQVNDSUlTdHJpbmcodG80Q2hhckhleChfY2hhckNvZGUyKSk7CiAgICAgICAgICAgICAgc2IuYXBwZW5kQVNDSUlTdHJpbmcoJ10nKTsKICAgICAgICAgICAgICBfcHJvZHVjZWRDaGFyYWN0ZXJzID0gODsKICAgICAgICAgICAgICBfY2hhcldpZHRoMiA9IF9wcm9kdWNlZENoYXJhY3RlcnM7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgc2Iud3JpdGUxKF9jaGFyQ29kZTIpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGNoYXJPZmZzZXRJblBhcnQgKz0gX3Byb2R1Y2VkQ2hhcmFjdGVyczsKICAgICAgICBjaGFySG9yaXpvbnRhbE9mZnNldCArPSBfY2hhcldpZHRoMjsKICAgICAgICBpZiAoY2hhckluZGV4ID49IGZhdXhJbmRlbnRMZW5ndGgpIHsKICAgICAgICAgIHZpc2libGVDb2x1bW4gKz0gX2NoYXJXaWR0aDI7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBpZiAocGFydElzRW1wdHlBbmRIYXNQc2V1ZG9BZnRlcikgewogICAgICBwYXJ0RGlzcGxhY2VtZW50Kys7CiAgICB9IGVsc2UgewogICAgICBwYXJ0RGlzcGxhY2VtZW50ID0gMDsKICAgIH0KICAgIGlmIChjaGFySW5kZXggPj0gbGVuICYmICFsYXN0Q2hhcmFjdGVyTWFwcGluZ0RlZmluZWQgJiYgcGFydC5pc1BzZXVkb0FmdGVyKCkpIHsKICAgICAgbGFzdENoYXJhY3Rlck1hcHBpbmdEZWZpbmVkID0gdHJ1ZTsKICAgICAgY2hhcmFjdGVyTWFwcGluZy5zZXRDb2x1bW5JbmZvKGNoYXJJbmRleCArIDEsIHBhcnRJbmRleCwgY2hhck9mZnNldEluUGFydCwgY2hhckhvcml6b250YWxPZmZzZXQpOwogICAgfQogICAgc2IuYXBwZW5kQVNDSUlTdHJpbmcoJzwvc3Bhbj4nKTsKICB9CiAgaWYgKCFsYXN0Q2hhcmFjdGVyTWFwcGluZ0RlZmluZWQpIHsKICAgIC8vIFdoZW4gZ2V0dGluZyBjbGllbnQgcmVjdHMgZm9yIHRoZSBsYXN0IGNoYXJhY3Rlciwgd2Ugd2lsbCBwb3NpdGlvbiB0aGUKICAgIC8vIHRleHQgcmFuZ2UgYXQgdGhlIGVuZCBvZiB0aGUgc3BhbiwgaW5zdGVhZiBvZiBhdCB0aGUgYmVnaW5uaW5nIG9mIG5leHQgc3BhbgogICAgY2hhcmFjdGVyTWFwcGluZy5zZXRDb2x1bW5JbmZvKGxlbiArIDEsIHBhcnRzLmxlbmd0aCAtIDEsIGNoYXJPZmZzZXRJblBhcnQsIGNoYXJIb3Jpem9udGFsT2Zmc2V0KTsKICB9CiAgaWYgKGlzT3ZlcmZsb3dpbmcpIHsKICAgIHNiLmFwcGVuZEFTQ0lJU3RyaW5nKCc8c3Bhbj4maGVsbGlwOzwvc3Bhbj4nKTsKICB9CiAgc2IuYXBwZW5kQVNDSUlTdHJpbmcoJzwvc3Bhbj4nKTsKICByZXR1cm4gbmV3IFJlbmRlckxpbmVPdXRwdXQoY2hhcmFjdGVyTWFwcGluZywgY29udGFpbnNSVEwsIGNvbnRhaW5zRm9yZWlnbkVsZW1lbnRzKTsKfQpmdW5jdGlvbiB0bzRDaGFySGV4KG4pIHsKICByZXR1cm4gbi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCg0LCAnMCcpOwp9"},{"version":3,"names":["strings","createStringBuilder","LineDecoration","LineDecorationsNormalizer","LinePart","LineRange","startIndex","endIndex","startOffset","endOffset","otherLineRange","RenderLineInput","useMonospaceOptimizations","canUseHalfwidthRightwardsArrow","lineContent","continuesWithWrappedLine","isBasicASCII","containsRTL","fauxIndentLength","lineTokens","lineDecorations","tabSize","startVisibleColumn","spaceWidth","middotWidth","wsmiddotWidth","stopRenderingLineAfter","renderWhitespace","renderControlCharacters","fontLigatures","selectionsOnLine","sort","compare","a","b","wsmiddotDiff","Math","abs","middotDiff","renderSpaceWidth","renderSpaceCharCode","otherSelections","length","i","equals","other","equalsArr","sameSelection","DomPosition","partIndex","charIndex","CharacterMapping","partCount","_data","Uint32Array","_horizontalOffset","column","horizontalOffset","partData","charOffset","charOffsetToPartData","getPartIndex","getCharIndex","domPosition","partLength","partDataToCharOffset","searchEntry","min","max","mid","midEntry","minEntry","maxEntry","minPartIndex","minCharIndex","maxPartIndex","maxCharIndex","minEntryDistance","maxEntryDistance","RenderLineOutput","characterMapping","containsForeignElements","_renderLineOutputBrand","undefined","renderViewLine","input","sb","appendASCIIString","beforeCount","afterCount","lineDecoration","type","className","setColumnInfo","_renderLine","resolveRenderLineInput","RenderLineOutput2","html","renderViewLine2","out","build","ResolvedRenderLineInput","fontIsMonospace","len","isOverflowing","parts","tokens","transformAndRemoveOverflowing","extractControlCharacters","_applyRenderWhitespace","_applyInlineDecorations","splitLargeTokens","lineContainsRTL","result","resultLen","tokenIndex","tokensLen","getCount","getEndOffset","getClassName","tokenContainsRTL","substring","onlyAtSpaces","lastTokenEndIndex","token","tokenEndIndex","tokenType","tokenMetadata","metadata","lastSpaceOffset","currTokenStart","j","charCodeAt","diff","piecesCount","ceil","pieceEndIndex","isControlCharacter","charCode","lastLinePart","push","selections","onlyBoundary","onlyTrailing","generateLinePartForEachWhitespace","tokensLength","lineIsEmptyOrWhitespace","firstNonWhitespaceIndex","lastNonWhitespaceIndex","wasInWhitespace","currentSelectionIndex","currentSelection","tmpIndent","chCode","isInWhitespace","nextChCode","lastEndIndex","isFullWidthCharacter","generateWhitespace","lastCharCode","prevCharCode","isSingleTrailingSpace","_lineDecorations","normalize","lineDecorationsLen","lineDecorationIndex","lastResultEndIndex","lastCharacterMappingDefined","visibleColumn","charOffsetInPart","charHorizontalOffset","partDisplacement","part","partEndIndex","partType","partContainsRTL","partRendersWhitespace","isWhitespace","partRendersWhitespaceWithWidth","partIsEmptyAndHasPseudoAfter","isPseudoAfter","appendASCII","partWidth","_charIndex","_visibleColumn","charWidth","String","producedCharacters","write1","space","to4CharHex","n","toString","toUpperCase","padStart"],"sources":["/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { createStringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nimport { LinePart } from './linePart.js';\nexport class LineRange {\n    constructor(startIndex, endIndex) {\n        this.startOffset = startIndex;\n        this.endOffset = endIndex;\n    }\n    equals(otherLineRange) {\n        return this.startOffset === otherLineRange.startOffset\n            && this.endOffset === otherLineRange.endOffset;\n    }\n}\nexport class RenderLineInput {\n    constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = isBasicASCII;\n        this.containsRTL = containsRTL;\n        this.fauxIndentLength = fauxIndentLength;\n        this.lineTokens = lineTokens;\n        this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.spaceWidth = spaceWidth;\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\n        this.renderWhitespace = (renderWhitespace === 'all'\n            ? 4 /* RenderWhitespace.All */\n            : renderWhitespace === 'boundary'\n                ? 1 /* RenderWhitespace.Boundary */\n                : renderWhitespace === 'selection'\n                    ? 2 /* RenderWhitespace.Selection */\n                    : renderWhitespace === 'trailing'\n                        ? 3 /* RenderWhitespace.Trailing */\n                        : 0 /* RenderWhitespace.None */);\n        this.renderControlCharacters = renderControlCharacters;\n        this.fontLigatures = fontLigatures;\n        this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\n        const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n        const middotDiff = Math.abs(middotWidth - spaceWidth);\n        if (wsmiddotDiff < middotDiff) {\n            this.renderSpaceWidth = wsmiddotWidth;\n            this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n        }\n        else {\n            this.renderSpaceWidth = middotWidth;\n            this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n        }\n    }\n    sameSelection(otherSelections) {\n        if (this.selectionsOnLine === null) {\n            return otherSelections === null;\n        }\n        if (otherSelections === null) {\n            return false;\n        }\n        if (otherSelections.length !== this.selectionsOnLine.length) {\n            return false;\n        }\n        for (let i = 0; i < this.selectionsOnLine.length; i++) {\n            if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    equals(other) {\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.lineContent === other.lineContent\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\n            && this.isBasicASCII === other.isBasicASCII\n            && this.containsRTL === other.containsRTL\n            && this.fauxIndentLength === other.fauxIndentLength\n            && this.tabSize === other.tabSize\n            && this.startVisibleColumn === other.startVisibleColumn\n            && this.spaceWidth === other.spaceWidth\n            && this.renderSpaceWidth === other.renderSpaceWidth\n            && this.renderSpaceCharCode === other.renderSpaceCharCode\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n            && this.renderWhitespace === other.renderWhitespace\n            && this.renderControlCharacters === other.renderControlCharacters\n            && this.fontLigatures === other.fontLigatures\n            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n            && this.lineTokens.equals(other.lineTokens)\n            && this.sameSelection(other.selectionsOnLine));\n    }\n}\nexport class DomPosition {\n    constructor(partIndex, charIndex) {\n        this.partIndex = partIndex;\n        this.charIndex = charIndex;\n    }\n}\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nexport class CharacterMapping {\n    constructor(length, partCount) {\n        this.length = length;\n        this._data = new Uint32Array(this.length);\n        this._horizontalOffset = new Uint32Array(this.length);\n    }\n    static getPartIndex(partData) {\n        return (partData & 4294901760 /* CharacterMappingConstants.PART_INDEX_MASK */) >>> 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */;\n    }\n    static getCharIndex(partData) {\n        return (partData & 65535 /* CharacterMappingConstants.CHAR_INDEX_MASK */) >>> 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */;\n    }\n    setColumnInfo(column, partIndex, charIndex, horizontalOffset) {\n        const partData = ((partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */)) >>> 0;\n        this._data[column - 1] = partData;\n        this._horizontalOffset[column - 1] = horizontalOffset;\n    }\n    getHorizontalOffset(column) {\n        if (this._horizontalOffset.length === 0) {\n            // No characters on this line\n            return 0;\n        }\n        return this._horizontalOffset[column - 1];\n    }\n    charOffsetToPartData(charOffset) {\n        if (this.length === 0) {\n            return 0;\n        }\n        if (charOffset < 0) {\n            return this._data[0];\n        }\n        if (charOffset >= this.length) {\n            return this._data[this.length - 1];\n        }\n        return this._data[charOffset];\n    }\n    getDomPosition(column) {\n        const partData = this.charOffsetToPartData(column - 1);\n        const partIndex = CharacterMapping.getPartIndex(partData);\n        const charIndex = CharacterMapping.getCharIndex(partData);\n        return new DomPosition(partIndex, charIndex);\n    }\n    getColumn(domPosition, partLength) {\n        const charOffset = this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex);\n        return charOffset + 1;\n    }\n    partDataToCharOffset(partIndex, partLength, charIndex) {\n        if (this.length === 0) {\n            return 0;\n        }\n        const searchEntry = ((partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */)) >>> 0;\n        let min = 0;\n        let max = this.length - 1;\n        while (min + 1 < max) {\n            const mid = ((min + max) >>> 1);\n            const midEntry = this._data[mid];\n            if (midEntry === searchEntry) {\n                return mid;\n            }\n            else if (midEntry > searchEntry) {\n                max = mid;\n            }\n            else {\n                min = mid;\n            }\n        }\n        if (min === max) {\n            return min;\n        }\n        const minEntry = this._data[min];\n        const maxEntry = this._data[max];\n        if (minEntry === searchEntry) {\n            return min;\n        }\n        if (maxEntry === searchEntry) {\n            return max;\n        }\n        const minPartIndex = CharacterMapping.getPartIndex(minEntry);\n        const minCharIndex = CharacterMapping.getCharIndex(minEntry);\n        const maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n        let maxCharIndex;\n        if (minPartIndex !== maxPartIndex) {\n            // sitting between parts\n            maxCharIndex = partLength;\n        }\n        else {\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n        }\n        const minEntryDistance = charIndex - minCharIndex;\n        const maxEntryDistance = maxCharIndex - charIndex;\n        if (minEntryDistance <= maxEntryDistance) {\n            return min;\n        }\n        return max;\n    }\n}\nexport class RenderLineOutput {\n    constructor(characterMapping, containsRTL, containsForeignElements) {\n        this._renderLineOutputBrand = undefined;\n        this.characterMapping = characterMapping;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine(input, sb) {\n    if (input.lineContent.length === 0) {\n        if (input.lineDecorations.length > 0) {\n            // This line is empty, but it contains inline decorations\n            sb.appendASCIIString(`<span>`);\n            let beforeCount = 0;\n            let afterCount = 0;\n            let containsForeignElements = 0 /* ForeignElementType.None */;\n            for (const lineDecoration of input.lineDecorations) {\n                if (lineDecoration.type === 1 /* InlineDecorationType.Before */ || lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                    sb.appendASCIIString(`<span class=\"`);\n                    sb.appendASCIIString(lineDecoration.className);\n                    sb.appendASCIIString(`\"></span>`);\n                    if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n                        containsForeignElements |= 1 /* ForeignElementType.Before */;\n                        beforeCount++;\n                    }\n                    if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                        containsForeignElements |= 2 /* ForeignElementType.After */;\n                        afterCount++;\n                    }\n                }\n            }\n            sb.appendASCIIString(`</span>`);\n            const characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n            characterMapping.setColumnInfo(1, beforeCount, 0, 0);\n            return new RenderLineOutput(characterMapping, false, containsForeignElements);\n        }\n        // completely empty line\n        sb.appendASCIIString('<span><span></span></span>');\n        return new RenderLineOutput(new CharacterMapping(0, 0), false, 0 /* ForeignElementType.None */);\n    }\n    return _renderLine(resolveRenderLineInput(input), sb);\n}\nexport class RenderLineOutput2 {\n    constructor(characterMapping, html, containsRTL, containsForeignElements) {\n        this.characterMapping = characterMapping;\n        this.html = html;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine2(input) {\n    const sb = createStringBuilder(10000);\n    const out = renderViewLine(input, sb);\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\nclass ResolvedRenderLineInput {\n    constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n        this.fontIsMonospace = fontIsMonospace;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.len = len;\n        this.isOverflowing = isOverflowing;\n        this.parts = parts;\n        this.containsForeignElements = containsForeignElements;\n        this.fauxIndentLength = fauxIndentLength;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.containsRTL = containsRTL;\n        this.spaceWidth = spaceWidth;\n        this.renderSpaceCharCode = renderSpaceCharCode;\n        this.renderWhitespace = renderWhitespace;\n        this.renderControlCharacters = renderControlCharacters;\n        //\n    }\n}\nfunction resolveRenderLineInput(input) {\n    const lineContent = input.lineContent;\n    let isOverflowing;\n    let len;\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n        isOverflowing = true;\n        len = input.stopRenderingLineAfter;\n    }\n    else {\n        isOverflowing = false;\n        len = lineContent.length;\n    }\n    let tokens = transformAndRemoveOverflowing(lineContent, input.containsRTL, input.lineTokens, input.fauxIndentLength, len);\n    if (input.renderControlCharacters && !input.isBasicASCII) {\n        // Calling `extractControlCharacters` before adding (possibly empty) line parts\n        // for inline decorations. `extractControlCharacters` removes empty line parts.\n        tokens = extractControlCharacters(lineContent, tokens);\n    }\n    if (input.renderWhitespace === 4 /* RenderWhitespace.All */ ||\n        input.renderWhitespace === 1 /* RenderWhitespace.Boundary */ ||\n        (input.renderWhitespace === 2 /* RenderWhitespace.Selection */ && !!input.selectionsOnLine) ||\n        input.renderWhitespace === 3 /* RenderWhitespace.Trailing */) {\n        tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n    }\n    let containsForeignElements = 0 /* ForeignElementType.None */;\n    if (input.lineDecorations.length > 0) {\n        for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n            const lineDecoration = input.lineDecorations[i];\n            if (lineDecoration.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */) {\n                // Pretend there are foreign elements... although not 100% accurate.\n                containsForeignElements |= 1 /* ForeignElementType.Before */;\n            }\n            else if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n                containsForeignElements |= 1 /* ForeignElementType.Before */;\n            }\n            else if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                containsForeignElements |= 2 /* ForeignElementType.After */;\n            }\n        }\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n    }\n    if (!input.containsRTL) {\n        // We can never split RTL text, as it ruins the rendering\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n    }\n    return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(lineContent, lineContainsRTL, tokens, fauxIndentLength, len) {\n    const result = [];\n    let resultLen = 0;\n    // The faux indent part of the line should have no token type\n    if (fauxIndentLength > 0) {\n        result[resultLen++] = new LinePart(fauxIndentLength, '', 0, false);\n    }\n    let startOffset = fauxIndentLength;\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n        const endIndex = tokens.getEndOffset(tokenIndex);\n        if (endIndex <= fauxIndentLength) {\n            // The faux indent part of the line should have no token type\n            continue;\n        }\n        const type = tokens.getClassName(tokenIndex);\n        if (endIndex >= len) {\n            const tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, len)) : false);\n            result[resultLen++] = new LinePart(len, type, 0, tokenContainsRTL);\n            break;\n        }\n        const tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, endIndex)) : false);\n        result[resultLen++] = new LinePart(endIndex, type, 0, tokenContainsRTL);\n        startOffset = endIndex;\n    }\n    return result;\n}\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n    let lastTokenEndIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    if (onlyAtSpaces) {\n        // Split only at spaces => we need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            if (lastTokenEndIndex + 50 /* Constants.LongToken */ < tokenEndIndex) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const tokenContainsRTL = token.containsRTL;\n                let lastSpaceOffset = -1;\n                let currTokenStart = lastTokenEndIndex;\n                for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n                    if (lineContent.charCodeAt(j) === 32 /* CharCode.Space */) {\n                        lastSpaceOffset = j;\n                    }\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* Constants.LongToken */) {\n                        // Split at `lastSpaceOffset` + 1\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata, tokenContainsRTL);\n                        currTokenStart = lastSpaceOffset + 1;\n                        lastSpaceOffset = -1;\n                    }\n                }\n                if (currTokenStart !== tokenEndIndex) {\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n                }\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    else {\n        // Split anywhere => we don't need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            const diff = (tokenEndIndex - lastTokenEndIndex);\n            if (diff > 50 /* Constants.LongToken */) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const tokenContainsRTL = token.containsRTL;\n                const piecesCount = Math.ceil(diff / 50 /* Constants.LongToken */);\n                for (let j = 1; j < piecesCount; j++) {\n                    const pieceEndIndex = lastTokenEndIndex + (j * 50 /* Constants.LongToken */);\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n                }\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    return result;\n}\nfunction isControlCharacter(charCode) {\n    if (charCode < 32) {\n        return (charCode !== 9 /* CharCode.Tab */);\n    }\n    if (charCode === 127) {\n        // DEL\n        return true;\n    }\n    if ((charCode >= 0x202A && charCode <= 0x202E)\n        || (charCode >= 0x2066 && charCode <= 0x2069)\n        || (charCode >= 0x200E && charCode <= 0x200F)\n        || charCode === 0x061C) {\n        // Unicode Directional Formatting Characters\n        // LRE\tU+202A\tLEFT-TO-RIGHT EMBEDDING\n        // RLE\tU+202B\tRIGHT-TO-LEFT EMBEDDING\n        // PDF\tU+202C\tPOP DIRECTIONAL FORMATTING\n        // LRO\tU+202D\tLEFT-TO-RIGHT OVERRIDE\n        // RLO\tU+202E\tRIGHT-TO-LEFT OVERRIDE\n        // LRI\tU+2066\tLEFT-TO-RIGHT ISOLATE\n        // RLI\tU+2067\tRIGHT-TO-LEFT ISOLATE\n        // FSI\tU+2068\tFIRST STRONG ISOLATE\n        // PDI\tU+2069\tPOP DIRECTIONAL ISOLATE\n        // LRM\tU+200E\tLEFT-TO-RIGHT MARK\n        // RLM\tU+200F\tRIGHT-TO-LEFT MARK\n        // ALM\tU+061C\tARABIC LETTER MARK\n        return true;\n    }\n    return false;\n}\nfunction extractControlCharacters(lineContent, tokens) {\n    const result = [];\n    let lastLinePart = new LinePart(0, '', 0, false);\n    let charOffset = 0;\n    for (const token of tokens) {\n        const tokenEndIndex = token.endIndex;\n        for (; charOffset < tokenEndIndex; charOffset++) {\n            const charCode = lineContent.charCodeAt(charOffset);\n            if (isControlCharacter(charCode)) {\n                if (charOffset > lastLinePart.endIndex) {\n                    // emit previous part if it has text\n                    lastLinePart = new LinePart(charOffset, token.type, token.metadata, token.containsRTL);\n                    result.push(lastLinePart);\n                }\n                lastLinePart = new LinePart(charOffset + 1, 'mtkcontrol', token.metadata, false);\n                result.push(lastLinePart);\n            }\n        }\n        if (charOffset > lastLinePart.endIndex) {\n            // emit previous part if it has text\n            lastLinePart = new LinePart(tokenEndIndex, token.type, token.metadata, token.containsRTL);\n            result.push(lastLinePart);\n        }\n    }\n    return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n    const continuesWithWrappedLine = input.continuesWithWrappedLine;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const useMonospaceOptimizations = input.useMonospaceOptimizations;\n    const selections = input.selectionsOnLine;\n    const onlyBoundary = (input.renderWhitespace === 1 /* RenderWhitespace.Boundary */);\n    const onlyTrailing = (input.renderWhitespace === 3 /* RenderWhitespace.Trailing */);\n    const generateLinePartForEachWhitespace = (input.renderSpaceWidth !== input.spaceWidth);\n    const result = [];\n    let resultLen = 0;\n    let tokenIndex = 0;\n    let tokenType = tokens[tokenIndex].type;\n    let tokenContainsRTL = tokens[tokenIndex].containsRTL;\n    let tokenEndIndex = tokens[tokenIndex].endIndex;\n    const tokensLength = tokens.length;\n    let lineIsEmptyOrWhitespace = false;\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n    let lastNonWhitespaceIndex;\n    if (firstNonWhitespaceIndex === -1) {\n        lineIsEmptyOrWhitespace = true;\n        firstNonWhitespaceIndex = len;\n        lastNonWhitespaceIndex = len;\n    }\n    else {\n        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n    }\n    let wasInWhitespace = false;\n    let currentSelectionIndex = 0;\n    let currentSelection = selections && selections[currentSelectionIndex];\n    let tmpIndent = startVisibleColumn % tabSize;\n    for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n        const chCode = lineContent.charCodeAt(charIndex);\n        if (currentSelection && charIndex >= currentSelection.endOffset) {\n            currentSelectionIndex++;\n            currentSelection = selections && selections[currentSelectionIndex];\n        }\n        let isInWhitespace;\n        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n            // in leading or trailing whitespace\n            isInWhitespace = true;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            // a tab character is rendered both in all and boundary cases\n            isInWhitespace = true;\n        }\n        else if (chCode === 32 /* CharCode.Space */) {\n            // hit a space character\n            if (onlyBoundary) {\n                // rendering only boundary whitespace\n                if (wasInWhitespace) {\n                    isInWhitespace = true;\n                }\n                else {\n                    const nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* CharCode.Null */);\n                    isInWhitespace = (nextChCode === 32 /* CharCode.Space */ || nextChCode === 9 /* CharCode.Tab */);\n                }\n            }\n            else {\n                isInWhitespace = true;\n            }\n        }\n        else {\n            isInWhitespace = false;\n        }\n        // If rendering whitespace on selection, check that the charIndex falls within a selection\n        if (isInWhitespace && selections) {\n            isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n        }\n        // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n        if (isInWhitespace && onlyTrailing) {\n            isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n        }\n        if (isInWhitespace && tokenContainsRTL) {\n            // If the token contains RTL text, breaking it up into multiple line parts\n            // to render whitespace might affect the browser's bidi layout.\n            //\n            // We render whitespace in such tokens only if the whitespace\n            // is the leading or the trailing whitespace of the line,\n            // which doesn't affect the browser's bidi layout.\n            if (charIndex >= firstNonWhitespaceIndex && charIndex <= lastNonWhitespaceIndex) {\n                isInWhitespace = false;\n            }\n        }\n        if (wasInWhitespace) {\n            // was in whitespace token\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n                // leaving whitespace token or entering a new indent\n                if (generateLinePartForEachWhitespace) {\n                    const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n                    for (let i = lastEndIndex + 1; i <= charIndex; i++) {\n                        result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n                    }\n                }\n                else {\n                    result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n                }\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        else {\n            // was in regular token\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n                result[resultLen++] = new LinePart(charIndex, tokenType, 0, tokenContainsRTL);\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        if (chCode === 9 /* CharCode.Tab */) {\n            tmpIndent = tabSize;\n        }\n        else if (strings.isFullWidthCharacter(chCode)) {\n            tmpIndent += 2;\n        }\n        else {\n            tmpIndent++;\n        }\n        wasInWhitespace = isInWhitespace;\n        while (charIndex === tokenEndIndex) {\n            tokenIndex++;\n            if (tokenIndex < tokensLength) {\n                tokenType = tokens[tokenIndex].type;\n                tokenContainsRTL = tokens[tokenIndex].containsRTL;\n                tokenEndIndex = tokens[tokenIndex].endIndex;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    let generateWhitespace = false;\n    if (wasInWhitespace) {\n        // was in whitespace token\n        if (continuesWithWrappedLine && onlyBoundary) {\n            const lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* CharCode.Null */);\n            const prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* CharCode.Null */);\n            const isSingleTrailingSpace = (lastCharCode === 32 /* CharCode.Space */ && (prevCharCode !== 32 /* CharCode.Space */ && prevCharCode !== 9 /* CharCode.Tab */));\n            if (!isSingleTrailingSpace) {\n                generateWhitespace = true;\n            }\n        }\n        else {\n            generateWhitespace = true;\n        }\n    }\n    if (generateWhitespace) {\n        if (generateLinePartForEachWhitespace) {\n            const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n            for (let i = lastEndIndex + 1; i <= len; i++) {\n                result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n            }\n        }\n        else {\n            result[resultLen++] = new LinePart(len, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n        }\n    }\n    else {\n        result[resultLen++] = new LinePart(len, tokenType, 0, tokenContainsRTL);\n    }\n    return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n    _lineDecorations.sort(LineDecoration.compare);\n    const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n    const lineDecorationsLen = lineDecorations.length;\n    let lineDecorationIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    let lastResultEndIndex = 0;\n    for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n        const token = tokens[tokenIndex];\n        const tokenEndIndex = token.endIndex;\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        const tokenContainsRTL = token.containsRTL;\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            if (lineDecoration.startOffset > lastResultEndIndex) {\n                lastResultEndIndex = lineDecoration.startOffset;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n            }\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n                // This line decoration ends before this token ends\n                lastResultEndIndex = lineDecoration.endOffset + 1;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n                lineDecorationIndex++;\n            }\n            else {\n                // This line decoration continues on to the next token\n                lastResultEndIndex = tokenEndIndex;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n                break;\n            }\n        }\n        if (tokenEndIndex > lastResultEndIndex) {\n            lastResultEndIndex = tokenEndIndex;\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n        }\n    }\n    const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            result[resultLen++] = new LinePart(lastResultEndIndex, lineDecoration.className, lineDecoration.metadata, false);\n            lineDecorationIndex++;\n        }\n    }\n    return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input, sb) {\n    const fontIsMonospace = input.fontIsMonospace;\n    const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n    const containsForeignElements = input.containsForeignElements;\n    const lineContent = input.lineContent;\n    const len = input.len;\n    const isOverflowing = input.isOverflowing;\n    const parts = input.parts;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const containsRTL = input.containsRTL;\n    const spaceWidth = input.spaceWidth;\n    const renderSpaceCharCode = input.renderSpaceCharCode;\n    const renderWhitespace = input.renderWhitespace;\n    const renderControlCharacters = input.renderControlCharacters;\n    const characterMapping = new CharacterMapping(len + 1, parts.length);\n    let lastCharacterMappingDefined = false;\n    let charIndex = 0;\n    let visibleColumn = startVisibleColumn;\n    let charOffsetInPart = 0; // the character offset in the current part\n    let charHorizontalOffset = 0; // the character horizontal position in terms of chars relative to line start\n    let partDisplacement = 0;\n    if (containsRTL) {\n        sb.appendASCIIString('<span dir=\"ltr\">');\n    }\n    else {\n        sb.appendASCIIString('<span>');\n    }\n    for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n        const part = parts[partIndex];\n        const partEndIndex = part.endIndex;\n        const partType = part.type;\n        const partContainsRTL = part.containsRTL;\n        const partRendersWhitespace = (renderWhitespace !== 0 /* RenderWhitespace.None */ && part.isWhitespace());\n        const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\n        const partIsEmptyAndHasPseudoAfter = (charIndex === partEndIndex && part.isPseudoAfter());\n        charOffsetInPart = 0;\n        sb.appendASCIIString('<span ');\n        if (partContainsRTL) {\n            sb.appendASCIIString('style=\"unicode-bidi:isolate\" ');\n        }\n        sb.appendASCIIString('class=\"');\n        sb.appendASCIIString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n        sb.appendASCII(34 /* CharCode.DoubleQuote */);\n        if (partRendersWhitespace) {\n            let partWidth = 0;\n            {\n                let _charIndex = charIndex;\n                let _visibleColumn = visibleColumn;\n                for (; _charIndex < partEndIndex; _charIndex++) {\n                    const charCode = lineContent.charCodeAt(_charIndex);\n                    const charWidth = (charCode === 9 /* CharCode.Tab */ ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\n                    partWidth += charWidth;\n                    if (_charIndex >= fauxIndentLength) {\n                        _visibleColumn += charWidth;\n                    }\n                }\n            }\n            if (partRendersWhitespaceWithWidth) {\n                sb.appendASCIIString(' style=\"width:');\n                sb.appendASCIIString(String(spaceWidth * partWidth));\n                sb.appendASCIIString('px\"');\n            }\n            sb.appendASCII(62 /* CharCode.GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters;\n                let charWidth;\n                if (charCode === 9 /* CharCode.Tab */) {\n                    producedCharacters = (tabSize - (visibleColumn % tabSize)) | 0;\n                    charWidth = producedCharacters;\n                    if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n                        sb.write1(0x2192); // RIGHTWARDS ARROW\n                    }\n                    else {\n                        sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n                    }\n                    for (let space = 2; space <= charWidth; space++) {\n                        sb.write1(0xA0); // &nbsp;\n                    }\n                }\n                else { // must be CharCode.Space\n                    producedCharacters = 2;\n                    charWidth = 1;\n                    sb.write1(renderSpaceCharCode); // &middot; or word separator middle dot\n                    sb.write1(0x200C); // ZERO WIDTH NON-JOINER\n                }\n                charOffsetInPart += producedCharacters;\n                charHorizontalOffset += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n        }\n        else {\n            sb.appendASCII(62 /* CharCode.GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters = 1;\n                let charWidth = 1;\n                switch (charCode) {\n                    case 9 /* CharCode.Tab */:\n                        producedCharacters = (tabSize - (visibleColumn % tabSize));\n                        charWidth = producedCharacters;\n                        for (let space = 1; space <= producedCharacters; space++) {\n                            sb.write1(0xA0); // &nbsp;\n                        }\n                        break;\n                    case 32 /* CharCode.Space */:\n                        sb.write1(0xA0); // &nbsp;\n                        break;\n                    case 60 /* CharCode.LessThan */:\n                        sb.appendASCIIString('&lt;');\n                        break;\n                    case 62 /* CharCode.GreaterThan */:\n                        sb.appendASCIIString('&gt;');\n                        break;\n                    case 38 /* CharCode.Ampersand */:\n                        sb.appendASCIIString('&amp;');\n                        break;\n                    case 0 /* CharCode.Null */:\n                        if (renderControlCharacters) {\n                            // See https://unicode-table.com/en/blocks/control-pictures/\n                            sb.write1(9216);\n                        }\n                        else {\n                            sb.appendASCIIString('&#00;');\n                        }\n                        break;\n                    case 65279 /* CharCode.UTF8_BOM */:\n                    case 8232 /* CharCode.LINE_SEPARATOR */:\n                    case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n                    case 133 /* CharCode.NEXT_LINE */:\n                        sb.write1(0xFFFD);\n                        break;\n                    default:\n                        if (strings.isFullWidthCharacter(charCode)) {\n                            charWidth++;\n                        }\n                        // See https://unicode-table.com/en/blocks/control-pictures/\n                        if (renderControlCharacters && charCode < 32) {\n                            sb.write1(9216 + charCode);\n                        }\n                        else if (renderControlCharacters && charCode === 127) {\n                            // DEL\n                            sb.write1(9249);\n                        }\n                        else if (renderControlCharacters && isControlCharacter(charCode)) {\n                            sb.appendASCIIString('[U+');\n                            sb.appendASCIIString(to4CharHex(charCode));\n                            sb.appendASCIIString(']');\n                            producedCharacters = 8;\n                            charWidth = producedCharacters;\n                        }\n                        else {\n                            sb.write1(charCode);\n                        }\n                }\n                charOffsetInPart += producedCharacters;\n                charHorizontalOffset += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n        }\n        if (partIsEmptyAndHasPseudoAfter) {\n            partDisplacement++;\n        }\n        else {\n            partDisplacement = 0;\n        }\n        if (charIndex >= len && !lastCharacterMappingDefined && part.isPseudoAfter()) {\n            lastCharacterMappingDefined = true;\n            characterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, charHorizontalOffset);\n        }\n        sb.appendASCIIString('</span>');\n    }\n    if (!lastCharacterMappingDefined) {\n        // When getting client rects for the last character, we will position the\n        // text range at the end of the span, insteaf of at the beginning of next span\n        characterMapping.setColumnInfo(len + 1, parts.length - 1, charOffsetInPart, charHorizontalOffset);\n    }\n    if (isOverflowing) {\n        sb.appendASCIIString('<span>&hellip;</span>');\n    }\n    sb.appendASCIIString('</span>');\n    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\nfunction to4CharHex(n) {\n    return n.toString(16).toUpperCase().padStart(4, '0');\n}\n"],"mappings":"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"}]}