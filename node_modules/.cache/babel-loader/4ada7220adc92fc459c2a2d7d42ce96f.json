{"remainingRequest":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/thread-loader/dist/cjs.js!/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js!/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js","dependencies":[{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/babel.config.js","mtime":1668271197000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js","mtime":456789000000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9pbmhlcml0cyBmcm9tICIvVXNlcnMveWFuamlhamlhL0Rlc2t0b3Avd29ya3NwYWNlL2F2dWUtZGF0YS1uZXcvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzLmpzIjsKaW1wb3J0IF9jcmVhdGVTdXBlciBmcm9tICIvVXNlcnMveWFuamlhamlhL0Rlc2t0b3Avd29ya3NwYWNlL2F2dWUtZGF0YS1uZXcvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZVN1cGVyLmpzIjsKaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICIvVXNlcnMveWFuamlhamlhL0Rlc2t0b3Avd29ya3NwYWNlL2F2dWUtZGF0YS1uZXcvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzIjsKaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICIvVXNlcnMveWFuamlhamlhL0Rlc2t0b3Avd29ya3NwYWNlL2F2dWUtZGF0YS1uZXcvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucHVzaC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcyI7Ci8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uCiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLwppbXBvcnQgKiBhcyBzdHJpbmdzIGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3N0cmluZ3MuanMnOwppbXBvcnQgeyBDaGFyYWN0ZXJDbGFzc2lmaWVyIH0gZnJvbSAnLi4vY29yZS9jaGFyYWN0ZXJDbGFzc2lmaWVyLmpzJzsKaW1wb3J0IHsgTGluZUluamVjdGVkVGV4dCB9IGZyb20gJy4uL3RleHRNb2RlbEV2ZW50cy5qcyc7CmltcG9ydCB7IE1vZGVsTGluZVByb2plY3Rpb25EYXRhIH0gZnJvbSAnLi4vbW9kZWxMaW5lUHJvamVjdGlvbkRhdGEuanMnOwpleHBvcnQgdmFyIE1vbm9zcGFjZUxpbmVCcmVha3NDb21wdXRlckZhY3RvcnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIGZ1bmN0aW9uIE1vbm9zcGFjZUxpbmVCcmVha3NDb21wdXRlckZhY3RvcnkoYnJlYWtCZWZvcmVDaGFycywgYnJlYWtBZnRlckNoYXJzKSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9ub3NwYWNlTGluZUJyZWFrc0NvbXB1dGVyRmFjdG9yeSk7CiAgICB0aGlzLmNsYXNzaWZpZXIgPSBuZXcgV3JhcHBpbmdDaGFyYWN0ZXJDbGFzc2lmaWVyKGJyZWFrQmVmb3JlQ2hhcnMsIGJyZWFrQWZ0ZXJDaGFycyk7CiAgfQogIF9jcmVhdGVDbGFzcyhNb25vc3BhY2VMaW5lQnJlYWtzQ29tcHV0ZXJGYWN0b3J5LCBbewogICAga2V5OiAiY3JlYXRlTGluZUJyZWFrc0NvbXB1dGVyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVMaW5lQnJlYWtzQ29tcHV0ZXIoZm9udEluZm8sIHRhYlNpemUsIHdyYXBwaW5nQ29sdW1uLCB3cmFwcGluZ0luZGVudCkgewogICAgICB2YXIgX3RoaXMgPSB0aGlzOwogICAgICB2YXIgcmVxdWVzdHMgPSBbXTsKICAgICAgdmFyIGluamVjdGVkVGV4dHMgPSBbXTsKICAgICAgdmFyIHByZXZpb3VzQnJlYWtpbmdEYXRhID0gW107CiAgICAgIHJldHVybiB7CiAgICAgICAgYWRkUmVxdWVzdDogZnVuY3Rpb24gYWRkUmVxdWVzdChsaW5lVGV4dCwgaW5qZWN0ZWRUZXh0LCBwcmV2aW91c0xpbmVCcmVha0RhdGEpIHsKICAgICAgICAgIHJlcXVlc3RzLnB1c2gobGluZVRleHQpOwogICAgICAgICAgaW5qZWN0ZWRUZXh0cy5wdXNoKGluamVjdGVkVGV4dCk7CiAgICAgICAgICBwcmV2aW91c0JyZWFraW5nRGF0YS5wdXNoKHByZXZpb3VzTGluZUJyZWFrRGF0YSk7CiAgICAgICAgfSwKICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gZmluYWxpemUoKSB7CiAgICAgICAgICB2YXIgY29sdW1uc0ZvckZ1bGxXaWR0aENoYXIgPSBmb250SW5mby50eXBpY2FsRnVsbHdpZHRoQ2hhcmFjdGVyV2lkdGggLyBmb250SW5mby50eXBpY2FsSGFsZndpZHRoQ2hhcmFjdGVyV2lkdGg7CiAgICAgICAgICB2YXIgcmVzdWx0ID0gW107CiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVxdWVzdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgICAgdmFyIGluamVjdGVkVGV4dCA9IGluamVjdGVkVGV4dHNbaV07CiAgICAgICAgICAgIHZhciBwcmV2aW91c0xpbmVCcmVha0RhdGEgPSBwcmV2aW91c0JyZWFraW5nRGF0YVtpXTsKICAgICAgICAgICAgaWYgKHByZXZpb3VzTGluZUJyZWFrRGF0YSAmJiAhcHJldmlvdXNMaW5lQnJlYWtEYXRhLmluamVjdGlvbk9wdGlvbnMgJiYgIWluamVjdGVkVGV4dCkgewogICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNyZWF0ZUxpbmVCcmVha3NGcm9tUHJldmlvdXNMaW5lQnJlYWtzKF90aGlzLmNsYXNzaWZpZXIsIHByZXZpb3VzTGluZUJyZWFrRGF0YSwgcmVxdWVzdHNbaV0sIHRhYlNpemUsIHdyYXBwaW5nQ29sdW1uLCBjb2x1bW5zRm9yRnVsbFdpZHRoQ2hhciwgd3JhcHBpbmdJbmRlbnQpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNyZWF0ZUxpbmVCcmVha3MoX3RoaXMuY2xhc3NpZmllciwgcmVxdWVzdHNbaV0sIGluamVjdGVkVGV4dCwgdGFiU2l6ZSwgd3JhcHBpbmdDb2x1bW4sIGNvbHVtbnNGb3JGdWxsV2lkdGhDaGFyLCB3cmFwcGluZ0luZGVudCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGFyclBvb2wxLmxlbmd0aCA9IDA7CiAgICAgICAgICBhcnJQb29sMi5sZW5ndGggPSAwOwogICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CiAgICAgIH07CiAgICB9CiAgfV0sIFt7CiAgICBrZXk6ICJjcmVhdGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7CiAgICAgIHJldHVybiBuZXcgTW9ub3NwYWNlTGluZUJyZWFrc0NvbXB1dGVyRmFjdG9yeShvcHRpb25zLmdldCgxMjIgLyogRWRpdG9yT3B0aW9uLndvcmRXcmFwQnJlYWtCZWZvcmVDaGFyYWN0ZXJzICovKSwgb3B0aW9ucy5nZXQoMTIxIC8qIEVkaXRvck9wdGlvbi53b3JkV3JhcEJyZWFrQWZ0ZXJDaGFyYWN0ZXJzICovKSk7CiAgICB9CiAgfV0pOwogIHJldHVybiBNb25vc3BhY2VMaW5lQnJlYWtzQ29tcHV0ZXJGYWN0b3J5Owp9KCk7CnZhciBXcmFwcGluZ0NoYXJhY3RlckNsYXNzaWZpZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DaGFyYWN0ZXJDbGFzc2lmaWVyKSB7CiAgX2luaGVyaXRzKFdyYXBwaW5nQ2hhcmFjdGVyQ2xhc3NpZmllciwgX0NoYXJhY3RlckNsYXNzaWZpZXIpOwogIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoV3JhcHBpbmdDaGFyYWN0ZXJDbGFzc2lmaWVyKTsKICBmdW5jdGlvbiBXcmFwcGluZ0NoYXJhY3RlckNsYXNzaWZpZXIoQlJFQUtfQkVGT1JFLCBCUkVBS19BRlRFUikgewogICAgdmFyIF90aGlzMjsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXcmFwcGluZ0NoYXJhY3RlckNsYXNzaWZpZXIpOwogICAgX3RoaXMyID0gX3N1cGVyLmNhbGwodGhpcywgMCAvKiBDaGFyYWN0ZXJDbGFzcy5OT05FICovKTsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQlJFQUtfQkVGT1JFLmxlbmd0aDsgaSsrKSB7CiAgICAgIF90aGlzMi5zZXQoQlJFQUtfQkVGT1JFLmNoYXJDb2RlQXQoaSksIDEgLyogQ2hhcmFjdGVyQ2xhc3MuQlJFQUtfQkVGT1JFICovKTsKICAgIH0KCiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgQlJFQUtfQUZURVIubGVuZ3RoOyBfaSsrKSB7CiAgICAgIF90aGlzMi5zZXQoQlJFQUtfQUZURVIuY2hhckNvZGVBdChfaSksIDIgLyogQ2hhcmFjdGVyQ2xhc3MuQlJFQUtfQUZURVIgKi8pOwogICAgfQogICAgcmV0dXJuIF90aGlzMjsKICB9CiAgX2NyZWF0ZUNsYXNzKFdyYXBwaW5nQ2hhcmFjdGVyQ2xhc3NpZmllciwgW3sKICAgIGtleTogImdldCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGNoYXJDb2RlKSB7CiAgICAgIGlmIChjaGFyQ29kZSA+PSAwICYmIGNoYXJDb2RlIDwgMjU2KSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2FzY2lpTWFwW2NoYXJDb2RlXTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBJbml0aWFsaXplIENoYXJhY3RlckNsYXNzLkJSRUFLX0lERU9HUkFQSElDIGZvciB0aGVzZSBVbmljb2RlIHJhbmdlczoKICAgICAgICAvLyAxLiBDSksgVW5pZmllZCBJZGVvZ3JhcGhzICgweDRFMDAgLS0gMHg5RkZGKQogICAgICAgIC8vIDIuIENKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEEgKDB4MzQwMCAtLSAweDREQkYpCiAgICAgICAgLy8gMy4gSGlyYWdhbmEgYW5kIEthdGFrYW5hICgweDMwNDAgLS0gMHgzMEZGKQogICAgICAgIGlmIChjaGFyQ29kZSA+PSAweDMwNDAgJiYgY2hhckNvZGUgPD0gMHgzMEZGIHx8IGNoYXJDb2RlID49IDB4MzQwMCAmJiBjaGFyQ29kZSA8PSAweDREQkYgfHwgY2hhckNvZGUgPj0gMHg0RTAwICYmIGNoYXJDb2RlIDw9IDB4OUZGRikgewogICAgICAgICAgcmV0dXJuIDMgLyogQ2hhcmFjdGVyQ2xhc3MuQlJFQUtfSURFT0dSQVBISUMgKi87CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmdldChjaGFyQ29kZSkgfHwgdGhpcy5fZGVmYXVsdFZhbHVlOwogICAgICB9CiAgICB9CiAgfV0pOwogIHJldHVybiBXcmFwcGluZ0NoYXJhY3RlckNsYXNzaWZpZXI7Cn0oQ2hhcmFjdGVyQ2xhc3NpZmllcik7CnZhciBhcnJQb29sMSA9IFtdOwp2YXIgYXJyUG9vbDIgPSBbXTsKZnVuY3Rpb24gY3JlYXRlTGluZUJyZWFrc0Zyb21QcmV2aW91c0xpbmVCcmVha3MoY2xhc3NpZmllciwgcHJldmlvdXNCcmVha2luZ0RhdGEsIGxpbmVUZXh0LCB0YWJTaXplLCBmaXJzdExpbmVCcmVha0NvbHVtbiwgY29sdW1uc0ZvckZ1bGxXaWR0aENoYXIsIHdyYXBwaW5nSW5kZW50KSB7CiAgaWYgKGZpcnN0TGluZUJyZWFrQ29sdW1uID09PSAtMSkgewogICAgcmV0dXJuIG51bGw7CiAgfQogIHZhciBsZW4gPSBsaW5lVGV4dC5sZW5ndGg7CiAgaWYgKGxlbiA8PSAxKSB7CiAgICByZXR1cm4gbnVsbDsKICB9CiAgdmFyIHByZXZCcmVha2luZ09mZnNldHMgPSBwcmV2aW91c0JyZWFraW5nRGF0YS5icmVha09mZnNldHM7CiAgdmFyIHByZXZCcmVha2luZ09mZnNldHNWaXNpYmxlQ29sdW1uID0gcHJldmlvdXNCcmVha2luZ0RhdGEuYnJlYWtPZmZzZXRzVmlzaWJsZUNvbHVtbjsKICB2YXIgd3JhcHBlZFRleHRJbmRlbnRMZW5ndGggPSBjb21wdXRlV3JhcHBlZFRleHRJbmRlbnRMZW5ndGgobGluZVRleHQsIHRhYlNpemUsIGZpcnN0TGluZUJyZWFrQ29sdW1uLCBjb2x1bW5zRm9yRnVsbFdpZHRoQ2hhciwgd3JhcHBpbmdJbmRlbnQpOwogIHZhciB3cmFwcGVkTGluZUJyZWFrQ29sdW1uID0gZmlyc3RMaW5lQnJlYWtDb2x1bW4gLSB3cmFwcGVkVGV4dEluZGVudExlbmd0aDsKICB2YXIgYnJlYWtpbmdPZmZzZXRzID0gYXJyUG9vbDE7CiAgdmFyIGJyZWFraW5nT2Zmc2V0c1Zpc2libGVDb2x1bW4gPSBhcnJQb29sMjsKICB2YXIgYnJlYWtpbmdPZmZzZXRzQ291bnQgPSAwOwogIHZhciBsYXN0QnJlYWtpbmdPZmZzZXQgPSAwOwogIHZhciBsYXN0QnJlYWtpbmdPZmZzZXRWaXNpYmxlQ29sdW1uID0gMDsKICB2YXIgYnJlYWtpbmdDb2x1bW4gPSBmaXJzdExpbmVCcmVha0NvbHVtbjsKICB2YXIgcHJldkxlbiA9IHByZXZCcmVha2luZ09mZnNldHMubGVuZ3RoOwogIHZhciBwcmV2SW5kZXggPSAwOwogIGlmIChwcmV2SW5kZXggPj0gMCkgewogICAgdmFyIGJlc3REaXN0YW5jZSA9IE1hdGguYWJzKHByZXZCcmVha2luZ09mZnNldHNWaXNpYmxlQ29sdW1uW3ByZXZJbmRleF0gLSBicmVha2luZ0NvbHVtbik7CiAgICB3aGlsZSAocHJldkluZGV4ICsgMSA8IHByZXZMZW4pIHsKICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5hYnMocHJldkJyZWFraW5nT2Zmc2V0c1Zpc2libGVDb2x1bW5bcHJldkluZGV4ICsgMV0gLSBicmVha2luZ0NvbHVtbik7CiAgICAgIGlmIChkaXN0YW5jZSA+PSBiZXN0RGlzdGFuY2UpIHsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBiZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTsKICAgICAgcHJldkluZGV4Kys7CiAgICB9CiAgfQogIHdoaWxlIChwcmV2SW5kZXggPCBwcmV2TGVuKSB7CiAgICAvLyBBbGxvdyBmb3IgcHJldkluZGV4IHRvIGJlIC0xIChmb3IgdGhlIGNhc2Ugd2hlcmUgd2UgaGl0IGEgdGFiIHdoZW4gd2Fsa2luZyBiYWNrd2FyZHMgZnJvbSB0aGUgZmlyc3QgYnJlYWspCiAgICB2YXIgcHJldkJyZWFrT2Zmc2V0ID0gcHJldkluZGV4IDwgMCA/IDAgOiBwcmV2QnJlYWtpbmdPZmZzZXRzW3ByZXZJbmRleF07CiAgICB2YXIgcHJldkJyZWFrT2Zmc2V0VmlzaWJsZUNvbHVtbiA9IHByZXZJbmRleCA8IDAgPyAwIDogcHJldkJyZWFraW5nT2Zmc2V0c1Zpc2libGVDb2x1bW5bcHJldkluZGV4XTsKICAgIGlmIChsYXN0QnJlYWtpbmdPZmZzZXQgPiBwcmV2QnJlYWtPZmZzZXQpIHsKICAgICAgcHJldkJyZWFrT2Zmc2V0ID0gbGFzdEJyZWFraW5nT2Zmc2V0OwogICAgICBwcmV2QnJlYWtPZmZzZXRWaXNpYmxlQ29sdW1uID0gbGFzdEJyZWFraW5nT2Zmc2V0VmlzaWJsZUNvbHVtbjsKICAgIH0KICAgIHZhciBicmVha09mZnNldCA9IDA7CiAgICB2YXIgYnJlYWtPZmZzZXRWaXNpYmxlQ29sdW1uID0gMDsKICAgIHZhciBmb3JjZWRCcmVha09mZnNldCA9IDA7CiAgICB2YXIgZm9yY2VkQnJlYWtPZmZzZXRWaXNpYmxlQ29sdW1uID0gMDsKICAgIC8vIGluaXRpYWxseSwgd2Ugc2VhcmNoIGFzIG11Y2ggYXMgcG9zc2libGUgdG8gdGhlIHJpZ2h0IChpZiBpdCBmaXRzKQogICAgaWYgKHByZXZCcmVha09mZnNldFZpc2libGVDb2x1bW4gPD0gYnJlYWtpbmdDb2x1bW4pIHsKICAgICAgdmFyIHZpc2libGVDb2x1bW4gPSBwcmV2QnJlYWtPZmZzZXRWaXNpYmxlQ29sdW1uOwogICAgICB2YXIgcHJldkNoYXJDb2RlID0gcHJldkJyZWFrT2Zmc2V0ID09PSAwID8gMCAvKiBDaGFyQ29kZS5OdWxsICovIDogbGluZVRleHQuY2hhckNvZGVBdChwcmV2QnJlYWtPZmZzZXQgLSAxKTsKICAgICAgdmFyIHByZXZDaGFyQ29kZUNsYXNzID0gcHJldkJyZWFrT2Zmc2V0ID09PSAwID8gMCAvKiBDaGFyYWN0ZXJDbGFzcy5OT05FICovIDogY2xhc3NpZmllci5nZXQocHJldkNoYXJDb2RlKTsKICAgICAgdmFyIGVudGlyZUxpbmVGaXRzID0gdHJ1ZTsKICAgICAgZm9yICh2YXIgaSA9IHByZXZCcmVha09mZnNldDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgdmFyIGNoYXJTdGFydE9mZnNldCA9IGk7CiAgICAgICAgdmFyIGNoYXJDb2RlID0gbGluZVRleHQuY2hhckNvZGVBdChpKTsKICAgICAgICB2YXIgY2hhckNvZGVDbGFzcyA9IHZvaWQgMDsKICAgICAgICB2YXIgY2hhcldpZHRoID0gdm9pZCAwOwogICAgICAgIGlmIChzdHJpbmdzLmlzSGlnaFN1cnJvZ2F0ZShjaGFyQ29kZSkpIHsKICAgICAgICAgIC8vIEEgc3Vycm9nYXRlIHBhaXIgbXVzdCBhbHdheXMgYmUgY29uc2lkZXJlZCBhcyBhIHNpbmdsZSB1bml0LCBzbyBpdCBpcyBuZXZlciB0byBiZSBicm9rZW4KICAgICAgICAgIGkrKzsKICAgICAgICAgIGNoYXJDb2RlQ2xhc3MgPSAwIC8qIENoYXJhY3RlckNsYXNzLk5PTkUgKi87CiAgICAgICAgICBjaGFyV2lkdGggPSAyOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjaGFyQ29kZUNsYXNzID0gY2xhc3NpZmllci5nZXQoY2hhckNvZGUpOwogICAgICAgICAgY2hhcldpZHRoID0gY29tcHV0ZUNoYXJXaWR0aChjaGFyQ29kZSwgdmlzaWJsZUNvbHVtbiwgdGFiU2l6ZSwgY29sdW1uc0ZvckZ1bGxXaWR0aENoYXIpOwogICAgICAgIH0KICAgICAgICBpZiAoY2hhclN0YXJ0T2Zmc2V0ID4gbGFzdEJyZWFraW5nT2Zmc2V0ICYmIGNhbkJyZWFrKHByZXZDaGFyQ29kZSwgcHJldkNoYXJDb2RlQ2xhc3MsIGNoYXJDb2RlLCBjaGFyQ29kZUNsYXNzKSkgewogICAgICAgICAgYnJlYWtPZmZzZXQgPSBjaGFyU3RhcnRPZmZzZXQ7CiAgICAgICAgICBicmVha09mZnNldFZpc2libGVDb2x1bW4gPSB2aXNpYmxlQ29sdW1uOwogICAgICAgIH0KICAgICAgICB2aXNpYmxlQ29sdW1uICs9IGNoYXJXaWR0aDsKICAgICAgICAvLyBjaGVjayBpZiBhZGRpbmcgY2hhcmFjdGVyIGF0IGBpYCB3aWxsIGdvIG92ZXIgdGhlIGJyZWFraW5nIGNvbHVtbgogICAgICAgIGlmICh2aXNpYmxlQ29sdW1uID4gYnJlYWtpbmdDb2x1bW4pIHsKICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYnJlYWsgYXQgbGVhc3QgYmVmb3JlIGNoYXJhY3RlciBhdCBgaWA6CiAgICAgICAgICBpZiAoY2hhclN0YXJ0T2Zmc2V0ID4gbGFzdEJyZWFraW5nT2Zmc2V0KSB7CiAgICAgICAgICAgIGZvcmNlZEJyZWFrT2Zmc2V0ID0gY2hhclN0YXJ0T2Zmc2V0OwogICAgICAgICAgICBmb3JjZWRCcmVha09mZnNldFZpc2libGVDb2x1bW4gPSB2aXNpYmxlQ29sdW1uIC0gY2hhcldpZHRoOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBhZHZhbmNlIGF0IGxlYXN0IGJ5IG9uZSBjaGFyYWN0ZXIKICAgICAgICAgICAgZm9yY2VkQnJlYWtPZmZzZXQgPSBpICsgMTsKICAgICAgICAgICAgZm9yY2VkQnJlYWtPZmZzZXRWaXNpYmxlQ29sdW1uID0gdmlzaWJsZUNvbHVtbjsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh2aXNpYmxlQ29sdW1uIC0gYnJlYWtPZmZzZXRWaXNpYmxlQ29sdW1uID4gd3JhcHBlZExpbmVCcmVha0NvbHVtbikgewogICAgICAgICAgICAvLyBDYW5ub3QgYnJlYWsgYXQgYGJyZWFrT2Zmc2V0YCA9PiByZXNldCBpdCBpZiBpdCB3YXMgc2V0CiAgICAgICAgICAgIGJyZWFrT2Zmc2V0ID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIGVudGlyZUxpbmVGaXRzID0gZmFsc2U7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgcHJldkNoYXJDb2RlID0gY2hhckNvZGU7CiAgICAgICAgcHJldkNoYXJDb2RlQ2xhc3MgPSBjaGFyQ29kZUNsYXNzOwogICAgICB9CiAgICAgIGlmIChlbnRpcmVMaW5lRml0cykgewogICAgICAgIC8vIHRoZXJlIGlzIG5vIG1vcmUgbmVlZCB0byBicmVhayA9PiBzdG9wIHRoZSBvdXRlciBsb29wIQogICAgICAgIGlmIChicmVha2luZ09mZnNldHNDb3VudCA+IDApIHsKICAgICAgICAgIC8vIEFkZCBsYXN0IHNlZ21lbnQsIG5vIG5lZWQgdG8gYXNzaWduIHRvIGBsYXN0QnJlYWtpbmdPZmZzZXRgIGFuZCBgbGFzdEJyZWFraW5nT2Zmc2V0VmlzaWJsZUNvbHVtbmAKICAgICAgICAgIGJyZWFraW5nT2Zmc2V0c1ticmVha2luZ09mZnNldHNDb3VudF0gPSBwcmV2QnJlYWtpbmdPZmZzZXRzW3ByZXZCcmVha2luZ09mZnNldHMubGVuZ3RoIC0gMV07CiAgICAgICAgICBicmVha2luZ09mZnNldHNWaXNpYmxlQ29sdW1uW2JyZWFraW5nT2Zmc2V0c0NvdW50XSA9IHByZXZCcmVha2luZ09mZnNldHNWaXNpYmxlQ29sdW1uW3ByZXZCcmVha2luZ09mZnNldHMubGVuZ3RoIC0gMV07CiAgICAgICAgICBicmVha2luZ09mZnNldHNDb3VudCsrOwogICAgICAgIH0KICAgICAgICBicmVhazsKICAgICAgfQogICAgfQogICAgaWYgKGJyZWFrT2Zmc2V0ID09PSAwKSB7CiAgICAgIC8vIG11c3Qgc2VhcmNoIGxlZnQKICAgICAgdmFyIF92aXNpYmxlQ29sdW1uID0gcHJldkJyZWFrT2Zmc2V0VmlzaWJsZUNvbHVtbjsKICAgICAgdmFyIF9jaGFyQ29kZSA9IGxpbmVUZXh0LmNoYXJDb2RlQXQocHJldkJyZWFrT2Zmc2V0KTsKICAgICAgdmFyIF9jaGFyQ29kZUNsYXNzID0gY2xhc3NpZmllci5nZXQoX2NoYXJDb2RlKTsKICAgICAgdmFyIGhpdEFUYWJDaGFyYWN0ZXIgPSBmYWxzZTsKICAgICAgZm9yICh2YXIgX2kyID0gcHJldkJyZWFrT2Zmc2V0IC0gMTsgX2kyID49IGxhc3RCcmVha2luZ09mZnNldDsgX2kyLS0pIHsKICAgICAgICB2YXIgX2NoYXJTdGFydE9mZnNldCA9IF9pMiArIDE7CiAgICAgICAgdmFyIF9wcmV2Q2hhckNvZGUgPSBsaW5lVGV4dC5jaGFyQ29kZUF0KF9pMik7CiAgICAgICAgaWYgKF9wcmV2Q2hhckNvZGUgPT09IDkgLyogQ2hhckNvZGUuVGFiICovKSB7CiAgICAgICAgICAvLyBjYW5ub3QgZGV0ZXJtaW5lIHRoZSB3aWR0aCBvZiBhIHRhYiB3aGVuIGdvaW5nIGJhY2t3YXJkcywgc28gd2UgbXVzdCBnbyBmb3J3YXJkcwogICAgICAgICAgaGl0QVRhYkNoYXJhY3RlciA9IHRydWU7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgdmFyIF9wcmV2Q2hhckNvZGVDbGFzcyA9IHZvaWQgMDsKICAgICAgICB2YXIgcHJldkNoYXJXaWR0aCA9IHZvaWQgMDsKICAgICAgICBpZiAoc3RyaW5ncy5pc0xvd1N1cnJvZ2F0ZShfcHJldkNoYXJDb2RlKSkgewogICAgICAgICAgLy8gQSBzdXJyb2dhdGUgcGFpciBtdXN0IGFsd2F5cyBiZSBjb25zaWRlcmVkIGFzIGEgc2luZ2xlIHVuaXQsIHNvIGl0IGlzIG5ldmVyIHRvIGJlIGJyb2tlbgogICAgICAgICAgX2kyLS07CiAgICAgICAgICBfcHJldkNoYXJDb2RlQ2xhc3MgPSAwIC8qIENoYXJhY3RlckNsYXNzLk5PTkUgKi87CiAgICAgICAgICBwcmV2Q2hhcldpZHRoID0gMjsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgX3ByZXZDaGFyQ29kZUNsYXNzID0gY2xhc3NpZmllci5nZXQoX3ByZXZDaGFyQ29kZSk7CiAgICAgICAgICBwcmV2Q2hhcldpZHRoID0gc3RyaW5ncy5pc0Z1bGxXaWR0aENoYXJhY3RlcihfcHJldkNoYXJDb2RlKSA/IGNvbHVtbnNGb3JGdWxsV2lkdGhDaGFyIDogMTsKICAgICAgICB9CiAgICAgICAgaWYgKF92aXNpYmxlQ29sdW1uIDw9IGJyZWFraW5nQ29sdW1uKSB7CiAgICAgICAgICBpZiAoZm9yY2VkQnJlYWtPZmZzZXQgPT09IDApIHsKICAgICAgICAgICAgZm9yY2VkQnJlYWtPZmZzZXQgPSBfY2hhclN0YXJ0T2Zmc2V0OwogICAgICAgICAgICBmb3JjZWRCcmVha09mZnNldFZpc2libGVDb2x1bW4gPSBfdmlzaWJsZUNvbHVtbjsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChfdmlzaWJsZUNvbHVtbiA8PSBicmVha2luZ0NvbHVtbiAtIHdyYXBwZWRMaW5lQnJlYWtDb2x1bW4pIHsKICAgICAgICAgICAgLy8gd2VudCB0b28gZmFyIQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChjYW5CcmVhayhfcHJldkNoYXJDb2RlLCBfcHJldkNoYXJDb2RlQ2xhc3MsIF9jaGFyQ29kZSwgX2NoYXJDb2RlQ2xhc3MpKSB7CiAgICAgICAgICAgIGJyZWFrT2Zmc2V0ID0gX2NoYXJTdGFydE9mZnNldDsKICAgICAgICAgICAgYnJlYWtPZmZzZXRWaXNpYmxlQ29sdW1uID0gX3Zpc2libGVDb2x1bW47CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBfdmlzaWJsZUNvbHVtbiAtPSBwcmV2Q2hhcldpZHRoOwogICAgICAgIF9jaGFyQ29kZSA9IF9wcmV2Q2hhckNvZGU7CiAgICAgICAgX2NoYXJDb2RlQ2xhc3MgPSBfcHJldkNoYXJDb2RlQ2xhc3M7CiAgICAgIH0KICAgICAgaWYgKGJyZWFrT2Zmc2V0ICE9PSAwKSB7CiAgICAgICAgdmFyIHJlbWFpbmluZ1dpZHRoT2ZOZXh0TGluZSA9IHdyYXBwZWRMaW5lQnJlYWtDb2x1bW4gLSAoZm9yY2VkQnJlYWtPZmZzZXRWaXNpYmxlQ29sdW1uIC0gYnJlYWtPZmZzZXRWaXNpYmxlQ29sdW1uKTsKICAgICAgICBpZiAocmVtYWluaW5nV2lkdGhPZk5leHRMaW5lIDw9IHRhYlNpemUpIHsKICAgICAgICAgIHZhciBjaGFyQ29kZUF0Rm9yY2VkQnJlYWtPZmZzZXQgPSBsaW5lVGV4dC5jaGFyQ29kZUF0KGZvcmNlZEJyZWFrT2Zmc2V0KTsKICAgICAgICAgIHZhciBfY2hhcldpZHRoID0gdm9pZCAwOwogICAgICAgICAgaWYgKHN0cmluZ3MuaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlQXRGb3JjZWRCcmVha09mZnNldCkpIHsKICAgICAgICAgICAgLy8gQSBzdXJyb2dhdGUgcGFpciBtdXN0IGFsd2F5cyBiZSBjb25zaWRlcmVkIGFzIGEgc2luZ2xlIHVuaXQsIHNvIGl0IGlzIG5ldmVyIHRvIGJlIGJyb2tlbgogICAgICAgICAgICBfY2hhcldpZHRoID0gMjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIF9jaGFyV2lkdGggPSBjb21wdXRlQ2hhcldpZHRoKGNoYXJDb2RlQXRGb3JjZWRCcmVha09mZnNldCwgZm9yY2VkQnJlYWtPZmZzZXRWaXNpYmxlQ29sdW1uLCB0YWJTaXplLCBjb2x1bW5zRm9yRnVsbFdpZHRoQ2hhcik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocmVtYWluaW5nV2lkdGhPZk5leHRMaW5lIC0gX2NoYXJXaWR0aCA8IDApIHsKICAgICAgICAgICAgLy8gaXQgaXMgbm90IHdvcnRoIGl0IHRvIGJyZWFrIGF0IGJyZWFrT2Zmc2V0LCBpdCBqdXN0IGludHJvZHVjZXMgYW4gZXh0cmEgbmVlZGxlc3MgbGluZSEKICAgICAgICAgICAgYnJlYWtPZmZzZXQgPSAwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBpZiAoaGl0QVRhYkNoYXJhY3RlcikgewogICAgICAgIC8vIGNhbm5vdCBkZXRlcm1pbmUgdGhlIHdpZHRoIG9mIGEgdGFiIHdoZW4gZ29pbmcgYmFja3dhcmRzLCBzbyB3ZSBtdXN0IGdvIGZvcndhcmRzIGZyb20gdGhlIHByZXZpb3VzIGJyZWFrCiAgICAgICAgcHJldkluZGV4LS07CiAgICAgICAgY29udGludWU7CiAgICAgIH0KICAgIH0KICAgIGlmIChicmVha09mZnNldCA9PT0gMCkgewogICAgICAvLyBDb3VsZCBub3QgZmluZCBhIGdvb2QgYnJlYWtpbmcgcG9pbnQKICAgICAgYnJlYWtPZmZzZXQgPSBmb3JjZWRCcmVha09mZnNldDsKICAgICAgYnJlYWtPZmZzZXRWaXNpYmxlQ29sdW1uID0gZm9yY2VkQnJlYWtPZmZzZXRWaXNpYmxlQ29sdW1uOwogICAgfQogICAgaWYgKGJyZWFrT2Zmc2V0IDw9IGxhc3RCcmVha2luZ09mZnNldCkgewogICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBhcmUgYWR2YW5jaW5nIChhdCBsZWFzdCBvbmUgY2hhcmFjdGVyKQogICAgICB2YXIgX2NoYXJDb2RlMiA9IGxpbmVUZXh0LmNoYXJDb2RlQXQobGFzdEJyZWFraW5nT2Zmc2V0KTsKICAgICAgaWYgKHN0cmluZ3MuaXNIaWdoU3Vycm9nYXRlKF9jaGFyQ29kZTIpKSB7CiAgICAgICAgLy8gQSBzdXJyb2dhdGUgcGFpciBtdXN0IGFsd2F5cyBiZSBjb25zaWRlcmVkIGFzIGEgc2luZ2xlIHVuaXQsIHNvIGl0IGlzIG5ldmVyIHRvIGJlIGJyb2tlbgogICAgICAgIGJyZWFrT2Zmc2V0ID0gbGFzdEJyZWFraW5nT2Zmc2V0ICsgMjsKICAgICAgICBicmVha09mZnNldFZpc2libGVDb2x1bW4gPSBsYXN0QnJlYWtpbmdPZmZzZXRWaXNpYmxlQ29sdW1uICsgMjsKICAgICAgfSBlbHNlIHsKICAgICAgICBicmVha09mZnNldCA9IGxhc3RCcmVha2luZ09mZnNldCArIDE7CiAgICAgICAgYnJlYWtPZmZzZXRWaXNpYmxlQ29sdW1uID0gbGFzdEJyZWFraW5nT2Zmc2V0VmlzaWJsZUNvbHVtbiArIGNvbXB1dGVDaGFyV2lkdGgoX2NoYXJDb2RlMiwgbGFzdEJyZWFraW5nT2Zmc2V0VmlzaWJsZUNvbHVtbiwgdGFiU2l6ZSwgY29sdW1uc0ZvckZ1bGxXaWR0aENoYXIpOwogICAgICB9CiAgICB9CiAgICBsYXN0QnJlYWtpbmdPZmZzZXQgPSBicmVha09mZnNldDsKICAgIGJyZWFraW5nT2Zmc2V0c1ticmVha2luZ09mZnNldHNDb3VudF0gPSBicmVha09mZnNldDsKICAgIGxhc3RCcmVha2luZ09mZnNldFZpc2libGVDb2x1bW4gPSBicmVha09mZnNldFZpc2libGVDb2x1bW47CiAgICBicmVha2luZ09mZnNldHNWaXNpYmxlQ29sdW1uW2JyZWFraW5nT2Zmc2V0c0NvdW50XSA9IGJyZWFrT2Zmc2V0VmlzaWJsZUNvbHVtbjsKICAgIGJyZWFraW5nT2Zmc2V0c0NvdW50Kys7CiAgICBicmVha2luZ0NvbHVtbiA9IGJyZWFrT2Zmc2V0VmlzaWJsZUNvbHVtbiArIHdyYXBwZWRMaW5lQnJlYWtDb2x1bW47CiAgICB3aGlsZSAocHJldkluZGV4IDwgMCB8fCBwcmV2SW5kZXggPCBwcmV2TGVuICYmIHByZXZCcmVha2luZ09mZnNldHNWaXNpYmxlQ29sdW1uW3ByZXZJbmRleF0gPCBicmVha09mZnNldFZpc2libGVDb2x1bW4pIHsKICAgICAgcHJldkluZGV4Kys7CiAgICB9CiAgICB2YXIgX2Jlc3REaXN0YW5jZSA9IE1hdGguYWJzKHByZXZCcmVha2luZ09mZnNldHNWaXNpYmxlQ29sdW1uW3ByZXZJbmRleF0gLSBicmVha2luZ0NvbHVtbik7CiAgICB3aGlsZSAocHJldkluZGV4ICsgMSA8IHByZXZMZW4pIHsKICAgICAgdmFyIF9kaXN0YW5jZSA9IE1hdGguYWJzKHByZXZCcmVha2luZ09mZnNldHNWaXNpYmxlQ29sdW1uW3ByZXZJbmRleCArIDFdIC0gYnJlYWtpbmdDb2x1bW4pOwogICAgICBpZiAoX2Rpc3RhbmNlID49IF9iZXN0RGlzdGFuY2UpIHsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBfYmVzdERpc3RhbmNlID0gX2Rpc3RhbmNlOwogICAgICBwcmV2SW5kZXgrKzsKICAgIH0KICB9CiAgaWYgKGJyZWFraW5nT2Zmc2V0c0NvdW50ID09PSAwKSB7CiAgICByZXR1cm4gbnVsbDsKICB9CiAgLy8gRG9pbmcgaGVyZSBzb21lIG9iamVjdCByZXVzZSB3aGljaCBlbmRzIHVwIGhlbHBpbmcgYSBodWdlIGRlYWwgd2l0aCBHQyBwYXVzZXMhCiAgYnJlYWtpbmdPZmZzZXRzLmxlbmd0aCA9IGJyZWFraW5nT2Zmc2V0c0NvdW50OwogIGJyZWFraW5nT2Zmc2V0c1Zpc2libGVDb2x1bW4ubGVuZ3RoID0gYnJlYWtpbmdPZmZzZXRzQ291bnQ7CiAgYXJyUG9vbDEgPSBwcmV2aW91c0JyZWFraW5nRGF0YS5icmVha09mZnNldHM7CiAgYXJyUG9vbDIgPSBwcmV2aW91c0JyZWFraW5nRGF0YS5icmVha09mZnNldHNWaXNpYmxlQ29sdW1uOwogIHByZXZpb3VzQnJlYWtpbmdEYXRhLmJyZWFrT2Zmc2V0cyA9IGJyZWFraW5nT2Zmc2V0czsKICBwcmV2aW91c0JyZWFraW5nRGF0YS5icmVha09mZnNldHNWaXNpYmxlQ29sdW1uID0gYnJlYWtpbmdPZmZzZXRzVmlzaWJsZUNvbHVtbjsKICBwcmV2aW91c0JyZWFraW5nRGF0YS53cmFwcGVkVGV4dEluZGVudExlbmd0aCA9IHdyYXBwZWRUZXh0SW5kZW50TGVuZ3RoOwogIHJldHVybiBwcmV2aW91c0JyZWFraW5nRGF0YTsKfQpmdW5jdGlvbiBjcmVhdGVMaW5lQnJlYWtzKGNsYXNzaWZpZXIsIF9saW5lVGV4dCwgaW5qZWN0ZWRUZXh0cywgdGFiU2l6ZSwgZmlyc3RMaW5lQnJlYWtDb2x1bW4sIGNvbHVtbnNGb3JGdWxsV2lkdGhDaGFyLCB3cmFwcGluZ0luZGVudCkgewogIHZhciBsaW5lVGV4dCA9IExpbmVJbmplY3RlZFRleHQuYXBwbHlJbmplY3RlZFRleHQoX2xpbmVUZXh0LCBpbmplY3RlZFRleHRzKTsKICB2YXIgaW5qZWN0aW9uT3B0aW9uczsKICB2YXIgaW5qZWN0aW9uT2Zmc2V0czsKICBpZiAoaW5qZWN0ZWRUZXh0cyAmJiBpbmplY3RlZFRleHRzLmxlbmd0aCA+IDApIHsKICAgIGluamVjdGlvbk9wdGlvbnMgPSBpbmplY3RlZFRleHRzLm1hcChmdW5jdGlvbiAodCkgewogICAgICByZXR1cm4gdC5vcHRpb25zOwogICAgfSk7CiAgICBpbmplY3Rpb25PZmZzZXRzID0gaW5qZWN0ZWRUZXh0cy5tYXAoZnVuY3Rpb24gKHRleHQpIHsKICAgICAgcmV0dXJuIHRleHQuY29sdW1uIC0gMTsKICAgIH0pOwogIH0gZWxzZSB7CiAgICBpbmplY3Rpb25PcHRpb25zID0gbnVsbDsKICAgIGluamVjdGlvbk9mZnNldHMgPSBudWxsOwogIH0KICBpZiAoZmlyc3RMaW5lQnJlYWtDb2x1bW4gPT09IC0xKSB7CiAgICBpZiAoIWluamVjdGlvbk9wdGlvbnMpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvLyBjcmVhdGluZyBhIGBMaW5lQnJlYWtEYXRhYCB3aXRoIGFuIGludmFsaWQgYGJyZWFrT2Zmc2V0c1Zpc2libGVDb2x1bW5gIGlzIE9LCiAgICAvLyBiZWNhdXNlIGBicmVha09mZnNldHNWaXNpYmxlQ29sdW1uYCB3aWxsIG5ldmVyIGJlIHVzZWQgYmVjYXVzZSBpdCBjb250YWlucyBpbmplY3RlZCB0ZXh0CiAgICByZXR1cm4gbmV3IE1vZGVsTGluZVByb2plY3Rpb25EYXRhKGluamVjdGlvbk9mZnNldHMsIGluamVjdGlvbk9wdGlvbnMsIFtsaW5lVGV4dC5sZW5ndGhdLCBbXSwgMCk7CiAgfQogIHZhciBsZW4gPSBsaW5lVGV4dC5sZW5ndGg7CiAgaWYgKGxlbiA8PSAxKSB7CiAgICBpZiAoIWluamVjdGlvbk9wdGlvbnMpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvLyBjcmVhdGluZyBhIGBMaW5lQnJlYWtEYXRhYCB3aXRoIGFuIGludmFsaWQgYGJyZWFrT2Zmc2V0c1Zpc2libGVDb2x1bW5gIGlzIE9LCiAgICAvLyBiZWNhdXNlIGBicmVha09mZnNldHNWaXNpYmxlQ29sdW1uYCB3aWxsIG5ldmVyIGJlIHVzZWQgYmVjYXVzZSBpdCBjb250YWlucyBpbmplY3RlZCB0ZXh0CiAgICByZXR1cm4gbmV3IE1vZGVsTGluZVByb2plY3Rpb25EYXRhKGluamVjdGlvbk9mZnNldHMsIGluamVjdGlvbk9wdGlvbnMsIFtsaW5lVGV4dC5sZW5ndGhdLCBbXSwgMCk7CiAgfQogIHZhciB3cmFwcGVkVGV4dEluZGVudExlbmd0aCA9IGNvbXB1dGVXcmFwcGVkVGV4dEluZGVudExlbmd0aChsaW5lVGV4dCwgdGFiU2l6ZSwgZmlyc3RMaW5lQnJlYWtDb2x1bW4sIGNvbHVtbnNGb3JGdWxsV2lkdGhDaGFyLCB3cmFwcGluZ0luZGVudCk7CiAgdmFyIHdyYXBwZWRMaW5lQnJlYWtDb2x1bW4gPSBmaXJzdExpbmVCcmVha0NvbHVtbiAtIHdyYXBwZWRUZXh0SW5kZW50TGVuZ3RoOwogIHZhciBicmVha2luZ09mZnNldHMgPSBbXTsKICB2YXIgYnJlYWtpbmdPZmZzZXRzVmlzaWJsZUNvbHVtbiA9IFtdOwogIHZhciBicmVha2luZ09mZnNldHNDb3VudCA9IDA7CiAgdmFyIGJyZWFrT2Zmc2V0ID0gMDsKICB2YXIgYnJlYWtPZmZzZXRWaXNpYmxlQ29sdW1uID0gMDsKICB2YXIgYnJlYWtpbmdDb2x1bW4gPSBmaXJzdExpbmVCcmVha0NvbHVtbjsKICB2YXIgcHJldkNoYXJDb2RlID0gbGluZVRleHQuY2hhckNvZGVBdCgwKTsKICB2YXIgcHJldkNoYXJDb2RlQ2xhc3MgPSBjbGFzc2lmaWVyLmdldChwcmV2Q2hhckNvZGUpOwogIHZhciB2aXNpYmxlQ29sdW1uID0gY29tcHV0ZUNoYXJXaWR0aChwcmV2Q2hhckNvZGUsIDAsIHRhYlNpemUsIGNvbHVtbnNGb3JGdWxsV2lkdGhDaGFyKTsKICB2YXIgc3RhcnRPZmZzZXQgPSAxOwogIGlmIChzdHJpbmdzLmlzSGlnaFN1cnJvZ2F0ZShwcmV2Q2hhckNvZGUpKSB7CiAgICAvLyBBIHN1cnJvZ2F0ZSBwYWlyIG11c3QgYWx3YXlzIGJlIGNvbnNpZGVyZWQgYXMgYSBzaW5nbGUgdW5pdCwgc28gaXQgaXMgbmV2ZXIgdG8gYmUgYnJva2VuCiAgICB2aXNpYmxlQ29sdW1uICs9IDE7CiAgICBwcmV2Q2hhckNvZGUgPSBsaW5lVGV4dC5jaGFyQ29kZUF0KDEpOwogICAgcHJldkNoYXJDb2RlQ2xhc3MgPSBjbGFzc2lmaWVyLmdldChwcmV2Q2hhckNvZGUpOwogICAgc3RhcnRPZmZzZXQrKzsKICB9CiAgZm9yICh2YXIgaSA9IHN0YXJ0T2Zmc2V0OyBpIDwgbGVuOyBpKyspIHsKICAgIHZhciBjaGFyU3RhcnRPZmZzZXQgPSBpOwogICAgdmFyIGNoYXJDb2RlID0gbGluZVRleHQuY2hhckNvZGVBdChpKTsKICAgIHZhciBjaGFyQ29kZUNsYXNzID0gdm9pZCAwOwogICAgdmFyIGNoYXJXaWR0aCA9IHZvaWQgMDsKICAgIGlmIChzdHJpbmdzLmlzSGlnaFN1cnJvZ2F0ZShjaGFyQ29kZSkpIHsKICAgICAgLy8gQSBzdXJyb2dhdGUgcGFpciBtdXN0IGFsd2F5cyBiZSBjb25zaWRlcmVkIGFzIGEgc2luZ2xlIHVuaXQsIHNvIGl0IGlzIG5ldmVyIHRvIGJlIGJyb2tlbgogICAgICBpKys7CiAgICAgIGNoYXJDb2RlQ2xhc3MgPSAwIC8qIENoYXJhY3RlckNsYXNzLk5PTkUgKi87CiAgICAgIGNoYXJXaWR0aCA9IDI7CiAgICB9IGVsc2UgewogICAgICBjaGFyQ29kZUNsYXNzID0gY2xhc3NpZmllci5nZXQoY2hhckNvZGUpOwogICAgICBjaGFyV2lkdGggPSBjb21wdXRlQ2hhcldpZHRoKGNoYXJDb2RlLCB2aXNpYmxlQ29sdW1uLCB0YWJTaXplLCBjb2x1bW5zRm9yRnVsbFdpZHRoQ2hhcik7CiAgICB9CiAgICBpZiAoY2FuQnJlYWsocHJldkNoYXJDb2RlLCBwcmV2Q2hhckNvZGVDbGFzcywgY2hhckNvZGUsIGNoYXJDb2RlQ2xhc3MpKSB7CiAgICAgIGJyZWFrT2Zmc2V0ID0gY2hhclN0YXJ0T2Zmc2V0OwogICAgICBicmVha09mZnNldFZpc2libGVDb2x1bW4gPSB2aXNpYmxlQ29sdW1uOwogICAgfQogICAgdmlzaWJsZUNvbHVtbiArPSBjaGFyV2lkdGg7CiAgICAvLyBjaGVjayBpZiBhZGRpbmcgY2hhcmFjdGVyIGF0IGBpYCB3aWxsIGdvIG92ZXIgdGhlIGJyZWFraW5nIGNvbHVtbgogICAgaWYgKHZpc2libGVDb2x1bW4gPiBicmVha2luZ0NvbHVtbikgewogICAgICAvLyBXZSBuZWVkIHRvIGJyZWFrIGF0IGxlYXN0IGJlZm9yZSBjaGFyYWN0ZXIgYXQgYGlgOgogICAgICBpZiAoYnJlYWtPZmZzZXQgPT09IDAgfHwgdmlzaWJsZUNvbHVtbiAtIGJyZWFrT2Zmc2V0VmlzaWJsZUNvbHVtbiA+IHdyYXBwZWRMaW5lQnJlYWtDb2x1bW4pIHsKICAgICAgICAvLyBDYW5ub3QgYnJlYWsgYXQgYGJyZWFrT2Zmc2V0YCwgbXVzdCBicmVhayBhdCBgaWAKICAgICAgICBicmVha09mZnNldCA9IGNoYXJTdGFydE9mZnNldDsKICAgICAgICBicmVha09mZnNldFZpc2libGVDb2x1bW4gPSB2aXNpYmxlQ29sdW1uIC0gY2hhcldpZHRoOwogICAgICB9CiAgICAgIGJyZWFraW5nT2Zmc2V0c1ticmVha2luZ09mZnNldHNDb3VudF0gPSBicmVha09mZnNldDsKICAgICAgYnJlYWtpbmdPZmZzZXRzVmlzaWJsZUNvbHVtblticmVha2luZ09mZnNldHNDb3VudF0gPSBicmVha09mZnNldFZpc2libGVDb2x1bW47CiAgICAgIGJyZWFraW5nT2Zmc2V0c0NvdW50Kys7CiAgICAgIGJyZWFraW5nQ29sdW1uID0gYnJlYWtPZmZzZXRWaXNpYmxlQ29sdW1uICsgd3JhcHBlZExpbmVCcmVha0NvbHVtbjsKICAgICAgYnJlYWtPZmZzZXQgPSAwOwogICAgfQogICAgcHJldkNoYXJDb2RlID0gY2hhckNvZGU7CiAgICBwcmV2Q2hhckNvZGVDbGFzcyA9IGNoYXJDb2RlQ2xhc3M7CiAgfQogIGlmIChicmVha2luZ09mZnNldHNDb3VudCA9PT0gMCAmJiAoIWluamVjdGVkVGV4dHMgfHwgaW5qZWN0ZWRUZXh0cy5sZW5ndGggPT09IDApKSB7CiAgICByZXR1cm4gbnVsbDsKICB9CiAgLy8gQWRkIGxhc3Qgc2VnbWVudAogIGJyZWFraW5nT2Zmc2V0c1ticmVha2luZ09mZnNldHNDb3VudF0gPSBsZW47CiAgYnJlYWtpbmdPZmZzZXRzVmlzaWJsZUNvbHVtblticmVha2luZ09mZnNldHNDb3VudF0gPSB2aXNpYmxlQ29sdW1uOwogIHJldHVybiBuZXcgTW9kZWxMaW5lUHJvamVjdGlvbkRhdGEoaW5qZWN0aW9uT2Zmc2V0cywgaW5qZWN0aW9uT3B0aW9ucywgYnJlYWtpbmdPZmZzZXRzLCBicmVha2luZ09mZnNldHNWaXNpYmxlQ29sdW1uLCB3cmFwcGVkVGV4dEluZGVudExlbmd0aCk7Cn0KZnVuY3Rpb24gY29tcHV0ZUNoYXJXaWR0aChjaGFyQ29kZSwgdmlzaWJsZUNvbHVtbiwgdGFiU2l6ZSwgY29sdW1uc0ZvckZ1bGxXaWR0aENoYXIpIHsKICBpZiAoY2hhckNvZGUgPT09IDkgLyogQ2hhckNvZGUuVGFiICovKSB7CiAgICByZXR1cm4gdGFiU2l6ZSAtIHZpc2libGVDb2x1bW4gJSB0YWJTaXplOwogIH0KICBpZiAoc3RyaW5ncy5pc0Z1bGxXaWR0aENoYXJhY3RlcihjaGFyQ29kZSkpIHsKICAgIHJldHVybiBjb2x1bW5zRm9yRnVsbFdpZHRoQ2hhcjsKICB9CiAgaWYgKGNoYXJDb2RlIDwgMzIpIHsKICAgIC8vIHdoZW4gdXNpbmcgYGVkaXRvci5yZW5kZXJDb250cm9sQ2hhcmFjdGVyc2AsIHRoZSBzdWJzdGl0dXRpb25zIGFyZSBvZnRlbiB3aWRlCiAgICByZXR1cm4gY29sdW1uc0ZvckZ1bGxXaWR0aENoYXI7CiAgfQogIHJldHVybiAxOwp9CmZ1bmN0aW9uIHRhYkNoYXJhY3RlcldpZHRoKHZpc2libGVDb2x1bW4sIHRhYlNpemUpIHsKICByZXR1cm4gdGFiU2l6ZSAtIHZpc2libGVDb2x1bW4gJSB0YWJTaXplOwp9Ci8qKgogKiBLaW5zb2t1IFNob3JpIDogRG9uJ3QgYnJlYWsgYWZ0ZXIgYSBsZWFkaW5nIGNoYXJhY3RlciwgbGlrZSBhbiBvcGVuIGJyYWNrZXQKICogS2luc29rdSBTaG9yaSA6IERvbid0IGJyZWFrIGJlZm9yZSBhIHRyYWlsaW5nIGNoYXJhY3RlciwgbGlrZSBhIHBlcmlvZAogKi8KZnVuY3Rpb24gY2FuQnJlYWsocHJldkNoYXJDb2RlLCBwcmV2Q2hhckNvZGVDbGFzcywgY2hhckNvZGUsIGNoYXJDb2RlQ2xhc3MpIHsKICByZXR1cm4gY2hhckNvZGUgIT09IDMyIC8qIENoYXJDb2RlLlNwYWNlICovICYmIChwcmV2Q2hhckNvZGVDbGFzcyA9PT0gMiAvKiBDaGFyYWN0ZXJDbGFzcy5CUkVBS19BRlRFUiAqLyAmJiBjaGFyQ29kZUNsYXNzICE9PSAyIC8qIENoYXJhY3RlckNsYXNzLkJSRUFLX0FGVEVSICovIC8vIGJyZWFrIGF0IHRoZSBlbmQgb2YgbXVsdGlwbGUgQlJFQUtfQUZURVIKICB8fCBwcmV2Q2hhckNvZGVDbGFzcyAhPT0gMSAvKiBDaGFyYWN0ZXJDbGFzcy5CUkVBS19CRUZPUkUgKi8gJiYgY2hhckNvZGVDbGFzcyA9PT0gMSAvKiBDaGFyYWN0ZXJDbGFzcy5CUkVBS19CRUZPUkUgKi8gLy8gYnJlYWsgYXQgdGhlIHN0YXJ0IG9mIG11bHRpcGxlIEJSRUFLX0JFRk9SRQogIHx8IHByZXZDaGFyQ29kZUNsYXNzID09PSAzIC8qIENoYXJhY3RlckNsYXNzLkJSRUFLX0lERU9HUkFQSElDICovICYmIGNoYXJDb2RlQ2xhc3MgIT09IDIgLyogQ2hhcmFjdGVyQ2xhc3MuQlJFQUtfQUZURVIgKi8gfHwgY2hhckNvZGVDbGFzcyA9PT0gMyAvKiBDaGFyYWN0ZXJDbGFzcy5CUkVBS19JREVPR1JBUEhJQyAqLyAmJiBwcmV2Q2hhckNvZGVDbGFzcyAhPT0gMSAvKiBDaGFyYWN0ZXJDbGFzcy5CUkVBS19CRUZPUkUgKi8pOwp9CgpmdW5jdGlvbiBjb21wdXRlV3JhcHBlZFRleHRJbmRlbnRMZW5ndGgobGluZVRleHQsIHRhYlNpemUsIGZpcnN0TGluZUJyZWFrQ29sdW1uLCBjb2x1bW5zRm9yRnVsbFdpZHRoQ2hhciwgd3JhcHBpbmdJbmRlbnQpIHsKICB2YXIgd3JhcHBlZFRleHRJbmRlbnRMZW5ndGggPSAwOwogIGlmICh3cmFwcGluZ0luZGVudCAhPT0gMCAvKiBXcmFwcGluZ0luZGVudC5Ob25lICovKSB7CiAgICB2YXIgZmlyc3ROb25XaGl0ZXNwYWNlSW5kZXggPSBzdHJpbmdzLmZpcnN0Tm9uV2hpdGVzcGFjZUluZGV4KGxpbmVUZXh0KTsKICAgIGlmIChmaXJzdE5vbldoaXRlc3BhY2VJbmRleCAhPT0gLTEpIHsKICAgICAgLy8gVHJhY2sgZXhpc3RpbmcgaW5kZW50CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlyc3ROb25XaGl0ZXNwYWNlSW5kZXg7IGkrKykgewogICAgICAgIHZhciBjaGFyV2lkdGggPSBsaW5lVGV4dC5jaGFyQ29kZUF0KGkpID09PSA5IC8qIENoYXJDb2RlLlRhYiAqLyA/IHRhYkNoYXJhY3RlcldpZHRoKHdyYXBwZWRUZXh0SW5kZW50TGVuZ3RoLCB0YWJTaXplKSA6IDE7CiAgICAgICAgd3JhcHBlZFRleHRJbmRlbnRMZW5ndGggKz0gY2hhcldpZHRoOwogICAgICB9CiAgICAgIC8vIEluY3JlYXNlIGluZGVudCBvZiBjb250aW51YXRpb24gbGluZXMsIGlmIGRlc2lyZWQKICAgICAgdmFyIG51bWJlck9mQWRkaXRpb25hbFRhYnMgPSB3cmFwcGluZ0luZGVudCA9PT0gMyAvKiBXcmFwcGluZ0luZGVudC5EZWVwSW5kZW50ICovID8gMiA6IHdyYXBwaW5nSW5kZW50ID09PSAyIC8qIFdyYXBwaW5nSW5kZW50LkluZGVudCAqLyA/IDEgOiAwOwogICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBudW1iZXJPZkFkZGl0aW9uYWxUYWJzOyBfaTMrKykgewogICAgICAgIHZhciBfY2hhcldpZHRoMiA9IHRhYkNoYXJhY3RlcldpZHRoKHdyYXBwZWRUZXh0SW5kZW50TGVuZ3RoLCB0YWJTaXplKTsKICAgICAgICB3cmFwcGVkVGV4dEluZGVudExlbmd0aCArPSBfY2hhcldpZHRoMjsKICAgICAgfQogICAgICAvLyBGb3JjZSBzdGlja2luZyB0byBiZWdpbm5pbmcgb2YgbGluZSBpZiBubyBjaGFyYWN0ZXIgd291bGQgZml0IGV4Y2VwdCBmb3IgdGhlIGluZGVudGF0aW9uCiAgICAgIGlmICh3cmFwcGVkVGV4dEluZGVudExlbmd0aCArIGNvbHVtbnNGb3JGdWxsV2lkdGhDaGFyID4gZmlyc3RMaW5lQnJlYWtDb2x1bW4pIHsKICAgICAgICB3cmFwcGVkVGV4dEluZGVudExlbmd0aCA9IDA7CiAgICAgIH0KICAgIH0KICB9CiAgcmV0dXJuIHdyYXBwZWRUZXh0SW5kZW50TGVuZ3RoOwp9"},{"version":3,"names":["strings","CharacterClassifier","LineInjectedText","ModelLineProjectionData","MonospaceLineBreaksComputerFactory","breakBeforeChars","breakAfterChars","classifier","WrappingCharacterClassifier","fontInfo","tabSize","wrappingColumn","wrappingIndent","requests","injectedTexts","previousBreakingData","addRequest","lineText","injectedText","previousLineBreakData","push","finalize","columnsForFullWidthChar","typicalFullwidthCharacterWidth","typicalHalfwidthCharacterWidth","result","i","len","length","injectionOptions","createLineBreaksFromPreviousLineBreaks","createLineBreaks","arrPool1","arrPool2","options","get","BREAK_BEFORE","BREAK_AFTER","set","charCodeAt","charCode","_asciiMap","_map","_defaultValue","firstLineBreakColumn","prevBreakingOffsets","breakOffsets","prevBreakingOffsetsVisibleColumn","breakOffsetsVisibleColumn","wrappedTextIndentLength","computeWrappedTextIndentLength","wrappedLineBreakColumn","breakingOffsets","breakingOffsetsVisibleColumn","breakingOffsetsCount","lastBreakingOffset","lastBreakingOffsetVisibleColumn","breakingColumn","prevLen","prevIndex","bestDistance","Math","abs","distance","prevBreakOffset","prevBreakOffsetVisibleColumn","breakOffset","breakOffsetVisibleColumn","forcedBreakOffset","forcedBreakOffsetVisibleColumn","visibleColumn","prevCharCode","prevCharCodeClass","entireLineFits","charStartOffset","charCodeClass","charWidth","isHighSurrogate","computeCharWidth","canBreak","hitATabCharacter","prevCharWidth","isLowSurrogate","isFullWidthCharacter","remainingWidthOfNextLine","charCodeAtForcedBreakOffset","_lineText","applyInjectedText","injectionOffsets","map","t","text","column","startOffset","tabCharacterWidth","firstNonWhitespaceIndex","numberOfAdditionalTabs"],"sources":["/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { ModelLineProjectionData } from '../modelLineProjectionData.js';\nexport class MonospaceLineBreaksComputerFactory {\n    constructor(breakBeforeChars, breakAfterChars) {\n        this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n    }\n    static create(options) {\n        return new MonospaceLineBreaksComputerFactory(options.get(122 /* EditorOption.wordWrapBreakBeforeCharacters */), options.get(121 /* EditorOption.wordWrapBreakAfterCharacters */));\n    }\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n        const requests = [];\n        const injectedTexts = [];\n        const previousBreakingData = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                requests.push(lineText);\n                injectedTexts.push(injectedText);\n                previousBreakingData.push(previousLineBreakData);\n            },\n            finalize: () => {\n                const columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth;\n                const result = [];\n                for (let i = 0, len = requests.length; i < len; i++) {\n                    const injectedText = injectedTexts[i];\n                    const previousLineBreakData = previousBreakingData[i];\n                    if (previousLineBreakData && !previousLineBreakData.injectionOptions && !injectedText) {\n                        result[i] = createLineBreaksFromPreviousLineBreaks(this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n                    }\n                    else {\n                        result[i] = createLineBreaks(this.classifier, requests[i], injectedText, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n                    }\n                }\n                arrPool1.length = 0;\n                arrPool2.length = 0;\n                return result;\n            }\n        };\n    }\n}\nclass WrappingCharacterClassifier extends CharacterClassifier {\n    constructor(BREAK_BEFORE, BREAK_AFTER) {\n        super(0 /* CharacterClass.NONE */);\n        for (let i = 0; i < BREAK_BEFORE.length; i++) {\n            this.set(BREAK_BEFORE.charCodeAt(i), 1 /* CharacterClass.BREAK_BEFORE */);\n        }\n        for (let i = 0; i < BREAK_AFTER.length; i++) {\n            this.set(BREAK_AFTER.charCodeAt(i), 2 /* CharacterClass.BREAK_AFTER */);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n            // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n            // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n            // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n            if ((charCode >= 0x3040 && charCode <= 0x30FF)\n                || (charCode >= 0x3400 && charCode <= 0x4DBF)\n                || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {\n                return 3 /* CharacterClass.BREAK_IDEOGRAPHIC */;\n            }\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n}\nlet arrPool1 = [];\nlet arrPool2 = [];\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    if (firstLineBreakColumn === -1) {\n        return null;\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        return null;\n    }\n    const prevBreakingOffsets = previousBreakingData.breakOffsets;\n    const prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = arrPool1;\n    const breakingOffsetsVisibleColumn = arrPool2;\n    let breakingOffsetsCount = 0;\n    let lastBreakingOffset = 0;\n    let lastBreakingOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    const prevLen = prevBreakingOffsets.length;\n    let prevIndex = 0;\n    if (prevIndex >= 0) {\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    while (prevIndex < prevLen) {\n        // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n        let prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n        let prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n        if (lastBreakingOffset > prevBreakOffset) {\n            prevBreakOffset = lastBreakingOffset;\n            prevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;\n        }\n        let breakOffset = 0;\n        let breakOffsetVisibleColumn = 0;\n        let forcedBreakOffset = 0;\n        let forcedBreakOffsetVisibleColumn = 0;\n        // initially, we search as much as possible to the right (if it fits)\n        if (prevBreakOffsetVisibleColumn <= breakingColumn) {\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let prevCharCode = prevBreakOffset === 0 ? 0 /* CharCode.Null */ : lineText.charCodeAt(prevBreakOffset - 1);\n            let prevCharCodeClass = prevBreakOffset === 0 ? 0 /* CharacterClass.NONE */ : classifier.get(prevCharCode);\n            let entireLineFits = true;\n            for (let i = prevBreakOffset; i < len; i++) {\n                const charStartOffset = i;\n                const charCode = lineText.charCodeAt(i);\n                let charCodeClass;\n                let charWidth;\n                if (strings.isHighSurrogate(charCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i++;\n                    charCodeClass = 0 /* CharacterClass.NONE */;\n                    charWidth = 2;\n                }\n                else {\n                    charCodeClass = classifier.get(charCode);\n                    charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n                }\n                if (charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n                    breakOffset = charStartOffset;\n                    breakOffsetVisibleColumn = visibleColumn;\n                }\n                visibleColumn += charWidth;\n                // check if adding character at `i` will go over the breaking column\n                if (visibleColumn > breakingColumn) {\n                    // We need to break at least before character at `i`:\n                    if (charStartOffset > lastBreakingOffset) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n                    }\n                    else {\n                        // we need to advance at least by one character\n                        forcedBreakOffset = i + 1;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                        // Cannot break at `breakOffset` => reset it if it was set\n                        breakOffset = 0;\n                    }\n                    entireLineFits = false;\n                    break;\n                }\n                prevCharCode = charCode;\n                prevCharCodeClass = charCodeClass;\n            }\n            if (entireLineFits) {\n                // there is no more need to break => stop the outer loop!\n                if (breakingOffsetsCount > 0) {\n                    // Add last segment, no need to assign to `lastBreakingOffset` and `lastBreakingOffsetVisibleColumn`\n                    breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n                    breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n                    breakingOffsetsCount++;\n                }\n                break;\n            }\n        }\n        if (breakOffset === 0) {\n            // must search left\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let charCode = lineText.charCodeAt(prevBreakOffset);\n            let charCodeClass = classifier.get(charCode);\n            let hitATabCharacter = false;\n            for (let i = prevBreakOffset - 1; i >= lastBreakingOffset; i--) {\n                const charStartOffset = i + 1;\n                const prevCharCode = lineText.charCodeAt(i);\n                if (prevCharCode === 9 /* CharCode.Tab */) {\n                    // cannot determine the width of a tab when going backwards, so we must go forwards\n                    hitATabCharacter = true;\n                    break;\n                }\n                let prevCharCodeClass;\n                let prevCharWidth;\n                if (strings.isLowSurrogate(prevCharCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i--;\n                    prevCharCodeClass = 0 /* CharacterClass.NONE */;\n                    prevCharWidth = 2;\n                }\n                else {\n                    prevCharCodeClass = classifier.get(prevCharCode);\n                    prevCharWidth = (strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1);\n                }\n                if (visibleColumn <= breakingColumn) {\n                    if (forcedBreakOffset === 0) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n                        // went too far!\n                        break;\n                    }\n                    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n                        breakOffset = charStartOffset;\n                        breakOffsetVisibleColumn = visibleColumn;\n                        break;\n                    }\n                }\n                visibleColumn -= prevCharWidth;\n                charCode = prevCharCode;\n                charCodeClass = prevCharCodeClass;\n            }\n            if (breakOffset !== 0) {\n                const remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n                if (remainingWidthOfNextLine <= tabSize) {\n                    const charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n                    let charWidth;\n                    if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n                        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                        charWidth = 2;\n                    }\n                    else {\n                        charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n                    }\n                    if (remainingWidthOfNextLine - charWidth < 0) {\n                        // it is not worth it to break at breakOffset, it just introduces an extra needless line!\n                        breakOffset = 0;\n                    }\n                }\n            }\n            if (hitATabCharacter) {\n                // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n                prevIndex--;\n                continue;\n            }\n        }\n        if (breakOffset === 0) {\n            // Could not find a good breaking point\n            breakOffset = forcedBreakOffset;\n            breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n        }\n        if (breakOffset <= lastBreakingOffset) {\n            // Make sure that we are advancing (at least one character)\n            const charCode = lineText.charCodeAt(lastBreakingOffset);\n            if (strings.isHighSurrogate(charCode)) {\n                // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                breakOffset = lastBreakingOffset + 2;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + 2;\n            }\n            else {\n                breakOffset = lastBreakingOffset + 1;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + computeCharWidth(charCode, lastBreakingOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n            }\n        }\n        lastBreakingOffset = breakOffset;\n        breakingOffsets[breakingOffsetsCount] = breakOffset;\n        lastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;\n        breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n        breakingOffsetsCount++;\n        breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n        while (prevIndex < 0 || (prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn)) {\n            prevIndex++;\n        }\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    if (breakingOffsetsCount === 0) {\n        return null;\n    }\n    // Doing here some object reuse which ends up helping a huge deal with GC pauses!\n    breakingOffsets.length = breakingOffsetsCount;\n    breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n    arrPool1 = previousBreakingData.breakOffsets;\n    arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n    previousBreakingData.breakOffsets = breakingOffsets;\n    previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n    previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n    return previousBreakingData;\n}\nfunction createLineBreaks(classifier, _lineText, injectedTexts, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    const lineText = LineInjectedText.applyInjectedText(_lineText, injectedTexts);\n    let injectionOptions;\n    let injectionOffsets;\n    if (injectedTexts && injectedTexts.length > 0) {\n        injectionOptions = injectedTexts.map(t => t.options);\n        injectionOffsets = injectedTexts.map(text => text.column - 1);\n    }\n    else {\n        injectionOptions = null;\n        injectionOffsets = null;\n    }\n    if (firstLineBreakColumn === -1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = [];\n    const breakingOffsetsVisibleColumn = [];\n    let breakingOffsetsCount = 0;\n    let breakOffset = 0;\n    let breakOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    let prevCharCode = lineText.charCodeAt(0);\n    let prevCharCodeClass = classifier.get(prevCharCode);\n    let visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n    let startOffset = 1;\n    if (strings.isHighSurrogate(prevCharCode)) {\n        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n        visibleColumn += 1;\n        prevCharCode = lineText.charCodeAt(1);\n        prevCharCodeClass = classifier.get(prevCharCode);\n        startOffset++;\n    }\n    for (let i = startOffset; i < len; i++) {\n        const charStartOffset = i;\n        const charCode = lineText.charCodeAt(i);\n        let charCodeClass;\n        let charWidth;\n        if (strings.isHighSurrogate(charCode)) {\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\n            i++;\n            charCodeClass = 0 /* CharacterClass.NONE */;\n            charWidth = 2;\n        }\n        else {\n            charCodeClass = classifier.get(charCode);\n            charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n        }\n        if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n            breakOffset = charStartOffset;\n            breakOffsetVisibleColumn = visibleColumn;\n        }\n        visibleColumn += charWidth;\n        // check if adding character at `i` will go over the breaking column\n        if (visibleColumn > breakingColumn) {\n            // We need to break at least before character at `i`:\n            if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                // Cannot break at `breakOffset`, must break at `i`\n                breakOffset = charStartOffset;\n                breakOffsetVisibleColumn = visibleColumn - charWidth;\n            }\n            breakingOffsets[breakingOffsetsCount] = breakOffset;\n            breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n            breakingOffsetsCount++;\n            breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n            breakOffset = 0;\n        }\n        prevCharCode = charCode;\n        prevCharCodeClass = charCodeClass;\n    }\n    if (breakingOffsetsCount === 0 && (!injectedTexts || injectedTexts.length === 0)) {\n        return null;\n    }\n    // Add last segment\n    breakingOffsets[breakingOffsetsCount] = len;\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n    return new ModelLineProjectionData(injectionOffsets, injectionOptions, breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\n    if (charCode === 9 /* CharCode.Tab */) {\n        return (tabSize - (visibleColumn % tabSize));\n    }\n    if (strings.isFullWidthCharacter(charCode)) {\n        return columnsForFullWidthChar;\n    }\n    if (charCode < 32) {\n        // when using `editor.renderControlCharacters`, the substitutions are often wide\n        return columnsForFullWidthChar;\n    }\n    return 1;\n}\nfunction tabCharacterWidth(visibleColumn, tabSize) {\n    return (tabSize - (visibleColumn % tabSize));\n}\n/**\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\n * Kinsoku Shori : Don't break before a trailing character, like a period\n */\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass) {\n    return (charCode !== 32 /* CharCode.Space */\n        && ((prevCharCodeClass === 2 /* CharacterClass.BREAK_AFTER */ && charCodeClass !== 2 /* CharacterClass.BREAK_AFTER */) // break at the end of multiple BREAK_AFTER\n            || (prevCharCodeClass !== 1 /* CharacterClass.BREAK_BEFORE */ && charCodeClass === 1 /* CharacterClass.BREAK_BEFORE */) // break at the start of multiple BREAK_BEFORE\n            || (prevCharCodeClass === 3 /* CharacterClass.BREAK_IDEOGRAPHIC */ && charCodeClass !== 2 /* CharacterClass.BREAK_AFTER */)\n            || (charCodeClass === 3 /* CharacterClass.BREAK_IDEOGRAPHIC */ && prevCharCodeClass !== 1 /* CharacterClass.BREAK_BEFORE */)));\n}\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    let wrappedTextIndentLength = 0;\n    if (wrappingIndent !== 0 /* WrappingIndent.None */) {\n        const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n        if (firstNonWhitespaceIndex !== -1) {\n            // Track existing indent\n            for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                const charWidth = (lineText.charCodeAt(i) === 9 /* CharCode.Tab */ ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Increase indent of continuation lines, if desired\n            const numberOfAdditionalTabs = (wrappingIndent === 3 /* WrappingIndent.DeepIndent */ ? 2 : wrappingIndent === 2 /* WrappingIndent.Indent */ ? 1 : 0);\n            for (let i = 0; i < numberOfAdditionalTabs; i++) {\n                const charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Force sticking to beginning of line if no character would fit except for the indentation\n            if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n                wrappedTextIndentLength = 0;\n            }\n        }\n    }\n    return wrappedTextIndentLength;\n}\n"],"mappings":"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"}]}