{"remainingRequest":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js!/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","dependencies":[{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/babel.config.js","mtime":1668271197000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js","mtime":456789000000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICIvVXNlcnMveWFuamlhamlhL0Rlc2t0b3Avd29ya3NwYWNlL2F2dWUtZGF0YS1uZXcvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzIjsKaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICIvVXNlcnMveWFuamlhamlhL0Rlc2t0b3Avd29ya3NwYWNlL2F2dWUtZGF0YS1uZXcvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuY29uc3RydWN0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZG90LWFsbC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5zdGlja3kuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucHVzaC5qcyI7Ci8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uCiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLwppbXBvcnQgeyBOb3RTdXBwb3J0ZWRFcnJvciB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL2Vycm9ycy5qcyc7CmltcG9ydCB7IFRva2VuTWV0YWRhdGEgfSBmcm9tICcuLi8uLi8uLi9lbmNvZGVkVG9rZW5BdHRyaWJ1dGVzLmpzJzsKaW1wb3J0IHsgVGV4dEFzdE5vZGUgfSBmcm9tICcuL2FzdC5qcyc7CmltcG9ydCB7IGxlbmd0aEFkZCwgbGVuZ3RoRGlmZiwgbGVuZ3RoR2V0Q29sdW1uQ291bnRJZlplcm9MaW5lQ291bnQsIGxlbmd0aFRvT2JqLCBsZW5ndGhaZXJvLCB0b0xlbmd0aCB9IGZyb20gJy4vbGVuZ3RoLmpzJzsKaW1wb3J0IHsgU21hbGxJbW11dGFibGVTZXQgfSBmcm9tICcuL3NtYWxsSW1tdXRhYmxlU2V0LmpzJzsKZXhwb3J0IHZhciBUb2tlbiA9IC8qI19fUFVSRV9fKi9fY3JlYXRlQ2xhc3MoZnVuY3Rpb24gVG9rZW4obGVuZ3RoLCBraW5kLAovKioKICogSWYgdGhpcyB0b2tlbiBpcyBhbiBvcGVuaW5nIGJyYWNrZXQsIHRoaXMgaXMgdGhlIGlkIG9mIHRoZSBvcGVuaW5nIGJyYWNrZXQuCiAqIElmIHRoaXMgdG9rZW4gaXMgYSBjbG9zaW5nIGJyYWNrZXQsIHRoaXMgaXMgdGhlIGlkIG9mIHRoZSBmaXJzdCBvcGVuaW5nIGJyYWNrZXQgdGhhdCBpcyBjbG9zZWQgYnkgdGhpcyBicmFja2V0LgogKiBPdGhlcndpc2UsIGl0IGlzIC0xLgogKi8KYnJhY2tldElkLAovKioKICogSWYgdGhpcyB0b2tlbiBpcyBhbiBvcGVuaW5nIGJyYWNrZXQsIHRoaXMganVzdCBjb250YWlucyBgYnJhY2tldElkYC4KICogSWYgdGhpcyB0b2tlbiBpcyBhIGNsb3NpbmcgYnJhY2tldCwgdGhpcyBsaXN0cyBhbGwgb3BlbmluZyBicmFja2V0IGlkcywgdGhhdCBpdCBjbG9zZXMuCiAqIE90aGVyd2lzZSwgaXQgaXMgZW1wdHkuCiAqLwpicmFja2V0SWRzLCBhc3ROb2RlKSB7CiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRva2VuKTsKICB0aGlzLmxlbmd0aCA9IGxlbmd0aDsKICB0aGlzLmtpbmQgPSBraW5kOwogIHRoaXMuYnJhY2tldElkID0gYnJhY2tldElkOwogIHRoaXMuYnJhY2tldElkcyA9IGJyYWNrZXRJZHM7CiAgdGhpcy5hc3ROb2RlID0gYXN0Tm9kZTsKfSk7CmV4cG9ydCB2YXIgVGV4dEJ1ZmZlclRva2VuaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7CiAgZnVuY3Rpb24gVGV4dEJ1ZmZlclRva2VuaXplcih0ZXh0TW9kZWwsIGJyYWNrZXRUb2tlbnMpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0QnVmZmVyVG9rZW5pemVyKTsKICAgIHRoaXMudGV4dE1vZGVsID0gdGV4dE1vZGVsOwogICAgdGhpcy5icmFja2V0VG9rZW5zID0gYnJhY2tldFRva2VuczsKICAgIHRoaXMucmVhZGVyID0gbmV3IE5vblBlZWthYmxlVGV4dEJ1ZmZlclRva2VuaXplcih0aGlzLnRleHRNb2RlbCwgdGhpcy5icmFja2V0VG9rZW5zKTsKICAgIHRoaXMuX29mZnNldCA9IGxlbmd0aFplcm87CiAgICB0aGlzLmRpZFBlZWsgPSBmYWxzZTsKICAgIHRoaXMucGVla2VkID0gbnVsbDsKICAgIHRoaXMudGV4dEJ1ZmZlckxpbmVDb3VudCA9IHRleHRNb2RlbC5nZXRMaW5lQ291bnQoKTsKICAgIHRoaXMudGV4dEJ1ZmZlckxhc3RMaW5lTGVuZ3RoID0gdGV4dE1vZGVsLmdldExpbmVMZW5ndGgodGhpcy50ZXh0QnVmZmVyTGluZUNvdW50KTsKICB9CiAgX2NyZWF0ZUNsYXNzKFRleHRCdWZmZXJUb2tlbml6ZXIsIFt7CiAgICBrZXk6ICJvZmZzZXQiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7CiAgICB9CiAgfSwgewogICAga2V5OiAibGVuZ3RoIiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdG9MZW5ndGgodGhpcy50ZXh0QnVmZmVyTGluZUNvdW50LCB0aGlzLnRleHRCdWZmZXJMYXN0TGluZUxlbmd0aCk7CiAgICB9CiAgfSwgewogICAga2V5OiAic2tpcCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc2tpcChsZW5ndGgpIHsKICAgICAgdGhpcy5kaWRQZWVrID0gZmFsc2U7CiAgICAgIHRoaXMuX29mZnNldCA9IGxlbmd0aEFkZCh0aGlzLl9vZmZzZXQsIGxlbmd0aCk7CiAgICAgIHZhciBvYmogPSBsZW5ndGhUb09iaih0aGlzLl9vZmZzZXQpOwogICAgICB0aGlzLnJlYWRlci5zZXRQb3NpdGlvbihvYmoubGluZUNvdW50LCBvYmouY29sdW1uQ291bnQpOwogICAgfQogIH0sIHsKICAgIGtleTogInJlYWQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWQoKSB7CiAgICAgIHZhciB0b2tlbjsKICAgICAgaWYgKHRoaXMucGVla2VkKSB7CiAgICAgICAgdGhpcy5kaWRQZWVrID0gZmFsc2U7CiAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtlZDsKICAgICAgfSBlbHNlIHsKICAgICAgICB0b2tlbiA9IHRoaXMucmVhZGVyLnJlYWQoKTsKICAgICAgfQogICAgICBpZiAodG9rZW4pIHsKICAgICAgICB0aGlzLl9vZmZzZXQgPSBsZW5ndGhBZGQodGhpcy5fb2Zmc2V0LCB0b2tlbi5sZW5ndGgpOwogICAgICB9CiAgICAgIHJldHVybiB0b2tlbjsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJwZWVrIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBwZWVrKCkgewogICAgICBpZiAoIXRoaXMuZGlkUGVlaykgewogICAgICAgIHRoaXMucGVla2VkID0gdGhpcy5yZWFkZXIucmVhZCgpOwogICAgICAgIHRoaXMuZGlkUGVlayA9IHRydWU7CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMucGVla2VkOwogICAgfQogIH1dKTsKICByZXR1cm4gVGV4dEJ1ZmZlclRva2VuaXplcjsKfSgpOwovKioKICogRG9lcyBub3Qgc3VwcG9ydCBwZWVrLgoqLwp2YXIgTm9uUGVla2FibGVUZXh0QnVmZmVyVG9rZW5pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICBmdW5jdGlvbiBOb25QZWVrYWJsZVRleHRCdWZmZXJUb2tlbml6ZXIodGV4dE1vZGVsLCBicmFja2V0VG9rZW5zKSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9uUGVla2FibGVUZXh0QnVmZmVyVG9rZW5pemVyKTsKICAgIHRoaXMudGV4dE1vZGVsID0gdGV4dE1vZGVsOwogICAgdGhpcy5icmFja2V0VG9rZW5zID0gYnJhY2tldFRva2VuczsKICAgIHRoaXMubGluZUlkeCA9IDA7CiAgICB0aGlzLmxpbmUgPSBudWxsOwogICAgdGhpcy5saW5lQ2hhck9mZnNldCA9IDA7CiAgICB0aGlzLmxpbmVUb2tlbnMgPSBudWxsOwogICAgdGhpcy5saW5lVG9rZW5PZmZzZXQgPSAwOwogICAgLyoqIE11c3QgYmUgYSB6ZXJvIGxpbmUgdG9rZW4uIFRoZSBlbmQgb2YgdGhlIGRvY3VtZW50IGNhbm5vdCBiZSBwZWVrZWQuICovCiAgICB0aGlzLnBlZWtlZFRva2VuID0gbnVsbDsKICAgIHRoaXMudGV4dEJ1ZmZlckxpbmVDb3VudCA9IHRleHRNb2RlbC5nZXRMaW5lQ291bnQoKTsKICAgIHRoaXMudGV4dEJ1ZmZlckxhc3RMaW5lTGVuZ3RoID0gdGV4dE1vZGVsLmdldExpbmVMZW5ndGgodGhpcy50ZXh0QnVmZmVyTGluZUNvdW50KTsKICB9CiAgX2NyZWF0ZUNsYXNzKE5vblBlZWthYmxlVGV4dEJ1ZmZlclRva2VuaXplciwgW3sKICAgIGtleTogInNldFBvc2l0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbihsaW5lSWR4LCBjb2x1bW4pIHsKICAgICAgLy8gV2UgbXVzdCBub3QganVtcCBpbnRvIGEgdG9rZW4hCiAgICAgIGlmIChsaW5lSWR4ID09PSB0aGlzLmxpbmVJZHgpIHsKICAgICAgICB0aGlzLmxpbmVDaGFyT2Zmc2V0ID0gY29sdW1uOwogICAgICAgIHRoaXMubGluZVRva2VuT2Zmc2V0ID0gdGhpcy5saW5lQ2hhck9mZnNldCA9PT0gMCA/IDAgOiB0aGlzLmxpbmVUb2tlbnMuZmluZFRva2VuSW5kZXhBdE9mZnNldCh0aGlzLmxpbmVDaGFyT2Zmc2V0KTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLmxpbmVJZHggPSBsaW5lSWR4OwogICAgICAgIHRoaXMubGluZUNoYXJPZmZzZXQgPSBjb2x1bW47CiAgICAgICAgdGhpcy5saW5lID0gbnVsbDsKICAgICAgfQogICAgICB0aGlzLnBlZWtlZFRva2VuID0gbnVsbDsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJyZWFkIiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkKCkgewogICAgICBpZiAodGhpcy5wZWVrZWRUb2tlbikgewogICAgICAgIHZhciB0b2tlbiA9IHRoaXMucGVla2VkVG9rZW47CiAgICAgICAgdGhpcy5wZWVrZWRUb2tlbiA9IG51bGw7CiAgICAgICAgdGhpcy5saW5lQ2hhck9mZnNldCArPSBsZW5ndGhHZXRDb2x1bW5Db3VudElmWmVyb0xpbmVDb3VudCh0b2tlbi5sZW5ndGgpOwogICAgICAgIHJldHVybiB0b2tlbjsKICAgICAgfQogICAgICBpZiAodGhpcy5saW5lSWR4ID4gdGhpcy50ZXh0QnVmZmVyTGluZUNvdW50IC0gMSB8fCB0aGlzLmxpbmVJZHggPT09IHRoaXMudGV4dEJ1ZmZlckxpbmVDb3VudCAtIDEgJiYgdGhpcy5saW5lQ2hhck9mZnNldCA+PSB0aGlzLnRleHRCdWZmZXJMYXN0TGluZUxlbmd0aCkgewogICAgICAgIC8vIFdlIGFyZSBhZnRlciB0aGUgZW5kCiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0KICAgICAgaWYgKHRoaXMubGluZSA9PT0gbnVsbCkgewogICAgICAgIHRoaXMubGluZVRva2VucyA9IHRoaXMudGV4dE1vZGVsLnRva2VuaXphdGlvbi5nZXRMaW5lVG9rZW5zKHRoaXMubGluZUlkeCArIDEpOwogICAgICAgIHRoaXMubGluZSA9IHRoaXMubGluZVRva2Vucy5nZXRMaW5lQ29udGVudCgpOwogICAgICAgIHRoaXMubGluZVRva2VuT2Zmc2V0ID0gdGhpcy5saW5lQ2hhck9mZnNldCA9PT0gMCA/IDAgOiB0aGlzLmxpbmVUb2tlbnMuZmluZFRva2VuSW5kZXhBdE9mZnNldCh0aGlzLmxpbmVDaGFyT2Zmc2V0KTsKICAgICAgfQogICAgICB2YXIgc3RhcnRMaW5lSWR4ID0gdGhpcy5saW5lSWR4OwogICAgICB2YXIgc3RhcnRMaW5lQ2hhck9mZnNldCA9IHRoaXMubGluZUNoYXJPZmZzZXQ7CiAgICAgIC8vIGxpbWl0cyB0aGUgbGVuZ3RoIG9mIHRleHQgdG9rZW5zLgogICAgICAvLyBJZiB0ZXh0IHRva2VucyBnZXQgdG9vIGxvbmcsIGluY3JlbWVudGFsIHVwZGF0ZXMgd2lsbCBiZSBzbG93CiAgICAgIHZhciBsZW5ndGhIZXVyaXN0aWMgPSAwOwogICAgICB3aGlsZSAodHJ1ZSkgewogICAgICAgIHZhciBsaW5lVG9rZW5zID0gdGhpcy5saW5lVG9rZW5zOwogICAgICAgIHZhciB0b2tlbkNvdW50ID0gbGluZVRva2Vucy5nZXRDb3VudCgpOwogICAgICAgIHZhciBwZWVrZWRCcmFja2V0VG9rZW4gPSBudWxsOwogICAgICAgIGlmICh0aGlzLmxpbmVUb2tlbk9mZnNldCA8IHRva2VuQ291bnQpIHsKICAgICAgICAgIHZhciB0b2tlbk1ldGFkYXRhID0gbGluZVRva2Vucy5nZXRNZXRhZGF0YSh0aGlzLmxpbmVUb2tlbk9mZnNldCk7CiAgICAgICAgICB3aGlsZSAodGhpcy5saW5lVG9rZW5PZmZzZXQgKyAxIDwgdG9rZW5Db3VudCAmJiB0b2tlbk1ldGFkYXRhID09PSBsaW5lVG9rZW5zLmdldE1ldGFkYXRhKHRoaXMubGluZVRva2VuT2Zmc2V0ICsgMSkpIHsKICAgICAgICAgICAgLy8gU2tpcCB0b2tlbnMgdGhhdCBhcmUgaWRlbnRpY2FsLgogICAgICAgICAgICAvLyBTb21ldGltZXMsIChicmFja2V0KSBpZGVudGlmaWVycyBhcmUgc3BsaXQgdXAgaW50byBtdWx0aXBsZSB0b2tlbnMuCiAgICAgICAgICAgIHRoaXMubGluZVRva2VuT2Zmc2V0Kys7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgaXNPdGhlciA9IFRva2VuTWV0YWRhdGEuZ2V0VG9rZW5UeXBlKHRva2VuTWV0YWRhdGEpID09PSAwIC8qIFN0YW5kYXJkVG9rZW5UeXBlLk90aGVyICovOwogICAgICAgICAgdmFyIGNvbnRhaW5zQnJhY2tldFR5cGUgPSBUb2tlbk1ldGFkYXRhLmNvbnRhaW5zQmFsYW5jZWRCcmFja2V0cyh0b2tlbk1ldGFkYXRhKTsKICAgICAgICAgIHZhciBlbmRPZmZzZXQgPSBsaW5lVG9rZW5zLmdldEVuZE9mZnNldCh0aGlzLmxpbmVUb2tlbk9mZnNldCk7CiAgICAgICAgICAvLyBJcyB0aGVyZSBhIGJyYWNrZXQgdG9rZW4gbmV4dD8gT25seSBjb25zdW1lIHRleHQuCiAgICAgICAgICBpZiAoY29udGFpbnNCcmFja2V0VHlwZSAmJiBpc090aGVyICYmIHRoaXMubGluZUNoYXJPZmZzZXQgPCBlbmRPZmZzZXQpIHsKICAgICAgICAgICAgdmFyIGxhbmd1YWdlSWQgPSBsaW5lVG9rZW5zLmdldExhbmd1YWdlSWQodGhpcy5saW5lVG9rZW5PZmZzZXQpOwogICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMubGluZS5zdWJzdHJpbmcodGhpcy5saW5lQ2hhck9mZnNldCwgZW5kT2Zmc2V0KTsKICAgICAgICAgICAgdmFyIGJyYWNrZXRzID0gdGhpcy5icmFja2V0VG9rZW5zLmdldFNpbmdsZUxhbmd1YWdlQnJhY2tldFRva2VucyhsYW5ndWFnZUlkKTsKICAgICAgICAgICAgdmFyIHJlZ2V4cCA9IGJyYWNrZXRzLnJlZ0V4cEdsb2JhbDsKICAgICAgICAgICAgaWYgKHJlZ2V4cCkgewogICAgICAgICAgICAgIHJlZ2V4cC5sYXN0SW5kZXggPSAwOwogICAgICAgICAgICAgIHZhciBtYXRjaCA9IHJlZ2V4cC5leGVjKHRleHQpOwogICAgICAgICAgICAgIGlmIChtYXRjaCkgewogICAgICAgICAgICAgICAgcGVla2VkQnJhY2tldFRva2VuID0gYnJhY2tldHMuZ2V0VG9rZW4obWF0Y2hbMF0pOwogICAgICAgICAgICAgICAgaWYgKHBlZWtlZEJyYWNrZXRUb2tlbikgewogICAgICAgICAgICAgICAgICAvLyBDb25zdW1lIGxlYWRpbmcgdGV4dCBvZiB0aGUgdG9rZW4KICAgICAgICAgICAgICAgICAgdGhpcy5saW5lQ2hhck9mZnNldCArPSBtYXRjaC5pbmRleDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGxlbmd0aEhldXJpc3RpYyArPSBlbmRPZmZzZXQgLSB0aGlzLmxpbmVDaGFyT2Zmc2V0OwogICAgICAgICAgaWYgKHBlZWtlZEJyYWNrZXRUb2tlbikgewogICAgICAgICAgICAvLyBEb24ndCBza2lwIHRoZSBlbnRpcmUgdG9rZW4sIGFzIGEgc2luZ2xlIHRva2VuIGNvdWxkIGNvbnRhaW4gbXVsdGlwbGUgYnJhY2tldHMuCiAgICAgICAgICAgIGlmIChzdGFydExpbmVJZHggIT09IHRoaXMubGluZUlkeCB8fCBzdGFydExpbmVDaGFyT2Zmc2V0ICE9PSB0aGlzLmxpbmVDaGFyT2Zmc2V0KSB7CiAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgdGV4dCBiZWZvcmUgdGhlIGJyYWNrZXQKICAgICAgICAgICAgICB0aGlzLnBlZWtlZFRva2VuID0gcGVla2VkQnJhY2tldFRva2VuOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIC8vIENvbnN1bWUgdGhlIHBlZWtlZCB0b2tlbgogICAgICAgICAgICAgIHRoaXMubGluZUNoYXJPZmZzZXQgKz0gbGVuZ3RoR2V0Q29sdW1uQ291bnRJZlplcm9MaW5lQ291bnQocGVla2VkQnJhY2tldFRva2VuLmxlbmd0aCk7CiAgICAgICAgICAgICAgcmV0dXJuIHBlZWtlZEJyYWNrZXRUb2tlbjsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgLy8gU2tpcCB0aGUgZW50aXJlIHRva2VuLCBhcyB0aGUgdG9rZW4gY29udGFpbnMgbm8gYnJhY2tldHMgYXQgYWxsLgogICAgICAgICAgICB0aGlzLmxpbmVUb2tlbk9mZnNldCsrOwogICAgICAgICAgICB0aGlzLmxpbmVDaGFyT2Zmc2V0ID0gZW5kT2Zmc2V0OwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAodGhpcy5saW5lSWR4ID09PSB0aGlzLnRleHRCdWZmZXJMaW5lQ291bnQgLSAxKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5saW5lSWR4Kys7CiAgICAgICAgICB0aGlzLmxpbmVUb2tlbnMgPSB0aGlzLnRleHRNb2RlbC50b2tlbml6YXRpb24uZ2V0TGluZVRva2Vucyh0aGlzLmxpbmVJZHggKyAxKTsKICAgICAgICAgIHRoaXMubGluZVRva2VuT2Zmc2V0ID0gMDsKICAgICAgICAgIHRoaXMubGluZSA9IHRoaXMubGluZVRva2Vucy5nZXRMaW5lQ29udGVudCgpOwogICAgICAgICAgdGhpcy5saW5lQ2hhck9mZnNldCA9IDA7CiAgICAgICAgICBsZW5ndGhIZXVyaXN0aWMgKz0gMzM7IC8vIG1heCAxMDAwLzMzID0gMzAgbGluZXMKICAgICAgICAgIC8vIFRoaXMgbGltaXRzIHRoZSBhbW91bnQgb2Ygd29yayB0byByZWNvbXB1dGUgbWluLWluZGVudGF0aW9uCiAgICAgICAgICBpZiAobGVuZ3RoSGV1cmlzdGljID4gMTAwMCkgewogICAgICAgICAgICAvLyBvbmx5IGJyZWFrIChhdXRvbWF0aWNhbGx5KSBhdCB0aGUgZW5kIG9mIGxpbmUuCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAobGVuZ3RoSGV1cmlzdGljID4gMTUwMCkgewogICAgICAgICAgLy8gRXZlbnR1YWxseSBicmVhayByZWdhcmRsZXNzIG9mIHRoZSBsaW5lIGxlbmd0aCBzbyB0aGF0CiAgICAgICAgICAvLyB2ZXJ5IGxvbmcgbGluZXMgZG8gbm90IGNhdXNlIGJhZCBwZXJmb3JtYW5jZS4KICAgICAgICAgIC8vIFRoaXMgZWZmZWN0aXZlIGxpbWl0cyBtYXggaW5kZW50YXRpb24gdG8gNTAwLCBhcwogICAgICAgICAgLy8gaW5kZW50YXRpb24gaXMgbm90IGNvbXB1dGVkIGFjcm9zcyBtdWx0aXBsZSB0ZXh0IG5vZGVzLgogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9CiAgICAgIC8vIElmIGEgdG9rZW4gY29udGFpbnMgc29tZSBwcm9wZXIgaW5kZW50YXRpb24sIGl0IGFsc28gY29udGFpbnMgXG57SU5ERU5UQVRJT04rfSg/IXtJTkRFTlRBVElPTn0pLAogICAgICAvLyB1bmxlc3MgdGhlIGxpbmUgaXMgdG9vIGxvbmcuCiAgICAgIC8vIFRodXMsIHRoZSBtaW4gaW5kZW50YXRpb24gb2YgdGhlIGRvY3VtZW50IGlzIHRoZSBtaW5pbXVtIG1pbiBpbmRlbnRhdGlvbiBvZiBldmVyeSB0ZXh0IG5vZGUuCiAgICAgIHZhciBsZW5ndGggPSBsZW5ndGhEaWZmKHN0YXJ0TGluZUlkeCwgc3RhcnRMaW5lQ2hhck9mZnNldCwgdGhpcy5saW5lSWR4LCB0aGlzLmxpbmVDaGFyT2Zmc2V0KTsKICAgICAgcmV0dXJuIG5ldyBUb2tlbihsZW5ndGgsIDAgLyogVG9rZW5LaW5kLlRleHQgKi8sIC0xLCBTbWFsbEltbXV0YWJsZVNldC5nZXRFbXB0eSgpLCBuZXcgVGV4dEFzdE5vZGUobGVuZ3RoKSk7CiAgICB9CiAgfV0pOwogIHJldHVybiBOb25QZWVrYWJsZVRleHRCdWZmZXJUb2tlbml6ZXI7Cn0oKTsKZXhwb3J0IHZhciBGYXN0VG9rZW5pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICBmdW5jdGlvbiBGYXN0VG9rZW5pemVyKHRleHQsIGJyYWNrZXRzKSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmFzdFRva2VuaXplcik7CiAgICB0aGlzLnRleHQgPSB0ZXh0OwogICAgdGhpcy5fb2Zmc2V0ID0gbGVuZ3RoWmVybzsKICAgIHRoaXMuaWR4ID0gMDsKICAgIHZhciByZWdFeHBTdHIgPSBicmFja2V0cy5nZXRSZWdFeHBTdHIoKTsKICAgIHZhciByZWdleHAgPSByZWdFeHBTdHIgPyBuZXcgUmVnRXhwKHJlZ0V4cFN0ciArICd8XG4nLCAnZ2knKSA6IG51bGw7CiAgICB2YXIgdG9rZW5zID0gW107CiAgICB2YXIgbWF0Y2g7CiAgICB2YXIgY3VyTGluZUNvdW50ID0gMDsKICAgIHZhciBsYXN0TGluZUJyZWFrT2Zmc2V0ID0gMDsKICAgIHZhciBsYXN0VG9rZW5FbmRPZmZzZXQgPSAwOwogICAgdmFyIGxhc3RUb2tlbkVuZExpbmUgPSAwOwogICAgdmFyIHNtYWxsVGV4dFRva2VuczBMaW5lID0gbmV3IEFycmF5KCk7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDYwOyBpKyspIHsKICAgICAgc21hbGxUZXh0VG9rZW5zMExpbmUucHVzaChuZXcgVG9rZW4odG9MZW5ndGgoMCwgaSksIDAgLyogVG9rZW5LaW5kLlRleHQgKi8sIC0xLCBTbWFsbEltbXV0YWJsZVNldC5nZXRFbXB0eSgpLCBuZXcgVGV4dEFzdE5vZGUodG9MZW5ndGgoMCwgaSkpKSk7CiAgICB9CiAgICB2YXIgc21hbGxUZXh0VG9rZW5zMUxpbmUgPSBuZXcgQXJyYXkoKTsKICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCA2MDsgX2krKykgewogICAgICBzbWFsbFRleHRUb2tlbnMxTGluZS5wdXNoKG5ldyBUb2tlbih0b0xlbmd0aCgxLCBfaSksIDAgLyogVG9rZW5LaW5kLlRleHQgKi8sIC0xLCBTbWFsbEltbXV0YWJsZVNldC5nZXRFbXB0eSgpLCBuZXcgVGV4dEFzdE5vZGUodG9MZW5ndGgoMSwgX2kpKSkpOwogICAgfQogICAgaWYgKHJlZ2V4cCkgewogICAgICByZWdleHAubGFzdEluZGV4ID0gMDsKICAgICAgLy8gSWYgYSB0b2tlbiBjb250YWlucyBpbmRlbnRhdGlvbiwgaXQgYWxzbyBjb250YWlucyBcbntJTkRFTlRBVElPTit9KD8he0lOREVOVEFUSU9OfSkKICAgICAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4cC5leGVjKHRleHQpKSAhPT0gbnVsbCkgewogICAgICAgIHZhciBjdXJPZmZzZXQgPSBtYXRjaC5pbmRleDsKICAgICAgICB2YXIgdmFsdWUgPSBtYXRjaFswXTsKICAgICAgICBpZiAodmFsdWUgPT09ICdcbicpIHsKICAgICAgICAgIGN1ckxpbmVDb3VudCsrOwogICAgICAgICAgbGFzdExpbmVCcmVha09mZnNldCA9IGN1ck9mZnNldCArIDE7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmIChsYXN0VG9rZW5FbmRPZmZzZXQgIT09IGN1ck9mZnNldCkgewogICAgICAgICAgICB2YXIgdG9rZW4gPSB2b2lkIDA7CiAgICAgICAgICAgIGlmIChsYXN0VG9rZW5FbmRMaW5lID09PSBjdXJMaW5lQ291bnQpIHsKICAgICAgICAgICAgICB2YXIgY29sQ291bnQgPSBjdXJPZmZzZXQgLSBsYXN0VG9rZW5FbmRPZmZzZXQ7CiAgICAgICAgICAgICAgaWYgKGNvbENvdW50IDwgc21hbGxUZXh0VG9rZW5zMExpbmUubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICB0b2tlbiA9IHNtYWxsVGV4dFRva2VuczBMaW5lW2NvbENvdW50XTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKDAsIGNvbENvdW50KTsKICAgICAgICAgICAgICAgIHRva2VuID0gbmV3IFRva2VuKGxlbmd0aCwgMCAvKiBUb2tlbktpbmQuVGV4dCAqLywgLTEsIFNtYWxsSW1tdXRhYmxlU2V0LmdldEVtcHR5KCksIG5ldyBUZXh0QXN0Tm9kZShsZW5ndGgpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdmFyIGxpbmVDb3VudCA9IGN1ckxpbmVDb3VudCAtIGxhc3RUb2tlbkVuZExpbmU7CiAgICAgICAgICAgICAgdmFyIF9jb2xDb3VudCA9IGN1ck9mZnNldCAtIGxhc3RMaW5lQnJlYWtPZmZzZXQ7CiAgICAgICAgICAgICAgaWYgKGxpbmVDb3VudCA9PT0gMSAmJiBfY29sQ291bnQgPCBzbWFsbFRleHRUb2tlbnMxTGluZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHRva2VuID0gc21hbGxUZXh0VG9rZW5zMUxpbmVbX2NvbENvdW50XTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdmFyIF9sZW5ndGggPSB0b0xlbmd0aChsaW5lQ291bnQsIF9jb2xDb3VudCk7CiAgICAgICAgICAgICAgICB0b2tlbiA9IG5ldyBUb2tlbihfbGVuZ3RoLCAwIC8qIFRva2VuS2luZC5UZXh0ICovLCAtMSwgU21hbGxJbW11dGFibGVTZXQuZ2V0RW1wdHkoKSwgbmV3IFRleHRBc3ROb2RlKF9sZW5ndGgpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pOwogICAgICAgICAgfQogICAgICAgICAgLy8gdmFsdWUgaXMgbWF0Y2hlZCBieSByZWdleHAsIHNvIHRoZSB0b2tlbiBtdXN0IGV4aXN0CiAgICAgICAgICB0b2tlbnMucHVzaChicmFja2V0cy5nZXRUb2tlbih2YWx1ZSkpOwogICAgICAgICAgbGFzdFRva2VuRW5kT2Zmc2V0ID0gY3VyT2Zmc2V0ICsgdmFsdWUubGVuZ3RoOwogICAgICAgICAgbGFzdFRva2VuRW5kTGluZSA9IGN1ckxpbmVDb3VudDsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIHZhciBvZmZzZXQgPSB0ZXh0Lmxlbmd0aDsKICAgIGlmIChsYXN0VG9rZW5FbmRPZmZzZXQgIT09IG9mZnNldCkgewogICAgICB2YXIgX2xlbmd0aDIgPSBsYXN0VG9rZW5FbmRMaW5lID09PSBjdXJMaW5lQ291bnQgPyB0b0xlbmd0aCgwLCBvZmZzZXQgLSBsYXN0VG9rZW5FbmRPZmZzZXQpIDogdG9MZW5ndGgoY3VyTGluZUNvdW50IC0gbGFzdFRva2VuRW5kTGluZSwgb2Zmc2V0IC0gbGFzdExpbmVCcmVha09mZnNldCk7CiAgICAgIHRva2Vucy5wdXNoKG5ldyBUb2tlbihfbGVuZ3RoMiwgMCAvKiBUb2tlbktpbmQuVGV4dCAqLywgLTEsIFNtYWxsSW1tdXRhYmxlU2V0LmdldEVtcHR5KCksIG5ldyBUZXh0QXN0Tm9kZShfbGVuZ3RoMikpKTsKICAgIH0KICAgIHRoaXMubGVuZ3RoID0gdG9MZW5ndGgoY3VyTGluZUNvdW50LCBvZmZzZXQgLSBsYXN0TGluZUJyZWFrT2Zmc2V0KTsKICAgIHRoaXMudG9rZW5zID0gdG9rZW5zOwogIH0KICBfY3JlYXRlQ2xhc3MoRmFzdFRva2VuaXplciwgW3sKICAgIGtleTogIm9mZnNldCIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgcmV0dXJuIHRoaXMuX29mZnNldDsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJyZWFkIiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkKCkgewogICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pZHgrK10gfHwgbnVsbDsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJwZWVrIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBwZWVrKCkgewogICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pZHhdIHx8IG51bGw7CiAgICB9CiAgfSwgewogICAga2V5OiAic2tpcCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc2tpcChsZW5ndGgpIHsKICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKCk7CiAgICB9CiAgfV0pOwogIHJldHVybiBGYXN0VG9rZW5pemVyOwp9KCk7"},{"version":3,"names":["NotSupportedError","TokenMetadata","TextAstNode","lengthAdd","lengthDiff","lengthGetColumnCountIfZeroLineCount","lengthToObj","lengthZero","toLength","SmallImmutableSet","Token","length","kind","bracketId","bracketIds","astNode","TextBufferTokenizer","textModel","bracketTokens","reader","NonPeekableTextBufferTokenizer","_offset","didPeek","peeked","textBufferLineCount","getLineCount","textBufferLastLineLength","getLineLength","obj","setPosition","lineCount","columnCount","token","read","lineIdx","line","lineCharOffset","lineTokens","lineTokenOffset","peekedToken","column","findTokenIndexAtOffset","tokenization","getLineTokens","getLineContent","startLineIdx","startLineCharOffset","lengthHeuristic","tokenCount","getCount","peekedBracketToken","tokenMetadata","getMetadata","isOther","getTokenType","containsBracketType","containsBalancedBrackets","endOffset","getEndOffset","languageId","getLanguageId","text","substring","brackets","getSingleLanguageBracketTokens","regexp","regExpGlobal","lastIndex","match","exec","getToken","index","getEmpty","FastTokenizer","idx","regExpStr","getRegExpStr","RegExp","tokens","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","Array","i","push","smallTextTokens1Line","curOffset","value","colCount","offset"],"sources":["/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = new Array();\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = new Array();\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n"],"mappings":"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"}]}