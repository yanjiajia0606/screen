{"remainingRequest":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/thread-loader/dist/cjs.js!/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js!/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/base/common/glob.js","dependencies":[{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/base/common/glob.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/babel.config.js","mtime":1668271197000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js","mtime":456789000000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9yZWdlbmVyYXRvclJ1bnRpbWUgZnJvbSAiL1VzZXJzL3lhbmppYWppYS9EZXNrdG9wL3dvcmtzcGFjZS9hdnVlLWRhdGEtbmV3L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9yZWdlbmVyYXRvclJ1bnRpbWUuanMiOwppbXBvcnQgX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIgZnJvbSAiL1VzZXJzL3lhbmppYWppYS9EZXNrdG9wL3dvcmtzcGFjZS9hdnVlLWRhdGEtbmV3L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnB1c2guanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbi5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudGVzdC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5lbmRzLXdpdGguanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXIuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbmQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5yZWR1Y2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5kb3QtYWxsLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnN0aWNreS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyI7CnZhciBfX2F3YWl0ZXIgPSB0aGlzICYmIHRoaXMuX19hd2FpdGVyIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHsKICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgewogICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsKICAgICAgcmVzb2x2ZSh2YWx1ZSk7CiAgICB9KTsKICB9CiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsKICAgICAgdHJ5IHsKICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICByZWplY3QoZSk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7CiAgICAgIHRyeSB7CiAgICAgICAgc3RlcChnZW5lcmF0b3JbInRocm93Il0odmFsdWUpKTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIHJlamVjdChlKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsKICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7CiAgICB9CiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7CiAgfSk7Cn07CmltcG9ydCB7IGlzVGhlbmFibGUgfSBmcm9tICcuL2FzeW5jLmpzJzsKaW1wb3J0IHsgaXNFcXVhbE9yUGFyZW50IH0gZnJvbSAnLi9leHRwYXRoLmpzJzsKaW1wb3J0IHsgTFJVQ2FjaGUgfSBmcm9tICcuL21hcC5qcyc7CmltcG9ydCB7IGJhc2VuYW1lLCBleHRuYW1lLCBwb3NpeCwgc2VwIH0gZnJvbSAnLi9wYXRoLmpzJzsKaW1wb3J0IHsgaXNMaW51eCB9IGZyb20gJy4vcGxhdGZvcm0uanMnOwppbXBvcnQgeyBlc2NhcGVSZWdFeHBDaGFyYWN0ZXJzIH0gZnJvbSAnLi9zdHJpbmdzLmpzJzsKZXhwb3J0IHZhciBHTE9CU1RBUiA9ICcqKic7CmV4cG9ydCB2YXIgR0xPQl9TUExJVCA9ICcvJzsKdmFyIFBBVEhfUkVHRVggPSAnWy9cXFxcXSc7IC8vIGFueSBzbGFzaCBvciBiYWNrc2xhc2gKdmFyIE5PX1BBVEhfUkVHRVggPSAnW14vXFxcXF0nOyAvLyBhbnkgbm9uLXNsYXNoIGFuZCBub24tYmFja3NsYXNoCnZhciBBTExfRk9SV0FSRF9TTEFTSEVTID0gL1wvL2c7CmZ1bmN0aW9uIHN0YXJzVG9SZWdFeHAoc3RhckNvdW50LCBpc0xhc3RQYXR0ZXJuKSB7CiAgc3dpdGNoIChzdGFyQ291bnQpIHsKICAgIGNhc2UgMDoKICAgICAgcmV0dXJuICcnOwogICAgY2FzZSAxOgogICAgICByZXR1cm4gIiIuY29uY2F0KE5PX1BBVEhfUkVHRVgsICIqPyIpOwogICAgLy8gMSBzdGFyIG1hdGNoZXMgYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzIGV4Y2VwdCBwYXRoIHNlcGFyYXRvciAoLyBhbmQgXCkgLSBub24gZ3JlZWR5ICg/KQogICAgZGVmYXVsdDoKICAgICAgLy8gTWF0Y2hlczogIChQYXRoIFNlcCBPUiBQYXRoIFZhbCBmb2xsb3dlZCBieSBQYXRoIFNlcCkgMC1tYW55IHRpbWVzIGV4Y2VwdCB3aGVuIGl0J3MgdGhlIGxhc3QgcGF0dGVybgogICAgICAvLyAgICAgICAgICAgaW4gd2hpY2ggY2FzZSBhbHNvIG1hdGNoZXMgKFBhdGggU2VwIGZvbGxvd2VkIGJ5IFBhdGggVmFsKQogICAgICAvLyBHcm91cCBpcyBub24gY2FwdHVyaW5nIGJlY2F1c2Ugd2UgZG9uJ3QgbmVlZCB0byBjYXB0dXJlIGF0IGFsbCAoPzouLi4pCiAgICAgIC8vIE92ZXJhbGwgd2UgdXNlIG5vbi1ncmVlZHkgbWF0Y2hpbmcgYmVjYXVzZSBpdCBjb3VsZCBiZSB0aGF0IHdlIG1hdGNoIHRvbyBtdWNoCiAgICAgIHJldHVybiAiKD86Ii5jb25jYXQoUEFUSF9SRUdFWCwgInwiKS5jb25jYXQoTk9fUEFUSF9SRUdFWCwgIisiKS5jb25jYXQoUEFUSF9SRUdFWCkuY29uY2F0KGlzTGFzdFBhdHRlcm4gPyAifCIuY29uY2F0KFBBVEhfUkVHRVgpLmNvbmNhdChOT19QQVRIX1JFR0VYLCAiKyIpIDogJycsICIpKj8iKTsKICB9Cn0KZXhwb3J0IGZ1bmN0aW9uIHNwbGl0R2xvYkF3YXJlKHBhdHRlcm4sIHNwbGl0Q2hhcikgewogIGlmICghcGF0dGVybikgewogICAgcmV0dXJuIFtdOwogIH0KICB2YXIgc2VnbWVudHMgPSBbXTsKICB2YXIgaW5CcmFjZXMgPSBmYWxzZTsKICB2YXIgaW5CcmFja2V0cyA9IGZhbHNlOwogIHZhciBjdXJWYWwgPSAnJzsKICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocGF0dGVybiksCiAgICBfc3RlcDsKICB0cnkgewogICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHsKICAgICAgdmFyIGNoYXIgPSBfc3RlcC52YWx1ZTsKICAgICAgc3dpdGNoIChjaGFyKSB7CiAgICAgICAgY2FzZSBzcGxpdENoYXI6CiAgICAgICAgICBpZiAoIWluQnJhY2VzICYmICFpbkJyYWNrZXRzKSB7CiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goY3VyVmFsKTsKICAgICAgICAgICAgY3VyVmFsID0gJyc7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAneyc6CiAgICAgICAgICBpbkJyYWNlcyA9IHRydWU7CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICd9JzoKICAgICAgICAgIGluQnJhY2VzID0gZmFsc2U7CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICdbJzoKICAgICAgICAgIGluQnJhY2tldHMgPSB0cnVlOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAnXSc6CiAgICAgICAgICBpbkJyYWNrZXRzID0gZmFsc2U7CiAgICAgICAgICBicmVhazsKICAgICAgfQogICAgICBjdXJWYWwgKz0gY2hhcjsKICAgIH0KICAgIC8vIFRhaWwKICB9IGNhdGNoIChlcnIpIHsKICAgIF9pdGVyYXRvci5lKGVycik7CiAgfSBmaW5hbGx5IHsKICAgIF9pdGVyYXRvci5mKCk7CiAgfQogIGlmIChjdXJWYWwpIHsKICAgIHNlZ21lbnRzLnB1c2goY3VyVmFsKTsKICB9CiAgcmV0dXJuIHNlZ21lbnRzOwp9CmZ1bmN0aW9uIHBhcnNlUmVnRXhwKHBhdHRlcm4pIHsKICBpZiAoIXBhdHRlcm4pIHsKICAgIHJldHVybiAnJzsKICB9CiAgdmFyIHJlZ0V4ID0gJyc7CiAgLy8gU3BsaXQgdXAgaW50byBzZWdtZW50cyBmb3IgZWFjaCBzbGFzaCBmb3VuZAogIHZhciBzZWdtZW50cyA9IHNwbGl0R2xvYkF3YXJlKHBhdHRlcm4sIEdMT0JfU1BMSVQpOwogIC8vIFNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBvbmx5IGhhdmUgZ2xvYnN0YXJzCiAgaWYgKHNlZ21lbnRzLmV2ZXJ5KGZ1bmN0aW9uIChzZWdtZW50KSB7CiAgICByZXR1cm4gc2VnbWVudCA9PT0gR0xPQlNUQVI7CiAgfSkpIHsKICAgIHJlZ0V4ID0gJy4qJzsKICB9CiAgLy8gQnVpbGQgcmVnZXggb3ZlciBzZWdtZW50cwogIGVsc2UgewogICAgdmFyIHByZXZpb3VzU2VnbWVudFdhc0dsb2JTdGFyID0gZmFsc2U7CiAgICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50LCBpbmRleCkgewogICAgICAvLyBUcmVhdCBnbG9ic3RhciBzcGVjaWFsbHkKICAgICAgaWYgKHNlZ21lbnQgPT09IEdMT0JTVEFSKSB7CiAgICAgICAgLy8gaWYgd2UgaGF2ZSBtb3JlIHRoYW4gb25lIGdsb2JzdGFyIGFmdGVyIGFub3RoZXIsIGp1c3QgaWdub3JlIGl0CiAgICAgICAgaWYgKHByZXZpb3VzU2VnbWVudFdhc0dsb2JTdGFyKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIHJlZ0V4ICs9IHN0YXJzVG9SZWdFeHAoMiwgaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCAtIDEpOwogICAgICB9CiAgICAgIC8vIEFueXRoaW5nIGVsc2UsIG5vdCBnbG9ic3RhcgogICAgICBlbHNlIHsKICAgICAgICAvLyBTdGF0ZXMKICAgICAgICB2YXIgaW5CcmFjZXMgPSBmYWxzZTsKICAgICAgICB2YXIgYnJhY2VWYWwgPSAnJzsKICAgICAgICB2YXIgaW5CcmFja2V0cyA9IGZhbHNlOwogICAgICAgIHZhciBicmFja2V0VmFsID0gJyc7CiAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzZWdtZW50KSwKICAgICAgICAgIF9zdGVwMjsKICAgICAgICB0cnkgewogICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgdmFyIGNoYXIgPSBfc3RlcDIudmFsdWU7CiAgICAgICAgICAgIC8vIFN1cHBvcnQgYnJhY2UgZXhwYW5zaW9uCiAgICAgICAgICAgIGlmIChjaGFyICE9PSAnfScgJiYgaW5CcmFjZXMpIHsKICAgICAgICAgICAgICBicmFjZVZhbCArPSBjaGFyOwogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vIFN1cHBvcnQgYnJhY2tldHMKICAgICAgICAgICAgaWYgKGluQnJhY2tldHMgJiYgKGNoYXIgIT09ICddJyB8fCAhYnJhY2tldFZhbCkgLyogXSBpcyBsaXRlcmFsbHkgb25seSBhbGxvd2VkIGFzIGZpcnN0IGNoYXJhY3RlciBpbiBicmFja2V0cyB0byBtYXRjaCBpdCAqLykgewogICAgICAgICAgICAgIHZhciByZXMgPSB2b2lkIDA7CiAgICAgICAgICAgICAgLy8gcmFuZ2Ugb3BlcmF0b3IKICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJy0nKSB7CiAgICAgICAgICAgICAgICByZXMgPSBjaGFyOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAvLyBuZWdhdGlvbiBvcGVyYXRvciAob25seSB2YWxpZCBvbiBmaXJzdCBpbmRleCBpbiBicmFja2V0KQogICAgICAgICAgICAgIGVsc2UgaWYgKChjaGFyID09PSAnXicgfHwgY2hhciA9PT0gJyEnKSAmJiAhYnJhY2tldFZhbCkgewogICAgICAgICAgICAgICAgcmVzID0gJ14nOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAvLyBnbG9iIHNwbGl0IG1hdGNoaW5nIGlzIG5vdCBhbGxvd2VkIHdpdGhpbiBjaGFyYWN0ZXIgcmFuZ2VzCiAgICAgICAgICAgICAgLy8gc2VlIGh0dHA6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuNy9nbG9iLjcuaHRtbAogICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IEdMT0JfU1BMSVQpIHsKICAgICAgICAgICAgICAgIHJlcyA9ICcnOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAvLyBhbnl0aGluZyBlbHNlIGdldHMgZXNjYXBlZAogICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgcmVzID0gZXNjYXBlUmVnRXhwQ2hhcmFjdGVycyhjaGFyKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJhY2tldFZhbCArPSByZXM7CiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgc3dpdGNoIChjaGFyKSB7CiAgICAgICAgICAgICAgY2FzZSAneyc6CiAgICAgICAgICAgICAgICBpbkJyYWNlcyA9IHRydWU7CiAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICBjYXNlICdbJzoKICAgICAgICAgICAgICAgIGluQnJhY2tldHMgPSB0cnVlOwogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgY2FzZSAnfSc6CiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgIHZhciBjaG9pY2VzID0gc3BsaXRHbG9iQXdhcmUoYnJhY2VWYWwsICcsJyk7CiAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnRzIHtmb28sYmFyfSA9PiBbZm9vfGJhcl0KICAgICAgICAgICAgICAgICAgdmFyIGJyYWNlUmVnRXhwID0gIig/OiIuY29uY2F0KGNob2ljZXMubWFwKGZ1bmN0aW9uIChjaG9pY2UpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VSZWdFeHAoY2hvaWNlKTsKICAgICAgICAgICAgICAgICAgfSkuam9pbignfCcpLCAiKSIpOwogICAgICAgICAgICAgICAgICByZWdFeCArPSBicmFjZVJlZ0V4cDsKICAgICAgICAgICAgICAgICAgaW5CcmFjZXMgPSBmYWxzZTsKICAgICAgICAgICAgICAgICAgYnJhY2VWYWwgPSAnJzsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY2FzZSAnXSc6CiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgIHJlZ0V4ICs9ICdbJyArIGJyYWNrZXRWYWwgKyAnXSc7CiAgICAgICAgICAgICAgICAgIGluQnJhY2tldHMgPSBmYWxzZTsKICAgICAgICAgICAgICAgICAgYnJhY2tldFZhbCA9ICcnOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjYXNlICc/JzoKICAgICAgICAgICAgICAgIHJlZ0V4ICs9IE5PX1BBVEhfUkVHRVg7IC8vIDEgPyBtYXRjaGVzIGFueSBzaW5nbGUgY2hhcmFjdGVyIGV4Y2VwdCBwYXRoIHNlcGFyYXRvciAoLyBhbmQgXCkKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIGNhc2UgJyonOgogICAgICAgICAgICAgICAgcmVnRXggKz0gc3RhcnNUb1JlZ0V4cCgxKTsKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICByZWdFeCArPSBlc2NhcGVSZWdFeHBDaGFyYWN0ZXJzKGNoYXIpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICAvLyBUYWlsOiBBZGQgdGhlIHNsYXNoIHdlIGhhZCBzcGxpdCBvbiBpZiB0aGVyZSBpcyBtb3JlIHRvCiAgICAgICAgICAvLyBjb21lIGFuZCB0aGUgcmVtYWluaW5nIHBhdHRlcm4gaXMgbm90IGEgZ2xvYnN0YXIKICAgICAgICAgIC8vIEZvciBleGFtcGxlIGlmIHBhdHRlcm46IHNvbWUvKiovKi5qcyB3ZSB3YW50IHRoZSAiLyIgYWZ0ZXIKICAgICAgICAgIC8vIHNvbWUgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIFJlZ0V4IHRvIHByZXZlbnQgYSBmb2xkZXIgY2FsbGVkCiAgICAgICAgICAvLyAic29tZXRoaW5nIiB0byBtYXRjaCBhcyB3ZWxsLgogICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIF9pdGVyYXRvcjIuZigpOwogICAgICAgIH0KICAgICAgICBpZiAoaW5kZXggPCBzZWdtZW50cy5sZW5ndGggLSAxICYmICgKICAgICAgICAvLyBtb3JlIHNlZ21lbnRzIHRvIGNvbWUgYWZ0ZXIgdGhpcwogICAgICAgIHNlZ21lbnRzW2luZGV4ICsgMV0gIT09IEdMT0JTVEFSIHx8CiAgICAgICAgLy8gbmV4dCBzZWdtZW50IGlzIG5vdCAqKiwgb3IuLi4KICAgICAgICBpbmRleCArIDIgPCBzZWdtZW50cy5sZW5ndGggLy8gLi4ubmV4dCBzZWdtZW50IGlzICoqIGJ1dCB0aGVyZSBpcyBtb3JlIHNlZ21lbnRzIGFmdGVyIHRoYXQKICAgICAgICApKSB7CiAgICAgICAgICByZWdFeCArPSBQQVRIX1JFR0VYOwogICAgICAgIH0KICAgICAgfQogICAgICAvLyB1cGRhdGUgZ2xvYnN0YXIgc3RhdGUKICAgICAgcHJldmlvdXNTZWdtZW50V2FzR2xvYlN0YXIgPSBzZWdtZW50ID09PSBHTE9CU1RBUjsKICAgIH0pOwogIH0KICByZXR1cm4gcmVnRXg7Cn0KLy8gcmVnZXhlcyB0byBjaGVjayBmb3IgdHJpdmlhbCBnbG9iIHBhdHRlcm5zIHRoYXQganVzdCBjaGVjayBmb3IgU3RyaW5nI2VuZHNXaXRoCnZhciBUMSA9IC9eXCpcKlwvXCpcLltcd1wuLV0rJC87IC8vICoqLyouc29tZXRoaW5nCnZhciBUMiA9IC9eXCpcKlwvKFtcd1wuLV0rKVwvPyQvOyAvLyAqKi9zb21ldGhpbmcKdmFyIFQzID0gL157XCpcKlwvXCo/W1x3XC4tXStcLz8oLFwqXCpcL1wqP1tcd1wuLV0rXC8/KSp9JC87IC8vIHsqKi8qLnNvbWV0aGluZywqKi8qLmVsc2V9IG9yIHsqKi9wYWNrYWdlLmpzb24sKiovcHJvamVjdC5qc29ufQp2YXIgVDNfMiA9IC9ee1wqXCpcL1wqP1tcd1wuLV0rKFwvKFwqXCopPyk/KCxcKlwqXC9cKj9bXHdcLi1dKyhcLyhcKlwqKT8pPykqfSQvOyAvLyBMaWtlIFQzLCB3aXRoIG9wdGlvbmFsIHRyYWlsaW5nIC8qKgp2YXIgVDQgPSAvXlwqXCooKFwvW1x3XC4tXSspKylcLz8kLzsgLy8gKiovc29tZXRoaW5nL2Vsc2UKdmFyIFQ1ID0gL14oW1x3XC4tXSsoXC9bXHdcLi1dKykqKVwvPyQvOyAvLyBzb21ldGhpbmcvZWxzZQp2YXIgQ0FDSEUgPSBuZXcgTFJVQ2FjaGUoMTAwMDApOyAvLyBib3VuZGVkIHRvIDEwMDAwIGVsZW1lbnRzCnZhciBGQUxTRSA9IGZ1bmN0aW9uIEZBTFNFKCkgewogIHJldHVybiBmYWxzZTsKfTsKdmFyIE5VTEwgPSBmdW5jdGlvbiBOVUxMKCkgewogIHJldHVybiBudWxsOwp9OwpmdW5jdGlvbiBwYXJzZVBhdHRlcm4oYXJnMSwgb3B0aW9ucykgewogIGlmICghYXJnMSkgewogICAgcmV0dXJuIE5VTEw7CiAgfQogIC8vIEhhbmRsZSByZWxhdGl2ZSBwYXR0ZXJucwogIHZhciBwYXR0ZXJuOwogIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3N0cmluZycpIHsKICAgIHBhdHRlcm4gPSBhcmcxLnBhdHRlcm47CiAgfSBlbHNlIHsKICAgIHBhdHRlcm4gPSBhcmcxOwogIH0KICAvLyBXaGl0ZXNwYWNlIHRyaW1taW5nCiAgcGF0dGVybiA9IHBhdHRlcm4udHJpbSgpOwogIC8vIENoZWNrIGNhY2hlCiAgdmFyIHBhdHRlcm5LZXkgPSAiIi5jb25jYXQocGF0dGVybiwgIl8iKS5jb25jYXQoISFvcHRpb25zLnRyaW1Gb3JFeGNsdXNpb25zKTsKICB2YXIgcGFyc2VkUGF0dGVybiA9IENBQ0hFLmdldChwYXR0ZXJuS2V5KTsKICBpZiAocGFyc2VkUGF0dGVybikgewogICAgcmV0dXJuIHdyYXBSZWxhdGl2ZVBhdHRlcm4ocGFyc2VkUGF0dGVybiwgYXJnMSk7CiAgfQogIC8vIENoZWNrIGZvciBUcml2aWFscwogIHZhciBtYXRjaDsKICBpZiAoVDEudGVzdChwYXR0ZXJuKSkgewogICAgcGFyc2VkUGF0dGVybiA9IHRyaXZpYTEocGF0dGVybi5zdWJzdHIoNCksIHBhdHRlcm4pOyAvLyBjb21tb24gcGF0dGVybjogKiovKi50eHQganVzdCBuZWVkIGVuZHNXaXRoIGNoZWNrCiAgfSBlbHNlIGlmIChtYXRjaCA9IFQyLmV4ZWModHJpbUZvckV4Y2x1c2lvbnMocGF0dGVybiwgb3B0aW9ucykpKSB7CiAgICAvLyBjb21tb24gcGF0dGVybjogKiovc29tZS50eHQganVzdCBuZWVkIGJhc2VuYW1lIGNoZWNrCiAgICBwYXJzZWRQYXR0ZXJuID0gdHJpdmlhMihtYXRjaFsxXSwgcGF0dGVybik7CiAgfSBlbHNlIGlmICgob3B0aW9ucy50cmltRm9yRXhjbHVzaW9ucyA/IFQzXzIgOiBUMykudGVzdChwYXR0ZXJuKSkgewogICAgLy8gcmVwZXRpdGlvbiBvZiBjb21tb24gcGF0dGVybnMgKHNlZSBhYm92ZSkgeyoqLyoudHh0LCoqLyoucG5nfQogICAgcGFyc2VkUGF0dGVybiA9IHRyaXZpYTMocGF0dGVybiwgb3B0aW9ucyk7CiAgfSBlbHNlIGlmIChtYXRjaCA9IFQ0LmV4ZWModHJpbUZvckV4Y2x1c2lvbnMocGF0dGVybiwgb3B0aW9ucykpKSB7CiAgICAvLyBjb21tb24gcGF0dGVybjogKiovc29tZXRoaW5nL2Vsc2UganVzdCBuZWVkIGVuZHNXaXRoIGNoZWNrCiAgICBwYXJzZWRQYXR0ZXJuID0gdHJpdmlhNGFuZDUobWF0Y2hbMV0uc3Vic3RyKDEpLCBwYXR0ZXJuLCB0cnVlKTsKICB9IGVsc2UgaWYgKG1hdGNoID0gVDUuZXhlYyh0cmltRm9yRXhjbHVzaW9ucyhwYXR0ZXJuLCBvcHRpb25zKSkpIHsKICAgIC8vIGNvbW1vbiBwYXR0ZXJuOiBzb21ldGhpbmcvZWxzZSBqdXN0IG5lZWQgZXF1YWxzIGNoZWNrCiAgICBwYXJzZWRQYXR0ZXJuID0gdHJpdmlhNGFuZDUobWF0Y2hbMV0sIHBhdHRlcm4sIGZhbHNlKTsKICB9CiAgLy8gT3RoZXJ3aXNlIGNvbnZlcnQgdG8gcGF0dGVybgogIGVsc2UgewogICAgcGFyc2VkUGF0dGVybiA9IHRvUmVnRXhwKHBhdHRlcm4pOwogIH0KICAvLyBDYWNoZQogIENBQ0hFLnNldChwYXR0ZXJuS2V5LCBwYXJzZWRQYXR0ZXJuKTsKICByZXR1cm4gd3JhcFJlbGF0aXZlUGF0dGVybihwYXJzZWRQYXR0ZXJuLCBhcmcxKTsKfQpmdW5jdGlvbiB3cmFwUmVsYXRpdmVQYXR0ZXJuKHBhcnNlZFBhdHRlcm4sIGFyZzIpIHsKICBpZiAodHlwZW9mIGFyZzIgPT09ICdzdHJpbmcnKSB7CiAgICByZXR1cm4gcGFyc2VkUGF0dGVybjsKICB9CiAgdmFyIHdyYXBwZWRQYXR0ZXJuID0gZnVuY3Rpb24gd3JhcHBlZFBhdHRlcm4ocGF0aCwgYmFzZW5hbWUpIHsKICAgIGlmICghaXNFcXVhbE9yUGFyZW50KHBhdGgsIGFyZzIuYmFzZSwgIWlzTGludXgpKSB7CiAgICAgIC8vIHNraXAgZ2xvYiBtYXRjaGluZyBpZiBgYmFzZWAgaXMgbm90IGEgcGFyZW50IG9mIGBwYXRoYAogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIC8vIEdpdmVuIHdlIGhhdmUgY2hlY2tlZCBgYmFzZWAgYmVpbmcgYSBwYXJlbnQgb2YgYHBhdGhgLAogICAgLy8gd2UgY2FuIG5vdyByZW1vdmUgdGhlIGBiYXNlYCBwb3J0aW9uIG9mIHRoZSBgcGF0aGAKICAgIC8vIGFuZCBvbmx5IG1hdGNoIG9uIHRoZSByZW1haW5pbmcgcGF0aCBjb21wb25lbnRzCiAgICByZXR1cm4gcGFyc2VkUGF0dGVybihwYXRoLnN1YnN0cihhcmcyLmJhc2UubGVuZ3RoICsgMSksIGJhc2VuYW1lKTsKICB9OwogIC8vIE1ha2Ugc3VyZSB0byBwcmVzZXJ2ZSBhc3NvY2lhdGVkIG1ldGFkYXRhCiAgd3JhcHBlZFBhdHRlcm4uYWxsQmFzZW5hbWVzID0gcGFyc2VkUGF0dGVybi5hbGxCYXNlbmFtZXM7CiAgd3JhcHBlZFBhdHRlcm4uYWxsUGF0aHMgPSBwYXJzZWRQYXR0ZXJuLmFsbFBhdGhzOwogIHdyYXBwZWRQYXR0ZXJuLmJhc2VuYW1lcyA9IHBhcnNlZFBhdHRlcm4uYmFzZW5hbWVzOwogIHdyYXBwZWRQYXR0ZXJuLnBhdHRlcm5zID0gcGFyc2VkUGF0dGVybi5wYXR0ZXJuczsKICByZXR1cm4gd3JhcHBlZFBhdHRlcm47Cn0KZnVuY3Rpb24gdHJpbUZvckV4Y2x1c2lvbnMocGF0dGVybiwgb3B0aW9ucykgewogIHJldHVybiBvcHRpb25zLnRyaW1Gb3JFeGNsdXNpb25zICYmIHBhdHRlcm4uZW5kc1dpdGgoJy8qKicpID8gcGF0dGVybi5zdWJzdHIoMCwgcGF0dGVybi5sZW5ndGggLSAyKSA6IHBhdHRlcm47IC8vIGRyb3BwaW5nICoqLCB0YWlsaW5nIC8gaXMgZHJvcHBlZCBsYXRlcgp9Ci8vIGNvbW1vbiBwYXR0ZXJuOiAqKi8qLnR4dCBqdXN0IG5lZWQgZW5kc1dpdGggY2hlY2sKZnVuY3Rpb24gdHJpdmlhMShiYXNlLCBwYXR0ZXJuKSB7CiAgcmV0dXJuIGZ1bmN0aW9uIChwYXRoLCBiYXNlbmFtZSkgewogICAgcmV0dXJuIHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyAmJiBwYXRoLmVuZHNXaXRoKGJhc2UpID8gcGF0dGVybiA6IG51bGw7CiAgfTsKfQovLyBjb21tb24gcGF0dGVybjogKiovc29tZS50eHQganVzdCBuZWVkIGJhc2VuYW1lIGNoZWNrCmZ1bmN0aW9uIHRyaXZpYTIoYmFzZSwgcGF0dGVybikgewogIHZhciBzbGFzaEJhc2UgPSAiLyIuY29uY2F0KGJhc2UpOwogIHZhciBiYWNrc2xhc2hCYXNlID0gIlxcIi5jb25jYXQoYmFzZSk7CiAgdmFyIHBhcnNlZFBhdHRlcm4gPSBmdW5jdGlvbiBwYXJzZWRQYXR0ZXJuKHBhdGgsIGJhc2VuYW1lKSB7CiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgaWYgKGJhc2VuYW1lKSB7CiAgICAgIHJldHVybiBiYXNlbmFtZSA9PT0gYmFzZSA/IHBhdHRlcm4gOiBudWxsOwogICAgfQogICAgcmV0dXJuIHBhdGggPT09IGJhc2UgfHwgcGF0aC5lbmRzV2l0aChzbGFzaEJhc2UpIHx8IHBhdGguZW5kc1dpdGgoYmFja3NsYXNoQmFzZSkgPyBwYXR0ZXJuIDogbnVsbDsKICB9OwogIHZhciBiYXNlbmFtZXMgPSBbYmFzZV07CiAgcGFyc2VkUGF0dGVybi5iYXNlbmFtZXMgPSBiYXNlbmFtZXM7CiAgcGFyc2VkUGF0dGVybi5wYXR0ZXJucyA9IFtwYXR0ZXJuXTsKICBwYXJzZWRQYXR0ZXJuLmFsbEJhc2VuYW1lcyA9IGJhc2VuYW1lczsKICByZXR1cm4gcGFyc2VkUGF0dGVybjsKfQovLyByZXBldGl0aW9uIG9mIGNvbW1vbiBwYXR0ZXJucyAoc2VlIGFib3ZlKSB7KiovKi50eHQsKiovKi5wbmd9CmZ1bmN0aW9uIHRyaXZpYTMocGF0dGVybiwgb3B0aW9ucykgewogIHZhciBwYXJzZWRQYXR0ZXJucyA9IGFnZ3JlZ2F0ZUJhc2VuYW1lTWF0Y2hlcyhwYXR0ZXJuLnNsaWNlKDEsIC0xKS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocGF0dGVybikgewogICAgcmV0dXJuIHBhcnNlUGF0dGVybihwYXR0ZXJuLCBvcHRpb25zKTsKICB9KS5maWx0ZXIoZnVuY3Rpb24gKHBhdHRlcm4pIHsKICAgIHJldHVybiBwYXR0ZXJuICE9PSBOVUxMOwogIH0pLCBwYXR0ZXJuKTsKICB2YXIgcGF0dGVybnNMZW5ndGggPSBwYXJzZWRQYXR0ZXJucy5sZW5ndGg7CiAgaWYgKCFwYXR0ZXJuc0xlbmd0aCkgewogICAgcmV0dXJuIE5VTEw7CiAgfQogIGlmIChwYXR0ZXJuc0xlbmd0aCA9PT0gMSkgewogICAgcmV0dXJuIHBhcnNlZFBhdHRlcm5zWzBdOwogIH0KICB2YXIgcGFyc2VkUGF0dGVybiA9IGZ1bmN0aW9uIHBhcnNlZFBhdHRlcm4ocGF0aCwgYmFzZW5hbWUpIHsKICAgIGZvciAodmFyIGkgPSAwLCBuID0gcGFyc2VkUGF0dGVybnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7CiAgICAgIGlmIChwYXJzZWRQYXR0ZXJuc1tpXShwYXRoLCBiYXNlbmFtZSkpIHsKICAgICAgICByZXR1cm4gcGF0dGVybjsKICAgICAgfQogICAgfQogICAgcmV0dXJuIG51bGw7CiAgfTsKICB2YXIgd2l0aEJhc2VuYW1lcyA9IHBhcnNlZFBhdHRlcm5zLmZpbmQoZnVuY3Rpb24gKHBhdHRlcm4pIHsKICAgIHJldHVybiAhIXBhdHRlcm4uYWxsQmFzZW5hbWVzOwogIH0pOwogIGlmICh3aXRoQmFzZW5hbWVzKSB7CiAgICBwYXJzZWRQYXR0ZXJuLmFsbEJhc2VuYW1lcyA9IHdpdGhCYXNlbmFtZXMuYWxsQmFzZW5hbWVzOwogIH0KICB2YXIgYWxsUGF0aHMgPSBwYXJzZWRQYXR0ZXJucy5yZWR1Y2UoZnVuY3Rpb24gKGFsbCwgY3VycmVudCkgewogICAgcmV0dXJuIGN1cnJlbnQuYWxsUGF0aHMgPyBhbGwuY29uY2F0KGN1cnJlbnQuYWxsUGF0aHMpIDogYWxsOwogIH0sIFtdKTsKICBpZiAoYWxsUGF0aHMubGVuZ3RoKSB7CiAgICBwYXJzZWRQYXR0ZXJuLmFsbFBhdGhzID0gYWxsUGF0aHM7CiAgfQogIHJldHVybiBwYXJzZWRQYXR0ZXJuOwp9Ci8vIGNvbW1vbiBwYXR0ZXJuczogKiovc29tZXRoaW5nL2Vsc2UganVzdCBuZWVkIGVuZHNXaXRoIGNoZWNrLCBzb21ldGhpbmcvZWxzZSBqdXN0IG5lZWRzIGFuZCBlcXVhbHMgY2hlY2sKZnVuY3Rpb24gdHJpdmlhNGFuZDUodGFyZ2V0UGF0aCwgcGF0dGVybiwgbWF0Y2hQYXRoRW5kcykgewogIHZhciB1c2luZ1Bvc2l4U2VwID0gc2VwID09PSBwb3NpeC5zZXA7CiAgdmFyIG5hdGl2ZVBhdGggPSB1c2luZ1Bvc2l4U2VwID8gdGFyZ2V0UGF0aCA6IHRhcmdldFBhdGgucmVwbGFjZShBTExfRk9SV0FSRF9TTEFTSEVTLCBzZXApOwogIHZhciBuYXRpdmVQYXRoRW5kID0gc2VwICsgbmF0aXZlUGF0aDsKICB2YXIgdGFyZ2V0UGF0aEVuZCA9IHBvc2l4LnNlcCArIHRhcmdldFBhdGg7CiAgdmFyIHBhcnNlZFBhdHRlcm47CiAgaWYgKG1hdGNoUGF0aEVuZHMpIHsKICAgIHBhcnNlZFBhdHRlcm4gPSBmdW5jdGlvbiBwYXJzZWRQYXR0ZXJuKHBhdGgsIGJhc2VuYW1lKSB7CiAgICAgIHJldHVybiB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgKHBhdGggPT09IG5hdGl2ZVBhdGggfHwgcGF0aC5lbmRzV2l0aChuYXRpdmVQYXRoRW5kKSB8fCAhdXNpbmdQb3NpeFNlcCAmJiAocGF0aCA9PT0gdGFyZ2V0UGF0aCB8fCBwYXRoLmVuZHNXaXRoKHRhcmdldFBhdGhFbmQpKSkgPyBwYXR0ZXJuIDogbnVsbDsKICAgIH07CiAgfSBlbHNlIHsKICAgIHBhcnNlZFBhdHRlcm4gPSBmdW5jdGlvbiBwYXJzZWRQYXR0ZXJuKHBhdGgsIGJhc2VuYW1lKSB7CiAgICAgIHJldHVybiB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgKHBhdGggPT09IG5hdGl2ZVBhdGggfHwgIXVzaW5nUG9zaXhTZXAgJiYgcGF0aCA9PT0gdGFyZ2V0UGF0aCkgPyBwYXR0ZXJuIDogbnVsbDsKICAgIH07CiAgfQogIHBhcnNlZFBhdHRlcm4uYWxsUGF0aHMgPSBbKG1hdGNoUGF0aEVuZHMgPyAnKi8nIDogJy4vJykgKyB0YXJnZXRQYXRoXTsKICByZXR1cm4gcGFyc2VkUGF0dGVybjsKfQpmdW5jdGlvbiB0b1JlZ0V4cChwYXR0ZXJuKSB7CiAgdHJ5IHsKICAgIHZhciByZWdFeHAgPSBuZXcgUmVnRXhwKCJeIi5jb25jYXQocGFyc2VSZWdFeHAocGF0dGVybiksICIkIikpOwogICAgcmV0dXJuIGZ1bmN0aW9uIChwYXRoKSB7CiAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSAwOyAvLyByZXNldCBSZWdFeHAgdG8gaXRzIGluaXRpYWwgc3RhdGUgdG8gcmV1c2UgaXQhCiAgICAgIHJldHVybiB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgcmVnRXhwLnRlc3QocGF0aCkgPyBwYXR0ZXJuIDogbnVsbDsKICAgIH07CiAgfSBjYXRjaCAoZXJyb3IpIHsKICAgIHJldHVybiBOVUxMOwogIH0KfQpleHBvcnQgZnVuY3Rpb24gbWF0Y2goYXJnMSwgcGF0aCwgaGFzU2libGluZykgewogIGlmICghYXJnMSB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHsKICAgIHJldHVybiBmYWxzZTsKICB9CiAgcmV0dXJuIHBhcnNlKGFyZzEpKHBhdGgsIHVuZGVmaW5lZCwgaGFzU2libGluZyk7Cn0KZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKGFyZzEpIHsKICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307CiAgaWYgKCFhcmcxKSB7CiAgICByZXR1cm4gRkFMU0U7CiAgfQogIC8vIEdsb2Igd2l0aCBTdHJpbmcKICBpZiAodHlwZW9mIGFyZzEgPT09ICdzdHJpbmcnIHx8IGlzUmVsYXRpdmVQYXR0ZXJuKGFyZzEpKSB7CiAgICB2YXIgcGFyc2VkUGF0dGVybiA9IHBhcnNlUGF0dGVybihhcmcxLCBvcHRpb25zKTsKICAgIGlmIChwYXJzZWRQYXR0ZXJuID09PSBOVUxMKSB7CiAgICAgIHJldHVybiBGQUxTRTsKICAgIH0KICAgIHZhciByZXN1bHRQYXR0ZXJuID0gZnVuY3Rpb24gcmVzdWx0UGF0dGVybihwYXRoLCBiYXNlbmFtZSkgewogICAgICByZXR1cm4gISFwYXJzZWRQYXR0ZXJuKHBhdGgsIGJhc2VuYW1lKTsKICAgIH07CiAgICBpZiAocGFyc2VkUGF0dGVybi5hbGxCYXNlbmFtZXMpIHsKICAgICAgcmVzdWx0UGF0dGVybi5hbGxCYXNlbmFtZXMgPSBwYXJzZWRQYXR0ZXJuLmFsbEJhc2VuYW1lczsKICAgIH0KICAgIGlmIChwYXJzZWRQYXR0ZXJuLmFsbFBhdGhzKSB7CiAgICAgIHJlc3VsdFBhdHRlcm4uYWxsUGF0aHMgPSBwYXJzZWRQYXR0ZXJuLmFsbFBhdGhzOwogICAgfQogICAgcmV0dXJuIHJlc3VsdFBhdHRlcm47CiAgfQogIC8vIEdsb2Igd2l0aCBFeHByZXNzaW9uCiAgcmV0dXJuIHBhcnNlZEV4cHJlc3Npb24oYXJnMSwgb3B0aW9ucyk7Cn0KZXhwb3J0IGZ1bmN0aW9uIGlzUmVsYXRpdmVQYXR0ZXJuKG9iaikgewogIHZhciBycCA9IG9iajsKICBpZiAoIXJwKSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfQogIHJldHVybiB0eXBlb2YgcnAuYmFzZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHJwLnBhdHRlcm4gPT09ICdzdHJpbmcnOwp9CmZ1bmN0aW9uIHBhcnNlZEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgb3B0aW9ucykgewogIHZhciBwYXJzZWRQYXR0ZXJucyA9IGFnZ3JlZ2F0ZUJhc2VuYW1lTWF0Y2hlcyhPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhleHByZXNzaW9uKS5tYXAoZnVuY3Rpb24gKHBhdHRlcm4pIHsKICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb25QYXR0ZXJuKHBhdHRlcm4sIGV4cHJlc3Npb25bcGF0dGVybl0sIG9wdGlvbnMpOwogIH0pLmZpbHRlcihmdW5jdGlvbiAocGF0dGVybikgewogICAgcmV0dXJuIHBhdHRlcm4gIT09IE5VTEw7CiAgfSkpOwogIHZhciBwYXR0ZXJuc0xlbmd0aCA9IHBhcnNlZFBhdHRlcm5zLmxlbmd0aDsKICBpZiAoIXBhdHRlcm5zTGVuZ3RoKSB7CiAgICByZXR1cm4gTlVMTDsKICB9CiAgaWYgKCFwYXJzZWRQYXR0ZXJucy5zb21lKGZ1bmN0aW9uIChwYXJzZWRQYXR0ZXJuKSB7CiAgICByZXR1cm4gISFwYXJzZWRQYXR0ZXJuLnJlcXVpcmVzU2libGluZ3M7CiAgfSkpIHsKICAgIGlmIChwYXR0ZXJuc0xlbmd0aCA9PT0gMSkgewogICAgICByZXR1cm4gcGFyc2VkUGF0dGVybnNbMF07CiAgICB9CiAgICB2YXIgX3Jlc3VsdEV4cHJlc3Npb24gPSBmdW5jdGlvbiBfcmVzdWx0RXhwcmVzc2lvbihwYXRoLCBiYXNlbmFtZSkgewogICAgICB2YXIgX3RoaXMgPSB0aGlzOwogICAgICB2YXIgcmVzdWx0UHJvbWlzZXMgPSB1bmRlZmluZWQ7CiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcGFyc2VkUGF0dGVybnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7CiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlZFBhdHRlcm5zW2ldKHBhdGgsIGJhc2VuYW1lKTsKICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgIHJldHVybiByZXN1bHQ7IC8vIGltbWVkaWF0ZWx5IHJldHVybiBhcyBzb29uIGFzIHRoZSBmaXJzdCBleHByZXNzaW9uIG1hdGNoZXMKICAgICAgICB9CiAgICAgICAgLy8gSWYgdGhlIHJlc3VsdCBpcyBhIHByb21pc2UsIHdlIGhhdmUgdG8ga2VlcCBpdCBmb3IKICAgICAgICAvLyBsYXRlciBwcm9jZXNzaW5nIGFuZCBhd2FpdCB0aGUgcmVzdWx0IHByb3Blcmx5LgogICAgICAgIGlmIChpc1RoZW5hYmxlKHJlc3VsdCkpIHsKICAgICAgICAgIGlmICghcmVzdWx0UHJvbWlzZXMpIHsKICAgICAgICAgICAgcmVzdWx0UHJvbWlzZXMgPSBbXTsKICAgICAgICAgIH0KICAgICAgICAgIHJlc3VsdFByb21pc2VzLnB1c2gocmVzdWx0KTsKICAgICAgICB9CiAgICAgIH0KICAgICAgLy8gV2l0aCByZXN1bHQgcHJvbWlzZXMsIHdlIGhhdmUgdG8gbG9vcCBvdmVyIGVhY2ggYW5kCiAgICAgIC8vIGF3YWl0IHRoZSByZXN1bHQgYmVmb3JlIHdlIGNhbiByZXR1cm4gYW55IHJlc3VsdC4KICAgICAgaWYgKHJlc3VsdFByb21pc2VzKSB7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHsKICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjMsIF9zdGVwMywgcmVzdWx0UHJvbWlzZSwgX3Jlc3VsdDsKICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7CiAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyZXN1bHRQcm9taXNlcyk7CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE7CiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5zKCk7CiAgICAgICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgICAgICBpZiAoKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lKSB7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZSA9IF9zdGVwMy52YWx1ZTsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNzsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZTsKICAgICAgICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgICAgICAgIF9yZXN1bHQgPSBfY29udGV4dC5zZW50OwogICAgICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiBfcmVzdWx0ID09PSAnc3RyaW5nJykpIHsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCJyZXR1cm4iLCBfcmVzdWx0KTsKICAgICAgICAgICAgICAgICAgY2FzZSAxMDoKICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgY2FzZSAxMjoKICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTc7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE0OwogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbImNhdGNoIl0oMSk7CiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5lKF9jb250ZXh0LnQwKTsKICAgICAgICAgICAgICAgICAgY2FzZSAxNzoKICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTc7CiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgxNyk7CiAgICAgICAgICAgICAgICAgIGNhc2UgMjA6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgicmV0dXJuIiwgbnVsbCk7CiAgICAgICAgICAgICAgICAgIGNhc2UgMjE6CiAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMSwgMTQsIDE3LCAyMF1dKTsKICAgICAgICAgIH0pKTsKICAgICAgICB9KCk7CiAgICAgIH0KICAgICAgcmV0dXJuIG51bGw7CiAgICB9OwogICAgdmFyIF93aXRoQmFzZW5hbWVzID0gcGFyc2VkUGF0dGVybnMuZmluZChmdW5jdGlvbiAocGF0dGVybikgewogICAgICByZXR1cm4gISFwYXR0ZXJuLmFsbEJhc2VuYW1lczsKICAgIH0pOwogICAgaWYgKF93aXRoQmFzZW5hbWVzKSB7CiAgICAgIF9yZXN1bHRFeHByZXNzaW9uLmFsbEJhc2VuYW1lcyA9IF93aXRoQmFzZW5hbWVzLmFsbEJhc2VuYW1lczsKICAgIH0KICAgIHZhciBfYWxsUGF0aHMgPSBwYXJzZWRQYXR0ZXJucy5yZWR1Y2UoZnVuY3Rpb24gKGFsbCwgY3VycmVudCkgewogICAgICByZXR1cm4gY3VycmVudC5hbGxQYXRocyA/IGFsbC5jb25jYXQoY3VycmVudC5hbGxQYXRocykgOiBhbGw7CiAgICB9LCBbXSk7CiAgICBpZiAoX2FsbFBhdGhzLmxlbmd0aCkgewogICAgICBfcmVzdWx0RXhwcmVzc2lvbi5hbGxQYXRocyA9IF9hbGxQYXRoczsKICAgIH0KICAgIHJldHVybiBfcmVzdWx0RXhwcmVzc2lvbjsKICB9CiAgdmFyIHJlc3VsdEV4cHJlc3Npb24gPSBmdW5jdGlvbiByZXN1bHRFeHByZXNzaW9uKHBhdGgsIGJhc2UsIGhhc1NpYmxpbmcpIHsKICAgIHZhciBfdGhpczIgPSB0aGlzOwogICAgdmFyIG5hbWUgPSB1bmRlZmluZWQ7CiAgICB2YXIgcmVzdWx0UHJvbWlzZXMgPSB1bmRlZmluZWQ7CiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBhcnNlZFBhdHRlcm5zLmxlbmd0aDsgaSA8IG47IGkrKykgewogICAgICAvLyBQYXR0ZXJuIG1hdGNoZXMgcGF0aAogICAgICB2YXIgcGFyc2VkUGF0dGVybiA9IHBhcnNlZFBhdHRlcm5zW2ldOwogICAgICBpZiAocGFyc2VkUGF0dGVybi5yZXF1aXJlc1NpYmxpbmdzICYmIGhhc1NpYmxpbmcpIHsKICAgICAgICBpZiAoIWJhc2UpIHsKICAgICAgICAgIGJhc2UgPSBiYXNlbmFtZShwYXRoKTsKICAgICAgICB9CiAgICAgICAgaWYgKCFuYW1lKSB7CiAgICAgICAgICBuYW1lID0gYmFzZS5zdWJzdHIoMCwgYmFzZS5sZW5ndGggLSBleHRuYW1lKHBhdGgpLmxlbmd0aCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIHZhciByZXN1bHQgPSBwYXJzZWRQYXR0ZXJuKHBhdGgsIGJhc2UsIG5hbWUsIGhhc1NpYmxpbmcpOwogICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHsKICAgICAgICByZXR1cm4gcmVzdWx0OyAvLyBpbW1lZGlhdGVseSByZXR1cm4gYXMgc29vbiBhcyB0aGUgZmlyc3QgZXhwcmVzc2lvbiBtYXRjaGVzCiAgICAgIH0KICAgICAgLy8gSWYgdGhlIHJlc3VsdCBpcyBhIHByb21pc2UsIHdlIGhhdmUgdG8ga2VlcCBpdCBmb3IKICAgICAgLy8gbGF0ZXIgcHJvY2Vzc2luZyBhbmQgYXdhaXQgdGhlIHJlc3VsdCBwcm9wZXJseS4KICAgICAgaWYgKGlzVGhlbmFibGUocmVzdWx0KSkgewogICAgICAgIGlmICghcmVzdWx0UHJvbWlzZXMpIHsKICAgICAgICAgIHJlc3VsdFByb21pc2VzID0gW107CiAgICAgICAgfQogICAgICAgIHJlc3VsdFByb21pc2VzLnB1c2gocmVzdWx0KTsKICAgICAgfQogICAgfQogICAgLy8gV2l0aCByZXN1bHQgcHJvbWlzZXMsIHdlIGhhdmUgdG8gbG9vcCBvdmVyIGVhY2ggYW5kCiAgICAvLyBhd2FpdCB0aGUgcmVzdWx0IGJlZm9yZSB3ZSBjYW4gcmV0dXJuIGFueSByZXN1bHQuCiAgICBpZiAocmVzdWx0UHJvbWlzZXMpIHsKICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gX19hd2FpdGVyKF90aGlzMiwgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHsKICAgICAgICAgIHZhciBfaXRlcmF0b3I0LCBfc3RlcDQsIHJlc3VsdFByb21pc2UsIF9yZXN1bHQyOwogICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHsKICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHsKICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJlc3VsdFByb21pc2VzKTsKICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxOwogICAgICAgICAgICAgICAgICBfaXRlcmF0b3I0LnMoKTsKICAgICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgICAgaWYgKChfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZSkgewogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZSA9IF9zdGVwNC52YWx1ZTsKICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3OwogICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZTsKICAgICAgICAgICAgICAgIGNhc2UgNzoKICAgICAgICAgICAgICAgICAgX3Jlc3VsdDIgPSBfY29udGV4dDIuc2VudDsKICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIF9yZXN1bHQyID09PSAnc3RyaW5nJykpIHsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KCJyZXR1cm4iLCBfcmVzdWx0Mik7CiAgICAgICAgICAgICAgICBjYXNlIDEwOgogICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAxMjoKICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNzsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlIDE0OgogICAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE0OwogICAgICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbImNhdGNoIl0oMSk7CiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjQuZShfY29udGV4dDIudDApOwogICAgICAgICAgICAgICAgY2FzZSAxNzoKICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxNzsKICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7CiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDE3KTsKICAgICAgICAgICAgICAgIGNhc2UgMjA6CiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KCJyZXR1cm4iLCBudWxsKTsKICAgICAgICAgICAgICAgIGNhc2UgMjE6CiAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0sIF9jYWxsZWUyLCBudWxsLCBbWzEsIDE0LCAxNywgMjBdXSk7CiAgICAgICAgfSkpOwogICAgICB9KCk7CiAgICB9CiAgICByZXR1cm4gbnVsbDsKICB9OwogIHZhciB3aXRoQmFzZW5hbWVzID0gcGFyc2VkUGF0dGVybnMuZmluZChmdW5jdGlvbiAocGF0dGVybikgewogICAgcmV0dXJuICEhcGF0dGVybi5hbGxCYXNlbmFtZXM7CiAgfSk7CiAgaWYgKHdpdGhCYXNlbmFtZXMpIHsKICAgIHJlc3VsdEV4cHJlc3Npb24uYWxsQmFzZW5hbWVzID0gd2l0aEJhc2VuYW1lcy5hbGxCYXNlbmFtZXM7CiAgfQogIHZhciBhbGxQYXRocyA9IHBhcnNlZFBhdHRlcm5zLnJlZHVjZShmdW5jdGlvbiAoYWxsLCBjdXJyZW50KSB7CiAgICByZXR1cm4gY3VycmVudC5hbGxQYXRocyA/IGFsbC5jb25jYXQoY3VycmVudC5hbGxQYXRocykgOiBhbGw7CiAgfSwgW10pOwogIGlmIChhbGxQYXRocy5sZW5ndGgpIHsKICAgIHJlc3VsdEV4cHJlc3Npb24uYWxsUGF0aHMgPSBhbGxQYXRoczsKICB9CiAgcmV0dXJuIHJlc3VsdEV4cHJlc3Npb247Cn0KZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uUGF0dGVybihwYXR0ZXJuLCB2YWx1ZSwgb3B0aW9ucykgewogIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHsKICAgIHJldHVybiBOVUxMOyAvLyBwYXR0ZXJuIGlzIGRpc2FibGVkCiAgfQoKICB2YXIgcGFyc2VkUGF0dGVybiA9IHBhcnNlUGF0dGVybihwYXR0ZXJuLCBvcHRpb25zKTsKICBpZiAocGFyc2VkUGF0dGVybiA9PT0gTlVMTCkgewogICAgcmV0dXJuIE5VTEw7CiAgfQogIC8vIEV4cHJlc3Npb24gUGF0dGVybiBpcyA8Ym9vbGVhbj4KICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHsKICAgIHJldHVybiBwYXJzZWRQYXR0ZXJuOwogIH0KICAvLyBFeHByZXNzaW9uIFBhdHRlcm4gaXMgPFNpYmxpbmdDbGF1c2U+CiAgaWYgKHZhbHVlKSB7CiAgICB2YXIgd2hlbiA9IHZhbHVlLndoZW47CiAgICBpZiAodHlwZW9mIHdoZW4gPT09ICdzdHJpbmcnKSB7CiAgICAgIHZhciByZXN1bHQgPSBmdW5jdGlvbiByZXN1bHQocGF0aCwgYmFzZW5hbWUsIG5hbWUsIGhhc1NpYmxpbmcpIHsKICAgICAgICBpZiAoIWhhc1NpYmxpbmcgfHwgIXBhcnNlZFBhdHRlcm4ocGF0aCwgYmFzZW5hbWUpKSB7CiAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9CiAgICAgICAgdmFyIGNsYXVzZVBhdHRlcm4gPSB3aGVuLnJlcGxhY2UoJyQoYmFzZW5hbWUpJywgbmFtZSk7CiAgICAgICAgdmFyIG1hdGNoZWQgPSBoYXNTaWJsaW5nKGNsYXVzZVBhdHRlcm4pOwogICAgICAgIHJldHVybiBpc1RoZW5hYmxlKG1hdGNoZWQpID8gbWF0Y2hlZC50aGVuKGZ1bmN0aW9uIChtYXRjaCkgewogICAgICAgICAgcmV0dXJuIG1hdGNoID8gcGF0dGVybiA6IG51bGw7CiAgICAgICAgfSkgOiBtYXRjaGVkID8gcGF0dGVybiA6IG51bGw7CiAgICAgIH07CiAgICAgIHJlc3VsdC5yZXF1aXJlc1NpYmxpbmdzID0gdHJ1ZTsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICB9CiAgLy8gRXhwcmVzc2lvbiBpcyBhbnl0aGluZwogIHJldHVybiBwYXJzZWRQYXR0ZXJuOwp9CmZ1bmN0aW9uIGFnZ3JlZ2F0ZUJhc2VuYW1lTWF0Y2hlcyhwYXJzZWRQYXR0ZXJucywgcmVzdWx0KSB7CiAgdmFyIGJhc2VuYW1lUGF0dGVybnMgPSBwYXJzZWRQYXR0ZXJucy5maWx0ZXIoZnVuY3Rpb24gKHBhcnNlZFBhdHRlcm4pIHsKICAgIHJldHVybiAhIXBhcnNlZFBhdHRlcm4uYmFzZW5hbWVzOwogIH0pOwogIGlmIChiYXNlbmFtZVBhdHRlcm5zLmxlbmd0aCA8IDIpIHsKICAgIHJldHVybiBwYXJzZWRQYXR0ZXJuczsKICB9CiAgdmFyIGJhc2VuYW1lcyA9IGJhc2VuYW1lUGF0dGVybnMucmVkdWNlKGZ1bmN0aW9uIChhbGwsIGN1cnJlbnQpIHsKICAgIHZhciBiYXNlbmFtZXMgPSBjdXJyZW50LmJhc2VuYW1lczsKICAgIHJldHVybiBiYXNlbmFtZXMgPyBhbGwuY29uY2F0KGJhc2VuYW1lcykgOiBhbGw7CiAgfSwgW10pOwogIHZhciBwYXR0ZXJuczsKICBpZiAocmVzdWx0KSB7CiAgICBwYXR0ZXJucyA9IFtdOwogICAgZm9yICh2YXIgaSA9IDAsIG4gPSBiYXNlbmFtZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7CiAgICAgIHBhdHRlcm5zLnB1c2gocmVzdWx0KTsKICAgIH0KICB9IGVsc2UgewogICAgcGF0dGVybnMgPSBiYXNlbmFtZVBhdHRlcm5zLnJlZHVjZShmdW5jdGlvbiAoYWxsLCBjdXJyZW50KSB7CiAgICAgIHZhciBwYXR0ZXJucyA9IGN1cnJlbnQucGF0dGVybnM7CiAgICAgIHJldHVybiBwYXR0ZXJucyA/IGFsbC5jb25jYXQocGF0dGVybnMpIDogYWxsOwogICAgfSwgW10pOwogIH0KICB2YXIgYWdncmVnYXRlID0gZnVuY3Rpb24gYWdncmVnYXRlKHBhdGgsIGJhc2VuYW1lKSB7CiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgaWYgKCFiYXNlbmFtZSkgewogICAgICB2YXIgX2k7CiAgICAgIGZvciAoX2kgPSBwYXRoLmxlbmd0aDsgX2kgPiAwOyBfaS0tKSB7CiAgICAgICAgdmFyIGNoID0gcGF0aC5jaGFyQ29kZUF0KF9pIC0gMSk7CiAgICAgICAgaWYgKGNoID09PSA0NyAvKiBDaGFyQ29kZS5TbGFzaCAqLyB8fCBjaCA9PT0gOTIgLyogQ2hhckNvZGUuQmFja3NsYXNoICovKSB7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIH0KICAgICAgYmFzZW5hbWUgPSBwYXRoLnN1YnN0cihfaSk7CiAgICB9CiAgICB2YXIgaW5kZXggPSBiYXNlbmFtZXMuaW5kZXhPZihiYXNlbmFtZSk7CiAgICByZXR1cm4gaW5kZXggIT09IC0xID8gcGF0dGVybnNbaW5kZXhdIDogbnVsbDsKICB9OwogIGFnZ3JlZ2F0ZS5iYXNlbmFtZXMgPSBiYXNlbmFtZXM7CiAgYWdncmVnYXRlLnBhdHRlcm5zID0gcGF0dGVybnM7CiAgYWdncmVnYXRlLmFsbEJhc2VuYW1lcyA9IGJhc2VuYW1lczsKICB2YXIgYWdncmVnYXRlZFBhdHRlcm5zID0gcGFyc2VkUGF0dGVybnMuZmlsdGVyKGZ1bmN0aW9uIChwYXJzZWRQYXR0ZXJuKSB7CiAgICByZXR1cm4gIXBhcnNlZFBhdHRlcm4uYmFzZW5hbWVzOwogIH0pOwogIGFnZ3JlZ2F0ZWRQYXR0ZXJucy5wdXNoKGFnZ3JlZ2F0ZSk7CiAgcmV0dXJuIGFnZ3JlZ2F0ZWRQYXR0ZXJuczsKfQ=="},{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","isThenable","isEqualOrParent","LRUCache","basename","extname","posix","sep","isLinux","escapeRegExpCharacters","GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","isLastPattern","splitGlobAware","pattern","splitChar","segments","inBraces","inBrackets","curVal","char","push","parseRegExp","regEx","every","segment","previousSegmentWasGlobStar","forEach","index","length","braceVal","bracketVal","res","choices","braceRegExp","map","choice","join","T1","T2","T3","T3_2","T4","T5","CACHE","FALSE","NULL","parsePattern","arg1","options","trim","patternKey","trimForExclusions","parsedPattern","get","wrapRelativePattern","match","test","trivia1","substr","exec","trivia2","trivia3","trivia4and5","toRegExp","set","arg2","wrappedPattern","path","base","allBasenames","allPaths","basenames","patterns","endsWith","slashBase","backslashBase","parsedPatterns","aggregateBasenameMatches","slice","split","filter","patternsLength","i","n","withBasenames","find","reduce","all","current","concat","targetPath","matchPathEnds","usingPosixSep","nativePath","replace","nativePathEnd","targetPathEnd","regExp","RegExp","lastIndex","error","hasSibling","parse","undefined","isRelativePattern","resultPattern","parsedExpression","obj","rp","expression","Object","getOwnPropertyNames","parseExpressionPattern","some","requiresSiblings","resultExpression","resultPromises","resultPromise","name","when","clausePattern","matched","basenamePatterns","aggregate","ch","charCodeAt","indexOf","aggregatedPatterns"],"sources":["/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/base/common/glob.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { isThenable } from './async.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { basename, extname, posix, sep } from './path.js';\nimport { isLinux } from './platform.js';\nimport { escapeRegExpCharacters } from './strings.js';\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount, isLastPattern) {\n    switch (starCount) {\n        case 0:\n            return '';\n        case 1:\n            return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n        default:\n            // Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n            //           in which case also matches (Path Sep followed by Path Val)\n            // Group is non capturing because we don't need to capture at all (?:...)\n            // Overall we use non-greedy matching because it could be that we match too much\n            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n    }\n}\nexport function splitGlobAware(pattern, splitChar) {\n    if (!pattern) {\n        return [];\n    }\n    const segments = [];\n    let inBraces = false;\n    let inBrackets = false;\n    let curVal = '';\n    for (const char of pattern) {\n        switch (char) {\n            case splitChar:\n                if (!inBraces && !inBrackets) {\n                    segments.push(curVal);\n                    curVal = '';\n                    continue;\n                }\n                break;\n            case '{':\n                inBraces = true;\n                break;\n            case '}':\n                inBraces = false;\n                break;\n            case '[':\n                inBrackets = true;\n                break;\n            case ']':\n                inBrackets = false;\n                break;\n        }\n        curVal += char;\n    }\n    // Tail\n    if (curVal) {\n        segments.push(curVal);\n    }\n    return segments;\n}\nfunction parseRegExp(pattern) {\n    if (!pattern) {\n        return '';\n    }\n    let regEx = '';\n    // Split up into segments for each slash found\n    const segments = splitGlobAware(pattern, GLOB_SPLIT);\n    // Special case where we only have globstars\n    if (segments.every(segment => segment === GLOBSTAR)) {\n        regEx = '.*';\n    }\n    // Build regex over segments\n    else {\n        let previousSegmentWasGlobStar = false;\n        segments.forEach((segment, index) => {\n            // Treat globstar specially\n            if (segment === GLOBSTAR) {\n                // if we have more than one globstar after another, just ignore it\n                if (previousSegmentWasGlobStar) {\n                    return;\n                }\n                regEx += starsToRegExp(2, index === segments.length - 1);\n            }\n            // Anything else, not globstar\n            else {\n                // States\n                let inBraces = false;\n                let braceVal = '';\n                let inBrackets = false;\n                let bracketVal = '';\n                for (const char of segment) {\n                    // Support brace expansion\n                    if (char !== '}' && inBraces) {\n                        braceVal += char;\n                        continue;\n                    }\n                    // Support brackets\n                    if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n                        let res;\n                        // range operator\n                        if (char === '-') {\n                            res = char;\n                        }\n                        // negation operator (only valid on first index in bracket)\n                        else if ((char === '^' || char === '!') && !bracketVal) {\n                            res = '^';\n                        }\n                        // glob split matching is not allowed within character ranges\n                        // see http://man7.org/linux/man-pages/man7/glob.7.html\n                        else if (char === GLOB_SPLIT) {\n                            res = '';\n                        }\n                        // anything else gets escaped\n                        else {\n                            res = escapeRegExpCharacters(char);\n                        }\n                        bracketVal += res;\n                        continue;\n                    }\n                    switch (char) {\n                        case '{':\n                            inBraces = true;\n                            continue;\n                        case '[':\n                            inBrackets = true;\n                            continue;\n                        case '}': {\n                            const choices = splitGlobAware(braceVal, ',');\n                            // Converts {foo,bar} => [foo|bar]\n                            const braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n                            regEx += braceRegExp;\n                            inBraces = false;\n                            braceVal = '';\n                            break;\n                        }\n                        case ']': {\n                            regEx += ('[' + bracketVal + ']');\n                            inBrackets = false;\n                            bracketVal = '';\n                            break;\n                        }\n                        case '?':\n                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n                            continue;\n                        case '*':\n                            regEx += starsToRegExp(1);\n                            continue;\n                        default:\n                            regEx += escapeRegExpCharacters(char);\n                    }\n                }\n                // Tail: Add the slash we had split on if there is more to\n                // come and the remaining pattern is not a globstar\n                // For example if pattern: some/**/*.js we want the \"/\" after\n                // some to be included in the RegEx to prevent a folder called\n                // \"something\" to match as well.\n                if (index < segments.length - 1 && // more segments to come after this\n                    (segments[index + 1] !== GLOBSTAR || // next segment is not **, or...\n                        index + 2 < segments.length // ...next segment is ** but there is more segments after that\n                    )) {\n                    regEx += PATH_REGEX;\n                }\n            }\n            // update globstar state\n            previousSegmentWasGlobStar = (segment === GLOBSTAR);\n        });\n    }\n    return regEx;\n}\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\nconst FALSE = function () {\n    return false;\n};\nconst NULL = function () {\n    return null;\n};\nfunction parsePattern(arg1, options) {\n    if (!arg1) {\n        return NULL;\n    }\n    // Handle relative patterns\n    let pattern;\n    if (typeof arg1 !== 'string') {\n        pattern = arg1.pattern;\n    }\n    else {\n        pattern = arg1;\n    }\n    // Whitespace trimming\n    pattern = pattern.trim();\n    // Check cache\n    const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n    let parsedPattern = CACHE.get(patternKey);\n    if (parsedPattern) {\n        return wrapRelativePattern(parsedPattern, arg1);\n    }\n    // Check for Trivials\n    let match;\n    if (T1.test(pattern)) {\n        parsedPattern = trivia1(pattern.substr(4), pattern); // common pattern: **/*.txt just need endsWith check\n    }\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n        parsedPattern = trivia2(match[1], pattern);\n    }\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n        parsedPattern = trivia3(pattern, options);\n    }\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n    }\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n        parsedPattern = trivia4and5(match[1], pattern, false);\n    }\n    // Otherwise convert to pattern\n    else {\n        parsedPattern = toRegExp(pattern);\n    }\n    // Cache\n    CACHE.set(patternKey, parsedPattern);\n    return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n    if (typeof arg2 === 'string') {\n        return parsedPattern;\n    }\n    const wrappedPattern = function (path, basename) {\n        if (!isEqualOrParent(path, arg2.base, !isLinux)) {\n            // skip glob matching if `base` is not a parent of `path`\n            return null;\n        }\n        // Given we have checked `base` being a parent of `path`,\n        // we can now remove the `base` portion of the `path`\n        // and only match on the remaining path components\n        return parsedPattern(path.substr(arg2.base.length + 1), basename);\n    };\n    // Make sure to preserve associated metadata\n    wrappedPattern.allBasenames = parsedPattern.allBasenames;\n    wrappedPattern.allPaths = parsedPattern.allPaths;\n    wrappedPattern.basenames = parsedPattern.basenames;\n    wrappedPattern.patterns = parsedPattern.patterns;\n    return wrappedPattern;\n}\nfunction trimForExclusions(pattern, options) {\n    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base, pattern) {\n    return function (path, basename) {\n        return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n    };\n}\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base, pattern) {\n    const slashBase = `/${base}`;\n    const backslashBase = `\\\\${base}`;\n    const parsedPattern = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (basename) {\n            return basename === base ? pattern : null;\n        }\n        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n    };\n    const basenames = [base];\n    parsedPattern.basenames = basenames;\n    parsedPattern.patterns = [pattern];\n    parsedPattern.allBasenames = basenames;\n    return parsedPattern;\n}\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern, options) {\n    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n        .split(',')\n        .map(pattern => parsePattern(pattern, options))\n        .filter(pattern => pattern !== NULL), pattern);\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (patternsLength === 1) {\n        return parsedPatterns[0];\n    }\n    const parsedPattern = function (path, basename) {\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            if (parsedPatterns[i](path, basename)) {\n                return pattern;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        parsedPattern.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        parsedPattern.allPaths = allPaths;\n    }\n    return parsedPattern;\n}\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n    const usingPosixSep = sep === posix.sep;\n    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n    const nativePathEnd = sep + nativePath;\n    const targetPathEnd = posix.sep + targetPath;\n    let parsedPattern;\n    if (matchPathEnds) {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n        };\n    }\n    else {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n        };\n    }\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n    return parsedPattern;\n}\nfunction toRegExp(pattern) {\n    try {\n        const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n        return function (path) {\n            regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n            return typeof path === 'string' && regExp.test(path) ? pattern : null;\n        };\n    }\n    catch (error) {\n        return NULL;\n    }\n}\nexport function match(arg1, path, hasSibling) {\n    if (!arg1 || typeof path !== 'string') {\n        return false;\n    }\n    return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1, options = {}) {\n    if (!arg1) {\n        return FALSE;\n    }\n    // Glob with String\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n        const parsedPattern = parsePattern(arg1, options);\n        if (parsedPattern === NULL) {\n            return FALSE;\n        }\n        const resultPattern = function (path, basename) {\n            return !!parsedPattern(path, basename);\n        };\n        if (parsedPattern.allBasenames) {\n            resultPattern.allBasenames = parsedPattern.allBasenames;\n        }\n        if (parsedPattern.allPaths) {\n            resultPattern.allPaths = parsedPattern.allPaths;\n        }\n        return resultPattern;\n    }\n    // Glob with Expression\n    return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n    const rp = obj;\n    if (!rp) {\n        return false;\n    }\n    return typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n        .filter(pattern => pattern !== NULL));\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\n        if (patternsLength === 1) {\n            return parsedPatterns[0];\n        }\n        const resultExpression = function (path, basename) {\n            let resultPromises = undefined;\n            for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n                const result = parsedPatterns[i](path, basename);\n                if (typeof result === 'string') {\n                    return result; // immediately return as soon as the first expression matches\n                }\n                // If the result is a promise, we have to keep it for\n                // later processing and await the result properly.\n                if (isThenable(result)) {\n                    if (!resultPromises) {\n                        resultPromises = [];\n                    }\n                    resultPromises.push(result);\n                }\n            }\n            // With result promises, we have to loop over each and\n            // await the result before we can return any result.\n            if (resultPromises) {\n                return (() => __awaiter(this, void 0, void 0, function* () {\n                    for (const resultPromise of resultPromises) {\n                        const result = yield resultPromise;\n                        if (typeof result === 'string') {\n                            return result;\n                        }\n                    }\n                    return null;\n                }))();\n            }\n            return null;\n        };\n        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n        if (withBasenames) {\n            resultExpression.allBasenames = withBasenames.allBasenames;\n        }\n        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n        if (allPaths.length) {\n            resultExpression.allPaths = allPaths;\n        }\n        return resultExpression;\n    }\n    const resultExpression = function (path, base, hasSibling) {\n        let name = undefined;\n        let resultPromises = undefined;\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            // Pattern matches path\n            const parsedPattern = parsedPatterns[i];\n            if (parsedPattern.requiresSiblings && hasSibling) {\n                if (!base) {\n                    base = basename(path);\n                }\n                if (!name) {\n                    name = base.substr(0, base.length - extname(path).length);\n                }\n            }\n            const result = parsedPattern(path, base, name, hasSibling);\n            if (typeof result === 'string') {\n                return result; // immediately return as soon as the first expression matches\n            }\n            // If the result is a promise, we have to keep it for\n            // later processing and await the result properly.\n            if (isThenable(result)) {\n                if (!resultPromises) {\n                    resultPromises = [];\n                }\n                resultPromises.push(result);\n            }\n        }\n        // With result promises, we have to loop over each and\n        // await the result before we can return any result.\n        if (resultPromises) {\n            return (() => __awaiter(this, void 0, void 0, function* () {\n                for (const resultPromise of resultPromises) {\n                    const result = yield resultPromise;\n                    if (typeof result === 'string') {\n                        return result;\n                    }\n                }\n                return null;\n            }))();\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n    if (value === false) {\n        return NULL; // pattern is disabled\n    }\n    const parsedPattern = parsePattern(pattern, options);\n    if (parsedPattern === NULL) {\n        return NULL;\n    }\n    // Expression Pattern is <boolean>\n    if (typeof value === 'boolean') {\n        return parsedPattern;\n    }\n    // Expression Pattern is <SiblingClause>\n    if (value) {\n        const when = value.when;\n        if (typeof when === 'string') {\n            const result = (path, basename, name, hasSibling) => {\n                if (!hasSibling || !parsedPattern(path, basename)) {\n                    return null;\n                }\n                const clausePattern = when.replace('$(basename)', name);\n                const matched = hasSibling(clausePattern);\n                return isThenable(matched) ?\n                    matched.then(match => match ? pattern : null) :\n                    matched ? pattern : null;\n            };\n            result.requiresSiblings = true;\n            return result;\n        }\n    }\n    // Expression is anything\n    return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n    if (basenamePatterns.length < 2) {\n        return parsedPatterns;\n    }\n    const basenames = basenamePatterns.reduce((all, current) => {\n        const basenames = current.basenames;\n        return basenames ? all.concat(basenames) : all;\n    }, []);\n    let patterns;\n    if (result) {\n        patterns = [];\n        for (let i = 0, n = basenames.length; i < n; i++) {\n            patterns.push(result);\n        }\n    }\n    else {\n        patterns = basenamePatterns.reduce((all, current) => {\n            const patterns = current.patterns;\n            return patterns ? all.concat(patterns) : all;\n        }, []);\n    }\n    const aggregate = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (!basename) {\n            let i;\n            for (i = path.length; i > 0; i--) {\n                const ch = path.charCodeAt(i - 1);\n                if (ch === 47 /* CharCode.Slash */ || ch === 92 /* CharCode.Backslash */) {\n                    break;\n                }\n            }\n            basename = path.substr(i);\n        }\n        const index = basenames.indexOf(basename);\n        return index !== -1 ? patterns[index] : null;\n    };\n    aggregate.basenames = basenames;\n    aggregate.patterns = patterns;\n    aggregate.allBasenames = basenames;\n    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n    aggregatedPatterns.push(aggregate);\n    return aggregatedPatterns;\n}\n"],"mappings":"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"}]}