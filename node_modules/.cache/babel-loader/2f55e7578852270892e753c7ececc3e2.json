{"remainingRequest":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/thread-loader/dist/cjs.js!/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js!/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchCompile.js","dependencies":[{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchCompile.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/babel.config.js","mtime":1668271197000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js","mtime":456789000000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF90eXBlb2YgZnJvbSAiL1VzZXJzL3lhbmppYWppYS9EZXNrdG9wL3dvcmtzcGFjZS9hdnVlLWRhdGEtbmV3L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YuanMiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIi9Vc2Vycy95YW5qaWFqaWEvRGVza3RvcC93b3Jrc3BhY2UvYXZ1ZS1kYXRhLW5ldy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanMiOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIi9Vc2Vycy95YW5qaWFqaWEvRGVza3RvcC93b3Jrc3BhY2UvYXZ1ZS1kYXRhLW5ldy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanMiOwppbXBvcnQgX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIgZnJvbSAiL1VzZXJzL3lhbmppYWppYS9EZXNrdG9wL3dvcmtzcGFjZS9hdnVlLWRhdGEtbmV3L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5kb3QtYWxsLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnN0aWNreS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS51bnNoaWZ0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLm1hdGNoLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRlc3QuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5wdXNoLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmVycm9yLmNhdXNlLmpzIjsKLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi4KICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovCi8qCiAqIFRoaXMgbW9kdWxlIG9ubHkgZXhwb3J0cyAnY29tcGlsZScgd2hpY2ggY29tcGlsZXMgYSBKU09OIGxhbmd1YWdlIGRlZmluaXRpb24KICogaW50byBhIHR5cGVkIGFuZCBjaGVja2VkIElMZXhlciBkZWZpbml0aW9uLgogKi8KaW1wb3J0ICogYXMgbW9uYXJjaENvbW1vbiBmcm9tICcuL21vbmFyY2hDb21tb24uanMnOwovKgogKiBUeXBlIGhlbHBlcnMKICoKICogTm90ZTogdGhpcyBpcyBqdXN0IGZvciBzYW5pdHkgY2hlY2tzIG9uIHRoZSBKU09OIGRlc2NyaXB0aW9uIHdoaWNoIGlzCiAqIGhlbHBmdWwgZm9yIHRoZSBwcm9ncmFtbWVyLiBObyBjaGVja3MgYXJlIGRvbmUgYW55bW9yZSBvbmNlIHRoZSBsZXhlciBpcwogKiBhbHJlYWR5ICdjb21waWxlZCBhbmQgY2hlY2tlZCcuCiAqCiAqLwpmdW5jdGlvbiBpc0FycmF5T2YoZWxlbVR5cGUsIG9iaikgewogIGlmICghb2JqKSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfQogIGlmICghQXJyYXkuaXNBcnJheShvYmopKSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfQogIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvYmopLAogICAgX3N0ZXA7CiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciBlbCA9IF9zdGVwLnZhbHVlOwogICAgICBpZiAoIWVsZW1UeXBlKGVsKSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2l0ZXJhdG9yLmUoZXJyKTsKICB9IGZpbmFsbHkgewogICAgX2l0ZXJhdG9yLmYoKTsKICB9CiAgcmV0dXJuIHRydWU7Cn0KZnVuY3Rpb24gYm9vbChwcm9wLCBkZWZWYWx1ZSkgewogIGlmICh0eXBlb2YgcHJvcCA9PT0gJ2Jvb2xlYW4nKSB7CiAgICByZXR1cm4gcHJvcDsKICB9CiAgcmV0dXJuIGRlZlZhbHVlOwp9CmZ1bmN0aW9uIHN0cmluZyhwcm9wLCBkZWZWYWx1ZSkgewogIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHsKICAgIHJldHVybiBwcm9wOwogIH0KICByZXR1cm4gZGVmVmFsdWU7Cn0KZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHsKICB2YXIgcmVzdWx0ID0ge307CiAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihhcnJheSksCiAgICBfc3RlcDI7CiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciBlID0gX3N0ZXAyLnZhbHVlOwogICAgICByZXN1bHRbZV0gPSB0cnVlOwogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2l0ZXJhdG9yMi5lKGVycik7CiAgfSBmaW5hbGx5IHsKICAgIF9pdGVyYXRvcjIuZigpOwogIH0KICByZXR1cm4gcmVzdWx0Owp9CmZ1bmN0aW9uIGNyZWF0ZUtleXdvcmRNYXRjaGVyKGFycikgewogIHZhciBjYXNlSW5zZW5zaXRpdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlOwogIGlmIChjYXNlSW5zZW5zaXRpdmUpIHsKICAgIGFyciA9IGFyci5tYXAoZnVuY3Rpb24gKHgpIHsKICAgICAgcmV0dXJuIHgudG9Mb3dlckNhc2UoKTsKICAgIH0pOwogIH0KICB2YXIgaGFzaCA9IGFycmF5VG9IYXNoKGFycik7CiAgaWYgKGNhc2VJbnNlbnNpdGl2ZSkgewogICAgcmV0dXJuIGZ1bmN0aW9uICh3b3JkKSB7CiAgICAgIHJldHVybiBoYXNoW3dvcmQudG9Mb3dlckNhc2UoKV0gIT09IHVuZGVmaW5lZCAmJiBoYXNoLmhhc093blByb3BlcnR5KHdvcmQudG9Mb3dlckNhc2UoKSk7CiAgICB9OwogIH0gZWxzZSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKHdvcmQpIHsKICAgICAgcmV0dXJuIGhhc2hbd29yZF0gIT09IHVuZGVmaW5lZCAmJiBoYXNoLmhhc093blByb3BlcnR5KHdvcmQpOwogICAgfTsKICB9Cn0KLy8gTGV4ZXIgaGVscGVycwovKioKICogQ29tcGlsZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLCBhZGRpbmcgdGhlICdpJyBmbGFnIGlmICdpZ25vcmVDYXNlJyBpcyBzZXQsIGFuZCB0aGUgJ3UnIGZsYWcgaWYgJ3VuaWNvZGUnIGlzIHNldC4KICogQWxzbyByZXBsYWNlcyBAXHcrIG9yIHNlcXVlbmNlcyB3aXRoIHRoZSBjb250ZW50IG9mIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlCiAqIEBcdysgcmVwbGFjZW1lbnQgY2FuIGJlIGF2b2lkZWQgYnkgZXNjYXBpbmcgYEBgIHNpZ25zIHdpdGggYW5vdGhlciBgQGAgc2lnbi4KICogQGV4YW1wbGUgL0BhdHRyLyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIHZhbHVlIG9mIGxleGVyW2F0dHJdCiAqIEBleGFtcGxlIC9AQHRleHQvIHdpbGwgbm90IGJlIHJlcGxhY2VkIGFuZCB3aWxsIGJlY29tZSAvQHRleHQvLgogKi8KZnVuY3Rpb24gY29tcGlsZVJlZ0V4cChsZXhlciwgc3RyKSB7CiAgLy8gQEAgbXVzdCBiZSBpbnRlcnByZXRlZCBhcyBhIGxpdGVyYWwgQCwgc28gd2UgcmVwbGFjZSBhbGwgb2NjdXJlbmNlcyBvZiBAQCB3aXRoIGEgcGxhY2Vob2xkZXIgY2hhcmFjdGVyCiAgc3RyID0gc3RyLnJlcGxhY2UoL0BAL2csICJceDAxIik7CiAgdmFyIG4gPSAwOwogIHZhciBoYWRFeHBhbnNpb247CiAgZG8gewogICAgaGFkRXhwYW5zaW9uID0gZmFsc2U7CiAgICBzdHIgPSBzdHIucmVwbGFjZSgvQChcdyspL2csIGZ1bmN0aW9uIChzLCBhdHRyKSB7CiAgICAgIGhhZEV4cGFuc2lvbiA9IHRydWU7CiAgICAgIHZhciBzdWIgPSAnJzsKICAgICAgaWYgKHR5cGVvZiBsZXhlclthdHRyXSA9PT0gJ3N0cmluZycpIHsKICAgICAgICBzdWIgPSBsZXhlclthdHRyXTsKICAgICAgfSBlbHNlIGlmIChsZXhlclthdHRyXSAmJiBsZXhlclthdHRyXSBpbnN0YW5jZW9mIFJlZ0V4cCkgewogICAgICAgIHN1YiA9IGxleGVyW2F0dHJdLnNvdXJjZTsKICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAobGV4ZXJbYXR0cl0gPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgdGhyb3cgbW9uYXJjaENvbW1vbi5jcmVhdGVFcnJvcihsZXhlciwgJ2xhbmd1YWdlIGRlZmluaXRpb24gZG9lcyBub3QgY29udGFpbiBhdHRyaWJ1dGUgXCcnICsgYXR0ciArICdcJywgdXNlZCBhdDogJyArIHN0cik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRocm93IG1vbmFyY2hDb21tb24uY3JlYXRlRXJyb3IobGV4ZXIsICdhdHRyaWJ1dGUgcmVmZXJlbmNlIFwnJyArIGF0dHIgKyAnXCcgbXVzdCBiZSBhIHN0cmluZywgdXNlZCBhdDogJyArIHN0cik7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBtb25hcmNoQ29tbW9uLmVtcHR5KHN1YikgPyAnJyA6ICcoPzonICsgc3ViICsgJyknOwogICAgfSk7CiAgICBuKys7CiAgfSB3aGlsZSAoaGFkRXhwYW5zaW9uICYmIG4gPCA1KTsKICAvLyBoYW5kbGUgZXNjYXBlZCBAQAogIHN0ciA9IHN0ci5yZXBsYWNlKC9ceDAxL2csICdAJyk7CiAgdmFyIGZsYWdzID0gKGxleGVyLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgKyAobGV4ZXIudW5pY29kZSA/ICd1JyA6ICcnKTsKICByZXR1cm4gbmV3IFJlZ0V4cChzdHIsIGZsYWdzKTsKfQovKioKICogQ29tcGlsZXMgZ3VhcmQgZnVuY3Rpb25zIGZvciBjYXNlIG1hdGNoZXMuCiAqIFRoaXMgY29tcGlsZXMgJ2Nhc2VzJyBhdHRyaWJ1dGVzIGludG8gZWZmaWNpZW50IG1hdGNoIGZ1bmN0aW9ucy4KICoKICovCmZ1bmN0aW9uIHNlbGVjdFNjcnV0aW5lZShpZCwgbWF0Y2hlcywgc3RhdGUsIG51bSkgewogIGlmIChudW0gPCAwKSB7CiAgICByZXR1cm4gaWQ7CiAgfQogIGlmIChudW0gPCBtYXRjaGVzLmxlbmd0aCkgewogICAgcmV0dXJuIG1hdGNoZXNbbnVtXTsKICB9CiAgaWYgKG51bSA+PSAxMDApIHsKICAgIG51bSA9IG51bSAtIDEwMDsKICAgIHZhciBwYXJ0cyA9IHN0YXRlLnNwbGl0KCcuJyk7CiAgICBwYXJ0cy51bnNoaWZ0KHN0YXRlKTsKICAgIGlmIChudW0gPCBwYXJ0cy5sZW5ndGgpIHsKICAgICAgcmV0dXJuIHBhcnRzW251bV07CiAgICB9CiAgfQogIHJldHVybiBudWxsOwp9CmZ1bmN0aW9uIGNyZWF0ZUd1YXJkKGxleGVyLCBydWxlTmFtZSwgdGtleSwgdmFsKSB7CiAgLy8gZ2V0IHRoZSBzY3J1dGluZWUgYW5kIHBhdHRlcm4KICB2YXIgc2NydXQgPSAtMTsgLy8gLTE6ICQhLCAwLTk5OiAkbiwgMTAwK246ICRTbgogIHZhciBvcHBhdCA9IHRrZXk7CiAgdmFyIG1hdGNoZXMgPSB0a2V5Lm1hdGNoKC9eXCQoKFtzU10/KShcZFxkPyl8IykoLiopJC8pOwogIGlmIChtYXRjaGVzKSB7CiAgICBpZiAobWF0Y2hlc1szXSkgewogICAgICAvLyBpZiBkaWdpdHMKICAgICAgc2NydXQgPSBwYXJzZUludChtYXRjaGVzWzNdKTsKICAgICAgaWYgKG1hdGNoZXNbMl0pIHsKICAgICAgICBzY3J1dCA9IHNjcnV0ICsgMTAwOyAvLyBpZiBbc1NdIHByZXNlbnQKICAgICAgfQogICAgfQoKICAgIG9wcGF0ID0gbWF0Y2hlc1s0XTsKICB9CiAgLy8gZ2V0IG9wZXJhdG9yCiAgdmFyIG9wID0gJ34nOwogIHZhciBwYXQgPSBvcHBhdDsKICBpZiAoIW9wcGF0IHx8IG9wcGF0Lmxlbmd0aCA9PT0gMCkgewogICAgb3AgPSAnIT0nOwogICAgcGF0ID0gJyc7CiAgfSBlbHNlIGlmICgvXlx3KiQvLnRlc3QocGF0KSkgewogICAgLy8ganVzdCBhIHdvcmQKICAgIG9wID0gJz09JzsKICB9IGVsc2UgewogICAgbWF0Y2hlcyA9IG9wcGF0Lm1hdGNoKC9eKEB8IUB8fnwhfnw9PXwhPSkoLiopJC8pOwogICAgaWYgKG1hdGNoZXMpIHsKICAgICAgb3AgPSBtYXRjaGVzWzFdOwogICAgICBwYXQgPSBtYXRjaGVzWzJdOwogICAgfQogIH0KICAvLyBzZXQgdGhlIHRlc3RlciBmdW5jdGlvbgogIHZhciB0ZXN0ZXI7CiAgLy8gc3BlY2lhbCBjYXNlIGEgcmVnZXhwIHRoYXQgbWF0Y2hlcyBqdXN0IHdvcmRzCiAgaWYgKChvcCA9PT0gJ34nIHx8IG9wID09PSAnIX4nKSAmJiAvXihcd3xcfCkqJC8udGVzdChwYXQpKSB7CiAgICB2YXIgaW5Xb3JkcyA9IGNyZWF0ZUtleXdvcmRNYXRjaGVyKHBhdC5zcGxpdCgnfCcpLCBsZXhlci5pZ25vcmVDYXNlKTsKICAgIHRlc3RlciA9IGZ1bmN0aW9uIHRlc3RlcihzKSB7CiAgICAgIHJldHVybiBvcCA9PT0gJ34nID8gaW5Xb3JkcyhzKSA6ICFpbldvcmRzKHMpOwogICAgfTsKICB9IGVsc2UgaWYgKG9wID09PSAnQCcgfHwgb3AgPT09ICchQCcpIHsKICAgIHZhciB3b3JkcyA9IGxleGVyW3BhdF07CiAgICBpZiAoIXdvcmRzKSB7CiAgICAgIHRocm93IG1vbmFyY2hDb21tb24uY3JlYXRlRXJyb3IobGV4ZXIsICd0aGUgQCBtYXRjaCB0YXJnZXQgXCcnICsgcGF0ICsgJ1wnIGlzIG5vdCBkZWZpbmVkLCBpbiBydWxlOiAnICsgcnVsZU5hbWUpOwogICAgfQogICAgaWYgKCFpc0FycmF5T2YoZnVuY3Rpb24gKGVsZW0pIHsKICAgICAgcmV0dXJuIHR5cGVvZiBlbGVtID09PSAnc3RyaW5nJzsKICAgIH0sIHdvcmRzKSkgewogICAgICB0aHJvdyBtb25hcmNoQ29tbW9uLmNyZWF0ZUVycm9yKGxleGVyLCAndGhlIEAgbWF0Y2ggdGFyZ2V0IFwnJyArIHBhdCArICdcJyBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3MsIGluIHJ1bGU6ICcgKyBydWxlTmFtZSk7CiAgICB9CiAgICB2YXIgX2luV29yZHMgPSBjcmVhdGVLZXl3b3JkTWF0Y2hlcih3b3JkcywgbGV4ZXIuaWdub3JlQ2FzZSk7CiAgICB0ZXN0ZXIgPSBmdW5jdGlvbiB0ZXN0ZXIocykgewogICAgICByZXR1cm4gb3AgPT09ICdAJyA/IF9pbldvcmRzKHMpIDogIV9pbldvcmRzKHMpOwogICAgfTsKICB9IGVsc2UgaWYgKG9wID09PSAnficgfHwgb3AgPT09ICchficpIHsKICAgIGlmIChwYXQuaW5kZXhPZignJCcpIDwgMCkgewogICAgICAvLyBwcmVjb21waWxlIHJlZ3VsYXIgZXhwcmVzc2lvbgogICAgICB2YXIgcmUgPSBjb21waWxlUmVnRXhwKGxleGVyLCAnXicgKyBwYXQgKyAnJCcpOwogICAgICB0ZXN0ZXIgPSBmdW5jdGlvbiB0ZXN0ZXIocykgewogICAgICAgIHJldHVybiBvcCA9PT0gJ34nID8gcmUudGVzdChzKSA6ICFyZS50ZXN0KHMpOwogICAgICB9OwogICAgfSBlbHNlIHsKICAgICAgdGVzdGVyID0gZnVuY3Rpb24gdGVzdGVyKHMsIGlkLCBtYXRjaGVzLCBzdGF0ZSkgewogICAgICAgIHZhciByZSA9IGNvbXBpbGVSZWdFeHAobGV4ZXIsICdeJyArIG1vbmFyY2hDb21tb24uc3Vic3RpdHV0ZU1hdGNoZXMobGV4ZXIsIHBhdCwgaWQsIG1hdGNoZXMsIHN0YXRlKSArICckJyk7CiAgICAgICAgcmV0dXJuIHJlLnRlc3Qocyk7CiAgICAgIH07CiAgICB9CiAgfSBlbHNlIHsKICAgIC8vIGlmIChvcD09PSc9PScgfHwgb3A9PT0nIT0nKSB7CiAgICBpZiAocGF0LmluZGV4T2YoJyQnKSA8IDApIHsKICAgICAgdmFyIHBhdHggPSBtb25hcmNoQ29tbW9uLmZpeENhc2UobGV4ZXIsIHBhdCk7CiAgICAgIHRlc3RlciA9IGZ1bmN0aW9uIHRlc3RlcihzKSB7CiAgICAgICAgcmV0dXJuIG9wID09PSAnPT0nID8gcyA9PT0gcGF0eCA6IHMgIT09IHBhdHg7CiAgICAgIH07CiAgICB9IGVsc2UgewogICAgICB2YXIgX3BhdHggPSBtb25hcmNoQ29tbW9uLmZpeENhc2UobGV4ZXIsIHBhdCk7CiAgICAgIHRlc3RlciA9IGZ1bmN0aW9uIHRlc3RlcihzLCBpZCwgbWF0Y2hlcywgc3RhdGUsIGVvcykgewogICAgICAgIHZhciBwYXRleHAgPSBtb25hcmNoQ29tbW9uLnN1YnN0aXR1dGVNYXRjaGVzKGxleGVyLCBfcGF0eCwgaWQsIG1hdGNoZXMsIHN0YXRlKTsKICAgICAgICByZXR1cm4gb3AgPT09ICc9PScgPyBzID09PSBwYXRleHAgOiBzICE9PSBwYXRleHA7CiAgICAgIH07CiAgICB9CiAgfQogIC8vIHJldHVybiB0aGUgYnJhbmNoIG9iamVjdAogIGlmIChzY3J1dCA9PT0gLTEpIHsKICAgIHJldHVybiB7CiAgICAgIG5hbWU6IHRrZXksCiAgICAgIHZhbHVlOiB2YWwsCiAgICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QoaWQsIG1hdGNoZXMsIHN0YXRlLCBlb3MpIHsKICAgICAgICByZXR1cm4gdGVzdGVyKGlkLCBpZCwgbWF0Y2hlcywgc3RhdGUsIGVvcyk7CiAgICAgIH0KICAgIH07CiAgfSBlbHNlIHsKICAgIHJldHVybiB7CiAgICAgIG5hbWU6IHRrZXksCiAgICAgIHZhbHVlOiB2YWwsCiAgICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QoaWQsIG1hdGNoZXMsIHN0YXRlLCBlb3MpIHsKICAgICAgICB2YXIgc2NydXRpbmVlID0gc2VsZWN0U2NydXRpbmVlKGlkLCBtYXRjaGVzLCBzdGF0ZSwgc2NydXQpOwogICAgICAgIHJldHVybiB0ZXN0ZXIoIXNjcnV0aW5lZSA/ICcnIDogc2NydXRpbmVlLCBpZCwgbWF0Y2hlcywgc3RhdGUsIGVvcyk7CiAgICAgIH0KICAgIH07CiAgfQp9Ci8qKgogKiBDb21waWxlcyBhbiBhY3Rpb246IGkuZS4gb3B0aW1pemUgcmVndWxhciBleHByZXNzaW9ucyBhbmQgY2FzZSBtYXRjaGVzCiAqIGFuZCBkbyBtYW55IHNhbml0eSBjaGVja3MuCiAqCiAqIFRoaXMgaXMgY2FsbGVkIG9ubHkgZHVyaW5nIGNvbXBpbGF0aW9uIGJ1dCBpZiB0aGUgbGV4ZXIgZGVmaW5pdGlvbgogKiBjb250YWlucyB1c2VyIGZ1bmN0aW9ucyBhcyBhY3Rpb25zICh3aGljaCBpcyB1c3VhbGx5IG5vdCBhbGxvd2VkKSwgdGhlbiB0aGlzCiAqIG1heSBiZSBjYWxsZWQgZHVyaW5nIGxleGluZy4gSXQgaXMgaW1wb3J0YW50IHRoZXJlZm9yZSB0byBjb21waWxlIGNvbW1vbiBjYXNlcyBlZmZpY2llbnRseQogKi8KZnVuY3Rpb24gY29tcGlsZUFjdGlvbihsZXhlciwgcnVsZU5hbWUsIGFjdGlvbikgewogIGlmICghYWN0aW9uKSB7CiAgICByZXR1cm4gewogICAgICB0b2tlbjogJycKICAgIH07CiAgfSBlbHNlIGlmICh0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJykgewogICAgcmV0dXJuIGFjdGlvbjsgLy8geyB0b2tlbjogYWN0aW9uIH07CiAgfSBlbHNlIGlmIChhY3Rpb24udG9rZW4gfHwgYWN0aW9uLnRva2VuID09PSAnJykgewogICAgaWYgKHR5cGVvZiBhY3Rpb24udG9rZW4gIT09ICdzdHJpbmcnKSB7CiAgICAgIHRocm93IG1vbmFyY2hDb21tb24uY3JlYXRlRXJyb3IobGV4ZXIsICdhIFwndG9rZW5cJyBhdHRyaWJ1dGUgbXVzdCBiZSBvZiB0eXBlIHN0cmluZywgaW4gcnVsZTogJyArIHJ1bGVOYW1lKTsKICAgIH0gZWxzZSB7CiAgICAgIC8vIG9ubHkgY29weSBzcGVjaWZpYyB0eXBlZCBmaWVsZHMgKG9ubHkgaGFwcGVucyBvbmNlIGR1cmluZyBjb21waWxlIExleGVyKQogICAgICB2YXIgbmV3QWN0aW9uID0gewogICAgICAgIHRva2VuOiBhY3Rpb24udG9rZW4KICAgICAgfTsKICAgICAgaWYgKGFjdGlvbi50b2tlbi5pbmRleE9mKCckJykgPj0gMCkgewogICAgICAgIG5ld0FjdGlvbi50b2tlblN1YnN0ID0gdHJ1ZTsKICAgICAgfQogICAgICBpZiAodHlwZW9mIGFjdGlvbi5icmFja2V0ID09PSAnc3RyaW5nJykgewogICAgICAgIGlmIChhY3Rpb24uYnJhY2tldCA9PT0gJ0BvcGVuJykgewogICAgICAgICAgbmV3QWN0aW9uLmJyYWNrZXQgPSAxIC8qIG1vbmFyY2hDb21tb24uTW9uYXJjaEJyYWNrZXQuT3BlbiAqLzsKICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbi5icmFja2V0ID09PSAnQGNsb3NlJykgewogICAgICAgICAgbmV3QWN0aW9uLmJyYWNrZXQgPSAtMSAvKiBtb25hcmNoQ29tbW9uLk1vbmFyY2hCcmFja2V0LkNsb3NlICovOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBtb25hcmNoQ29tbW9uLmNyZWF0ZUVycm9yKGxleGVyLCAnYSBcJ2JyYWNrZXRcJyBhdHRyaWJ1dGUgbXVzdCBiZSBlaXRoZXIgXCdAb3BlblwnIG9yIFwnQGNsb3NlXCcsIGluIHJ1bGU6ICcgKyBydWxlTmFtZSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmIChhY3Rpb24ubmV4dCkgewogICAgICAgIGlmICh0eXBlb2YgYWN0aW9uLm5leHQgIT09ICdzdHJpbmcnKSB7CiAgICAgICAgICB0aHJvdyBtb25hcmNoQ29tbW9uLmNyZWF0ZUVycm9yKGxleGVyLCAndGhlIG5leHQgc3RhdGUgbXVzdCBiZSBhIHN0cmluZyB2YWx1ZSBpbiBydWxlOiAnICsgcnVsZU5hbWUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgbmV4dCA9IGFjdGlvbi5uZXh0OwogICAgICAgICAgaWYgKCEvXihAcG9wfEBwdXNofEBwb3BhbGwpJC8udGVzdChuZXh0KSkgewogICAgICAgICAgICBpZiAobmV4dFswXSA9PT0gJ0AnKSB7CiAgICAgICAgICAgICAgbmV4dCA9IG5leHQuc3Vic3RyKDEpOyAvLyBwZWVsIG9mZiBzdGFydGluZyBAIHNpZ24KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKG5leHQuaW5kZXhPZignJCcpIDwgMCkgewogICAgICAgICAgICAgIC8vIG5vIGRvbGxhciBzdWJzdGl0dXRpb24sIHdlIGNhbiBjaGVjayBpZiB0aGUgc3RhdGUgZXhpc3RzCiAgICAgICAgICAgICAgaWYgKCFtb25hcmNoQ29tbW9uLnN0YXRlRXhpc3RzKGxleGVyLCBtb25hcmNoQ29tbW9uLnN1YnN0aXR1dGVNYXRjaGVzKGxleGVyLCBuZXh0LCAnJywgW10sICcnKSkpIHsKICAgICAgICAgICAgICAgIHRocm93IG1vbmFyY2hDb21tb24uY3JlYXRlRXJyb3IobGV4ZXIsICd0aGUgbmV4dCBzdGF0ZSBcJycgKyBhY3Rpb24ubmV4dCArICdcJyBpcyBub3QgZGVmaW5lZCBpbiBydWxlOiAnICsgcnVsZU5hbWUpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgbmV3QWN0aW9uLm5leHQgPSBuZXh0OwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAodHlwZW9mIGFjdGlvbi5nb0JhY2sgPT09ICdudW1iZXInKSB7CiAgICAgICAgbmV3QWN0aW9uLmdvQmFjayA9IGFjdGlvbi5nb0JhY2s7CiAgICAgIH0KICAgICAgaWYgKHR5cGVvZiBhY3Rpb24uc3dpdGNoVG8gPT09ICdzdHJpbmcnKSB7CiAgICAgICAgbmV3QWN0aW9uLnN3aXRjaFRvID0gYWN0aW9uLnN3aXRjaFRvOwogICAgICB9CiAgICAgIGlmICh0eXBlb2YgYWN0aW9uLmxvZyA9PT0gJ3N0cmluZycpIHsKICAgICAgICBuZXdBY3Rpb24ubG9nID0gYWN0aW9uLmxvZzsKICAgICAgfQogICAgICBpZiAodHlwZW9mIGFjdGlvbi5uZXh0RW1iZWRkZWQgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgbmV3QWN0aW9uLm5leHRFbWJlZGRlZCA9IGFjdGlvbi5uZXh0RW1iZWRkZWQ7CiAgICAgICAgbGV4ZXIudXNlc0VtYmVkZGVkID0gdHJ1ZTsKICAgICAgfQogICAgICByZXR1cm4gbmV3QWN0aW9uOwogICAgfQogIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhY3Rpb24pKSB7CiAgICB2YXIgcmVzdWx0cyA9IFtdOwogICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFjdGlvbi5sZW5ndGg7IGkgPCBsZW47IGkrKykgewogICAgICByZXN1bHRzW2ldID0gY29tcGlsZUFjdGlvbihsZXhlciwgcnVsZU5hbWUsIGFjdGlvbltpXSk7CiAgICB9CiAgICByZXR1cm4gewogICAgICBncm91cDogcmVzdWx0cwogICAgfTsKICB9IGVsc2UgaWYgKGFjdGlvbi5jYXNlcykgewogICAgLy8gYnVpbGQgYW4gYXJyYXkgb2YgdGVzdCBjYXNlcwogICAgdmFyIGNhc2VzID0gW107CiAgICAvLyBmb3IgZWFjaCBjYXNlLCBwdXNoIGEgdGVzdCBmdW5jdGlvbiBhbmQgcmVzdWx0IHZhbHVlCiAgICBmb3IgKHZhciB0a2V5IGluIGFjdGlvbi5jYXNlcykgewogICAgICBpZiAoYWN0aW9uLmNhc2VzLmhhc093blByb3BlcnR5KHRrZXkpKSB7CiAgICAgICAgdmFyIHZhbCA9IGNvbXBpbGVBY3Rpb24obGV4ZXIsIHJ1bGVOYW1lLCBhY3Rpb24uY2FzZXNbdGtleV0pOwogICAgICAgIC8vIHdoYXQga2luZCBvZiBjYXNlCiAgICAgICAgaWYgKHRrZXkgPT09ICdAZGVmYXVsdCcgfHwgdGtleSA9PT0gJ0AnIHx8IHRrZXkgPT09ICcnKSB7CiAgICAgICAgICBjYXNlcy5wdXNoKHsKICAgICAgICAgICAgdGVzdDogdW5kZWZpbmVkLAogICAgICAgICAgICB2YWx1ZTogdmFsLAogICAgICAgICAgICBuYW1lOiB0a2V5CiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgaWYgKHRrZXkgPT09ICdAZW9zJykgewogICAgICAgICAgY2FzZXMucHVzaCh7CiAgICAgICAgICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QoaWQsIG1hdGNoZXMsIHN0YXRlLCBlb3MpIHsKICAgICAgICAgICAgICByZXR1cm4gZW9zOwogICAgICAgICAgICB9LAogICAgICAgICAgICB2YWx1ZTogdmFsLAogICAgICAgICAgICBuYW1lOiB0a2V5CiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY2FzZXMucHVzaChjcmVhdGVHdWFyZChsZXhlciwgcnVsZU5hbWUsIHRrZXksIHZhbCkpOyAvLyBjYWxsIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGF2b2lkIGxvY2FsIHZhcmlhYmxlIGNhcHR1cmUKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8vIGNyZWF0ZSBhIG1hdGNoaW5nIGZ1bmN0aW9uCiAgICB2YXIgZGVmID0gbGV4ZXIuZGVmYXVsdFRva2VuOwogICAgcmV0dXJuIHsKICAgICAgdGVzdDogZnVuY3Rpb24gdGVzdChpZCwgbWF0Y2hlcywgc3RhdGUsIGVvcykgewogICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoY2FzZXMpLAogICAgICAgICAgX3N0ZXAzOwogICAgICAgIHRyeSB7CiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykgewogICAgICAgICAgICB2YXIgX2Nhc2UgPSBfc3RlcDMudmFsdWU7CiAgICAgICAgICAgIHZhciBkaWRtYXRjaCA9ICFfY2FzZS50ZXN0IHx8IF9jYXNlLnRlc3QoaWQsIG1hdGNoZXMsIHN0YXRlLCBlb3MpOwogICAgICAgICAgICBpZiAoZGlkbWF0Y2gpIHsKICAgICAgICAgICAgICByZXR1cm4gX2Nhc2UudmFsdWU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBfaXRlcmF0b3IzLmYoKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGRlZjsKICAgICAgfQogICAgfTsKICB9IGVsc2UgewogICAgdGhyb3cgbW9uYXJjaENvbW1vbi5jcmVhdGVFcnJvcihsZXhlciwgJ2FuIGFjdGlvbiBtdXN0IGJlIGEgc3RyaW5nLCBhbiBvYmplY3Qgd2l0aCBhIFwndG9rZW5cJyBvciBcJ2Nhc2VzXCcgYXR0cmlidXRlLCBvciBhbiBhcnJheSBvZiBhY3Rpb25zOyBpbiBydWxlOiAnICsgcnVsZU5hbWUpOwogIH0KfQovKioKICogSGVscGVyIGNsYXNzIGZvciBjcmVhdGluZyBtYXRjaGluZyBydWxlcwogKi8KdmFyIFJ1bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIGZ1bmN0aW9uIFJ1bGUobmFtZSkgewogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJ1bGUpOwogICAgdGhpcy5yZWdleCA9IG5ldyBSZWdFeHAoJycpOwogICAgdGhpcy5hY3Rpb24gPSB7CiAgICAgIHRva2VuOiAnJwogICAgfTsKICAgIHRoaXMubWF0Y2hPbmx5QXRMaW5lU3RhcnQgPSBmYWxzZTsKICAgIHRoaXMubmFtZSA9ICcnOwogICAgdGhpcy5uYW1lID0gbmFtZTsKICB9CiAgX2NyZWF0ZUNsYXNzKFJ1bGUsIFt7CiAgICBrZXk6ICJzZXRSZWdleCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UmVnZXgobGV4ZXIsIHJlKSB7CiAgICAgIHZhciBzcmVnZXg7CiAgICAgIGlmICh0eXBlb2YgcmUgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgc3JlZ2V4ID0gcmU7CiAgICAgIH0gZWxzZSBpZiAocmUgaW5zdGFuY2VvZiBSZWdFeHApIHsKICAgICAgICBzcmVnZXggPSByZS5zb3VyY2U7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhyb3cgbW9uYXJjaENvbW1vbi5jcmVhdGVFcnJvcihsZXhlciwgJ3J1bGVzIG11c3Qgc3RhcnQgd2l0aCBhIG1hdGNoIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb246ICcgKyB0aGlzLm5hbWUpOwogICAgICB9CiAgICAgIHRoaXMubWF0Y2hPbmx5QXRMaW5lU3RhcnQgPSBzcmVnZXgubGVuZ3RoID4gMCAmJiBzcmVnZXhbMF0gPT09ICdeJzsKICAgICAgdGhpcy5uYW1lID0gdGhpcy5uYW1lICsgJzogJyArIHNyZWdleDsKICAgICAgdGhpcy5yZWdleCA9IGNvbXBpbGVSZWdFeHAobGV4ZXIsICdeKD86JyArICh0aGlzLm1hdGNoT25seUF0TGluZVN0YXJ0ID8gc3JlZ2V4LnN1YnN0cigxKSA6IHNyZWdleCkgKyAnKScpOwogICAgfQogIH0sIHsKICAgIGtleTogInNldEFjdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QWN0aW9uKGxleGVyLCBhY3QpIHsKICAgICAgdGhpcy5hY3Rpb24gPSBjb21waWxlQWN0aW9uKGxleGVyLCB0aGlzLm5hbWUsIGFjdCk7CiAgICB9CiAgfV0pOwogIHJldHVybiBSdWxlOwp9KCk7Ci8qKgogKiBDb21waWxlcyBhIGpzb24gZGVzY3JpcHRpb24gZnVuY3Rpb24gaW50byBqc29uIHdoZXJlIGFsbCByZWd1bGFyIGV4cHJlc3Npb25zLAogKiBjYXNlIG1hdGNoZXMgZXRjLCBhcmUgY29tcGlsZWQgYW5kIGFsbCBpbmNsdWRlIHJ1bGVzIGFyZSBleHBhbmRlZC4KICogV2UgYWxzbyBjb21waWxlIHRoZSBicmFja2V0IGRlZmluaXRpb25zLCBzdXBwbHkgZGVmYXVsdHMsIGFuZCBkbyBtYW55IHNhbml0eSBjaGVja3MuCiAqIElmIHRoZSAnanNvblN0cmljdCcgcGFyYW1ldGVyIGlzICdmYWxzZScsIHdlIGFsbG93IGF0IGNlcnRhaW4gbG9jYXRpb25zCiAqIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3RzIGFuZCBmdW5jdGlvbnMgdGhhdCBnZXQgY2FsbGVkIGR1cmluZyBsZXhpbmcuCiAqIChDdXJyZW50bHkgd2UgaGF2ZSBubyBzYW1wbGVzIHRoYXQgbmVlZCB0aGlzIHNvIHBlcmhhcHMgd2Ugc2hvdWxkIGFsd2F5cyBoYXZlCiAqIGpzb25TdHJpY3QgdG8gdHJ1ZSkuCiAqLwpleHBvcnQgZnVuY3Rpb24gY29tcGlsZShsYW5ndWFnZUlkLCBqc29uKSB7CiAgaWYgKCFqc29uIHx8IF90eXBlb2YoanNvbikgIT09ICdvYmplY3QnKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ01vbmFyY2g6IGV4cGVjdGluZyBhIGxhbmd1YWdlIGRlZmluaXRpb24gb2JqZWN0Jyk7CiAgfQogIC8vIENyZWF0ZSBvdXIgbGV4ZXIKICB2YXIgbGV4ZXIgPSB7fTsKICBsZXhlci5sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDsKICBsZXhlci5pbmNsdWRlTEYgPSBib29sKGpzb24uaW5jbHVkZUxGLCBmYWxzZSk7CiAgbGV4ZXIubm9UaHJvdyA9IGZhbHNlOyAvLyByYWlzZSBleGNlcHRpb25zIGR1cmluZyBjb21waWxhdGlvbgogIGxleGVyLm1heFN0YWNrID0gMTAwOwogIC8vIFNldCBzdGFuZGFyZCBmaWVsZHM6IGJlIGRlZmVuc2l2ZSBhYm91dCB0eXBlcwogIGxleGVyLnN0YXJ0ID0gdHlwZW9mIGpzb24uc3RhcnQgPT09ICdzdHJpbmcnID8ganNvbi5zdGFydCA6IG51bGw7CiAgbGV4ZXIuaWdub3JlQ2FzZSA9IGJvb2woanNvbi5pZ25vcmVDYXNlLCBmYWxzZSk7CiAgbGV4ZXIudW5pY29kZSA9IGJvb2woanNvbi51bmljb2RlLCBmYWxzZSk7CiAgbGV4ZXIudG9rZW5Qb3N0Zml4ID0gc3RyaW5nKGpzb24udG9rZW5Qb3N0Zml4LCAnLicgKyBsZXhlci5sYW5ndWFnZUlkKTsKICBsZXhlci5kZWZhdWx0VG9rZW4gPSBzdHJpbmcoanNvbi5kZWZhdWx0VG9rZW4sICdzb3VyY2UnKTsKICBsZXhlci51c2VzRW1iZWRkZWQgPSBmYWxzZTsgLy8gYmVjb21lcyB0cnVlIGlmIHdlIGZpbmQgYSBuZXh0RW1iZWRkZWQgYWN0aW9uCiAgLy8gRm9yIGNhbGxpbmcgY29tcGlsZUFjdGlvbiBsYXRlciBvbgogIHZhciBsZXhlck1pbiA9IGpzb247CiAgbGV4ZXJNaW4ubGFuZ3VhZ2VJZCA9IGxhbmd1YWdlSWQ7CiAgbGV4ZXJNaW4uaW5jbHVkZUxGID0gbGV4ZXIuaW5jbHVkZUxGOwogIGxleGVyTWluLmlnbm9yZUNhc2UgPSBsZXhlci5pZ25vcmVDYXNlOwogIGxleGVyTWluLnVuaWNvZGUgPSBsZXhlci51bmljb2RlOwogIGxleGVyTWluLm5vVGhyb3cgPSBsZXhlci5ub1Rocm93OwogIGxleGVyTWluLnVzZXNFbWJlZGRlZCA9IGxleGVyLnVzZXNFbWJlZGRlZDsKICBsZXhlck1pbi5zdGF0ZU5hbWVzID0ganNvbi50b2tlbml6ZXI7CiAgbGV4ZXJNaW4uZGVmYXVsdFRva2VuID0gbGV4ZXIuZGVmYXVsdFRva2VuOwogIC8vIENvbXBpbGUgYW4gYXJyYXkgb2YgcnVsZXMgaW50byBuZXdydWxlcyB3aGVyZSBSZWdFeHAgb2JqZWN0cyBhcmUgY3JlYXRlZC4KICBmdW5jdGlvbiBhZGRSdWxlcyhzdGF0ZSwgbmV3cnVsZXMsIHJ1bGVzKSB7CiAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJ1bGVzKSwKICAgICAgX3N0ZXA0OwogICAgdHJ5IHsKICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHsKICAgICAgICB2YXIgcnVsZSA9IF9zdGVwNC52YWx1ZTsKICAgICAgICB2YXIgaW5jbHVkZSA9IHJ1bGUuaW5jbHVkZTsKICAgICAgICBpZiAoaW5jbHVkZSkgewogICAgICAgICAgaWYgKHR5cGVvZiBpbmNsdWRlICE9PSAnc3RyaW5nJykgewogICAgICAgICAgICB0aHJvdyBtb25hcmNoQ29tbW9uLmNyZWF0ZUVycm9yKGxleGVyLCAnYW4gXCdpbmNsdWRlXCcgYXR0cmlidXRlIG11c3QgYmUgYSBzdHJpbmcgYXQ6ICcgKyBzdGF0ZSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaW5jbHVkZVswXSA9PT0gJ0AnKSB7CiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlLnN1YnN0cigxKTsgLy8gcGVlbCBvZmYgc3RhcnRpbmcgQAogICAgICAgICAgfQoKICAgICAgICAgIGlmICghanNvbi50b2tlbml6ZXJbaW5jbHVkZV0pIHsKICAgICAgICAgICAgdGhyb3cgbW9uYXJjaENvbW1vbi5jcmVhdGVFcnJvcihsZXhlciwgJ2luY2x1ZGUgdGFyZ2V0IFwnJyArIGluY2x1ZGUgKyAnXCcgaXMgbm90IGRlZmluZWQgYXQ6ICcgKyBzdGF0ZSk7CiAgICAgICAgICB9CiAgICAgICAgICBhZGRSdWxlcyhzdGF0ZSArICcuJyArIGluY2x1ZGUsIG5ld3J1bGVzLCBqc29uLnRva2VuaXplcltpbmNsdWRlXSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhciBuZXdydWxlID0gbmV3IFJ1bGUoc3RhdGUpOwogICAgICAgICAgLy8gU2V0IHVwIG5ldyBydWxlIGF0dHJpYnV0ZXMKICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJ1bGUpICYmIHJ1bGUubGVuZ3RoID49IDEgJiYgcnVsZS5sZW5ndGggPD0gMykgewogICAgICAgICAgICBuZXdydWxlLnNldFJlZ2V4KGxleGVyTWluLCBydWxlWzBdKTsKICAgICAgICAgICAgaWYgKHJ1bGUubGVuZ3RoID49IDMpIHsKICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGVbMV0gPT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgICAgICBuZXdydWxlLnNldEFjdGlvbihsZXhlck1pbiwgewogICAgICAgICAgICAgICAgICB0b2tlbjogcnVsZVsxXSwKICAgICAgICAgICAgICAgICAgbmV4dDogcnVsZVsyXQogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKHJ1bGVbMV0pID09PSAnb2JqZWN0JykgewogICAgICAgICAgICAgICAgdmFyIHJ1bGUxID0gcnVsZVsxXTsKICAgICAgICAgICAgICAgIHJ1bGUxLm5leHQgPSBydWxlWzJdOwogICAgICAgICAgICAgICAgbmV3cnVsZS5zZXRBY3Rpb24obGV4ZXJNaW4sIHJ1bGUxKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdGhyb3cgbW9uYXJjaENvbW1vbi5jcmVhdGVFcnJvcihsZXhlciwgJ2EgbmV4dCBzdGF0ZSBhcyB0aGUgbGFzdCBlbGVtZW50IG9mIGEgcnVsZSBjYW4gb25seSBiZSBnaXZlbiBpZiB0aGUgYWN0aW9uIGlzIGVpdGhlciBhbiBvYmplY3Qgb3IgYSBzdHJpbmcsIGF0OiAnICsgc3RhdGUpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBuZXdydWxlLnNldEFjdGlvbihsZXhlck1pbiwgcnVsZVsxXSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGlmICghcnVsZS5yZWdleCkgewogICAgICAgICAgICAgIHRocm93IG1vbmFyY2hDb21tb24uY3JlYXRlRXJyb3IobGV4ZXIsICdhIHJ1bGUgbXVzdCBlaXRoZXIgYmUgYW4gYXJyYXksIG9yIGFuIG9iamVjdCB3aXRoIGEgXCdyZWdleFwnIG9yIFwnaW5jbHVkZVwnIGZpZWxkIGF0OiAnICsgc3RhdGUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChydWxlLm5hbWUpIHsKICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUubmFtZSA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgICAgICAgIG5ld3J1bGUubmFtZSA9IHJ1bGUubmFtZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHJ1bGUubWF0Y2hPbmx5QXRTdGFydCkgewogICAgICAgICAgICAgIG5ld3J1bGUubWF0Y2hPbmx5QXRMaW5lU3RhcnQgPSBib29sKHJ1bGUubWF0Y2hPbmx5QXRMaW5lU3RhcnQsIGZhbHNlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBuZXdydWxlLnNldFJlZ2V4KGxleGVyTWluLCBydWxlLnJlZ2V4KTsKICAgICAgICAgICAgbmV3cnVsZS5zZXRBY3Rpb24obGV4ZXJNaW4sIHJ1bGUuYWN0aW9uKTsKICAgICAgICAgIH0KICAgICAgICAgIG5ld3J1bGVzLnB1c2gobmV3cnVsZSk7CiAgICAgICAgfQogICAgICB9CiAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgX2l0ZXJhdG9yNC5lKGVycik7CiAgICB9IGZpbmFsbHkgewogICAgICBfaXRlcmF0b3I0LmYoKTsKICAgIH0KICB9CiAgLy8gY29tcGlsZSB0aGUgdG9rZW5pemVyIHJ1bGVzCiAgaWYgKCFqc29uLnRva2VuaXplciB8fCBfdHlwZW9mKGpzb24udG9rZW5pemVyKSAhPT0gJ29iamVjdCcpIHsKICAgIHRocm93IG1vbmFyY2hDb21tb24uY3JlYXRlRXJyb3IobGV4ZXIsICdhIGxhbmd1YWdlIGRlZmluaXRpb24gbXVzdCBkZWZpbmUgdGhlIFwndG9rZW5pemVyXCcgYXR0cmlidXRlIGFzIGFuIG9iamVjdCcpOwogIH0KICBsZXhlci50b2tlbml6ZXIgPSBbXTsKICBmb3IgKHZhciBrZXkgaW4ganNvbi50b2tlbml6ZXIpIHsKICAgIGlmIChqc29uLnRva2VuaXplci5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7CiAgICAgIGlmICghbGV4ZXIuc3RhcnQpIHsKICAgICAgICBsZXhlci5zdGFydCA9IGtleTsKICAgICAgfQogICAgICB2YXIgcnVsZXMgPSBqc29uLnRva2VuaXplcltrZXldOwogICAgICBsZXhlci50b2tlbml6ZXJba2V5XSA9IG5ldyBBcnJheSgpOwogICAgICBhZGRSdWxlcygndG9rZW5pemVyLicgKyBrZXksIGxleGVyLnRva2VuaXplcltrZXldLCBydWxlcyk7CiAgICB9CiAgfQogIGxleGVyLnVzZXNFbWJlZGRlZCA9IGxleGVyTWluLnVzZXNFbWJlZGRlZDsgLy8gY2FuIGJlIHNldCBkdXJpbmcgY29tcGlsZUFjdGlvbgogIC8vIFNldCBzaW1wbGUgYnJhY2tldHMKICBpZiAoanNvbi5icmFja2V0cykgewogICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24uYnJhY2tldHMpKSB7CiAgICAgIHRocm93IG1vbmFyY2hDb21tb24uY3JlYXRlRXJyb3IobGV4ZXIsICd0aGUgXCdicmFja2V0c1wnIGF0dHJpYnV0ZSBtdXN0IGJlIGRlZmluZWQgYXMgYW4gYXJyYXknKTsKICAgIH0KICB9IGVsc2UgewogICAganNvbi5icmFja2V0cyA9IFt7CiAgICAgIG9wZW46ICd7JywKICAgICAgY2xvc2U6ICd9JywKICAgICAgdG9rZW46ICdkZWxpbWl0ZXIuY3VybHknCiAgICB9LCB7CiAgICAgIG9wZW46ICdbJywKICAgICAgY2xvc2U6ICddJywKICAgICAgdG9rZW46ICdkZWxpbWl0ZXIuc3F1YXJlJwogICAgfSwgewogICAgICBvcGVuOiAnKCcsCiAgICAgIGNsb3NlOiAnKScsCiAgICAgIHRva2VuOiAnZGVsaW1pdGVyLnBhcmVudGhlc2lzJwogICAgfSwgewogICAgICBvcGVuOiAnPCcsCiAgICAgIGNsb3NlOiAnPicsCiAgICAgIHRva2VuOiAnZGVsaW1pdGVyLmFuZ2xlJwogICAgfV07CiAgfQogIHZhciBicmFja2V0cyA9IFtdOwogIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoanNvbi5icmFja2V0cyksCiAgICBfc3RlcDU7CiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciBlbCA9IF9zdGVwNS52YWx1ZTsKICAgICAgdmFyIGRlc2MgPSBlbDsKICAgICAgaWYgKGRlc2MgJiYgQXJyYXkuaXNBcnJheShkZXNjKSAmJiBkZXNjLmxlbmd0aCA9PT0gMykgewogICAgICAgIGRlc2MgPSB7CiAgICAgICAgICB0b2tlbjogZGVzY1syXSwKICAgICAgICAgIG9wZW46IGRlc2NbMF0sCiAgICAgICAgICBjbG9zZTogZGVzY1sxXQogICAgICAgIH07CiAgICAgIH0KICAgICAgaWYgKGRlc2Mub3BlbiA9PT0gZGVzYy5jbG9zZSkgewogICAgICAgIHRocm93IG1vbmFyY2hDb21tb24uY3JlYXRlRXJyb3IobGV4ZXIsICdvcGVuIGFuZCBjbG9zZSBicmFja2V0cyBpbiBhIFwnYnJhY2tldHNcJyBhdHRyaWJ1dGUgbXVzdCBiZSBkaWZmZXJlbnQ6ICcgKyBkZXNjLm9wZW4gKyAnXG4gaGludDogdXNlIHRoZSBcJ2JyYWNrZXRcJyBhdHRyaWJ1dGUgaWYgbWF0Y2hpbmcgb24gZXF1YWwgYnJhY2tldHMgaXMgcmVxdWlyZWQuJyk7CiAgICAgIH0KICAgICAgaWYgKHR5cGVvZiBkZXNjLm9wZW4gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBkZXNjLnRva2VuID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGVzYy5jbG9zZSA9PT0gJ3N0cmluZycpIHsKICAgICAgICBicmFja2V0cy5wdXNoKHsKICAgICAgICAgIHRva2VuOiBkZXNjLnRva2VuICsgbGV4ZXIudG9rZW5Qb3N0Zml4LAogICAgICAgICAgb3BlbjogbW9uYXJjaENvbW1vbi5maXhDYXNlKGxleGVyLCBkZXNjLm9wZW4pLAogICAgICAgICAgY2xvc2U6IG1vbmFyY2hDb21tb24uZml4Q2FzZShsZXhlciwgZGVzYy5jbG9zZSkKICAgICAgICB9KTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBtb25hcmNoQ29tbW9uLmNyZWF0ZUVycm9yKGxleGVyLCAnZXZlcnkgZWxlbWVudCBpbiB0aGUgXCdicmFja2V0c1wnIGFycmF5IG11c3QgYmUgYSBcJ3tvcGVuLGNsb3NlLHRva2VufVwnIG9iamVjdCBvciBhcnJheScpOwogICAgICB9CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfaXRlcmF0b3I1LmUoZXJyKTsKICB9IGZpbmFsbHkgewogICAgX2l0ZXJhdG9yNS5mKCk7CiAgfQogIGxleGVyLmJyYWNrZXRzID0gYnJhY2tldHM7CiAgLy8gRGlzYWJsZSB0aHJvdyBzbyB0aGUgc3ludGF4IGhpZ2hsaWdodGVyIGdvZXMsIG5vIG1hdHRlciB3aGF0CiAgbGV4ZXIubm9UaHJvdyA9IHRydWU7CiAgcmV0dXJuIGxleGVyOwp9"},{"version":3,"names":["monarchCommon","isArrayOf","elemType","obj","Array","isArray","el","bool","prop","defValue","string","arrayToHash","array","result","e","createKeywordMatcher","arr","caseInsensitive","map","x","toLowerCase","hash","word","undefined","hasOwnProperty","compileRegExp","lexer","str","replace","n","hadExpansion","s","attr","sub","RegExp","source","createError","empty","flags","ignoreCase","unicode","selectScrutinee","id","matches","state","num","length","parts","split","unshift","createGuard","ruleName","tkey","val","scrut","oppat","match","parseInt","op","pat","test","tester","inWords","words","elem","indexOf","re","substituteMatches","patx","fixCase","eos","patexp","name","value","scrutinee","compileAction","action","token","newAction","tokenSubst","bracket","next","substr","stateExists","goBack","switchTo","log","nextEmbedded","usesEmbedded","results","i","len","group","cases","push","def","defaultToken","_case","didmatch","Rule","regex","matchOnlyAtLineStart","sregex","act","compile","languageId","json","Error","includeLF","noThrow","maxStack","start","tokenPostfix","lexerMin","stateNames","tokenizer","addRules","newrules","rules","rule","include","newrule","setRegex","setAction","rule1","matchOnlyAtStart","key","brackets","open","close","desc"],"sources":["/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchCompile.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/*\n * This module only exports 'compile' which compiles a JSON language definition\n * into a typed and checked ILexer definition.\n */\nimport * as monarchCommon from './monarchCommon.js';\n/*\n * Type helpers\n *\n * Note: this is just for sanity checks on the JSON description which is\n * helpful for the programmer. No checks are done anymore once the lexer is\n * already 'compiled and checked'.\n *\n */\nfunction isArrayOf(elemType, obj) {\n    if (!obj) {\n        return false;\n    }\n    if (!(Array.isArray(obj))) {\n        return false;\n    }\n    for (const el of obj) {\n        if (!(elemType(el))) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction bool(prop, defValue) {\n    if (typeof prop === 'boolean') {\n        return prop;\n    }\n    return defValue;\n}\nfunction string(prop, defValue) {\n    if (typeof (prop) === 'string') {\n        return prop;\n    }\n    return defValue;\n}\nfunction arrayToHash(array) {\n    const result = {};\n    for (const e of array) {\n        result[e] = true;\n    }\n    return result;\n}\nfunction createKeywordMatcher(arr, caseInsensitive = false) {\n    if (caseInsensitive) {\n        arr = arr.map(function (x) { return x.toLowerCase(); });\n    }\n    const hash = arrayToHash(arr);\n    if (caseInsensitive) {\n        return function (word) {\n            return hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());\n        };\n    }\n    else {\n        return function (word) {\n            return hash[word] !== undefined && hash.hasOwnProperty(word);\n        };\n    }\n}\n// Lexer helpers\n/**\n * Compiles a regular expression string, adding the 'i' flag if 'ignoreCase' is set, and the 'u' flag if 'unicode' is set.\n * Also replaces @\\w+ or sequences with the content of the specified attribute\n * @\\w+ replacement can be avoided by escaping `@` signs with another `@` sign.\n * @example /@attr/ will be replaced with the value of lexer[attr]\n * @example /@@text/ will not be replaced and will become /@text/.\n */\nfunction compileRegExp(lexer, str) {\n    // @@ must be interpreted as a literal @, so we replace all occurences of @@ with a placeholder character\n    str = str.replace(/@@/g, `\\x01`);\n    let n = 0;\n    let hadExpansion;\n    do {\n        hadExpansion = false;\n        str = str.replace(/@(\\w+)/g, function (s, attr) {\n            hadExpansion = true;\n            let sub = '';\n            if (typeof (lexer[attr]) === 'string') {\n                sub = lexer[attr];\n            }\n            else if (lexer[attr] && lexer[attr] instanceof RegExp) {\n                sub = lexer[attr].source;\n            }\n            else {\n                if (lexer[attr] === undefined) {\n                    throw monarchCommon.createError(lexer, 'language definition does not contain attribute \\'' + attr + '\\', used at: ' + str);\n                }\n                else {\n                    throw monarchCommon.createError(lexer, 'attribute reference \\'' + attr + '\\' must be a string, used at: ' + str);\n                }\n            }\n            return (monarchCommon.empty(sub) ? '' : '(?:' + sub + ')');\n        });\n        n++;\n    } while (hadExpansion && n < 5);\n    // handle escaped @@\n    str = str.replace(/\\x01/g, '@');\n    const flags = (lexer.ignoreCase ? 'i' : '') + (lexer.unicode ? 'u' : '');\n    return new RegExp(str, flags);\n}\n/**\n * Compiles guard functions for case matches.\n * This compiles 'cases' attributes into efficient match functions.\n *\n */\nfunction selectScrutinee(id, matches, state, num) {\n    if (num < 0) {\n        return id;\n    }\n    if (num < matches.length) {\n        return matches[num];\n    }\n    if (num >= 100) {\n        num = num - 100;\n        const parts = state.split('.');\n        parts.unshift(state);\n        if (num < parts.length) {\n            return parts[num];\n        }\n    }\n    return null;\n}\nfunction createGuard(lexer, ruleName, tkey, val) {\n    // get the scrutinee and pattern\n    let scrut = -1; // -1: $!, 0-99: $n, 100+n: $Sn\n    let oppat = tkey;\n    let matches = tkey.match(/^\\$(([sS]?)(\\d\\d?)|#)(.*)$/);\n    if (matches) {\n        if (matches[3]) { // if digits\n            scrut = parseInt(matches[3]);\n            if (matches[2]) {\n                scrut = scrut + 100; // if [sS] present\n            }\n        }\n        oppat = matches[4];\n    }\n    // get operator\n    let op = '~';\n    let pat = oppat;\n    if (!oppat || oppat.length === 0) {\n        op = '!=';\n        pat = '';\n    }\n    else if (/^\\w*$/.test(pat)) { // just a word\n        op = '==';\n    }\n    else {\n        matches = oppat.match(/^(@|!@|~|!~|==|!=)(.*)$/);\n        if (matches) {\n            op = matches[1];\n            pat = matches[2];\n        }\n    }\n    // set the tester function\n    let tester;\n    // special case a regexp that matches just words\n    if ((op === '~' || op === '!~') && /^(\\w|\\|)*$/.test(pat)) {\n        const inWords = createKeywordMatcher(pat.split('|'), lexer.ignoreCase);\n        tester = function (s) { return (op === '~' ? inWords(s) : !inWords(s)); };\n    }\n    else if (op === '@' || op === '!@') {\n        const words = lexer[pat];\n        if (!words) {\n            throw monarchCommon.createError(lexer, 'the @ match target \\'' + pat + '\\' is not defined, in rule: ' + ruleName);\n        }\n        if (!(isArrayOf(function (elem) { return (typeof (elem) === 'string'); }, words))) {\n            throw monarchCommon.createError(lexer, 'the @ match target \\'' + pat + '\\' must be an array of strings, in rule: ' + ruleName);\n        }\n        const inWords = createKeywordMatcher(words, lexer.ignoreCase);\n        tester = function (s) { return (op === '@' ? inWords(s) : !inWords(s)); };\n    }\n    else if (op === '~' || op === '!~') {\n        if (pat.indexOf('$') < 0) {\n            // precompile regular expression\n            const re = compileRegExp(lexer, '^' + pat + '$');\n            tester = function (s) { return (op === '~' ? re.test(s) : !re.test(s)); };\n        }\n        else {\n            tester = function (s, id, matches, state) {\n                const re = compileRegExp(lexer, '^' + monarchCommon.substituteMatches(lexer, pat, id, matches, state) + '$');\n                return re.test(s);\n            };\n        }\n    }\n    else { // if (op==='==' || op==='!=') {\n        if (pat.indexOf('$') < 0) {\n            const patx = monarchCommon.fixCase(lexer, pat);\n            tester = function (s) { return (op === '==' ? s === patx : s !== patx); };\n        }\n        else {\n            const patx = monarchCommon.fixCase(lexer, pat);\n            tester = function (s, id, matches, state, eos) {\n                const patexp = monarchCommon.substituteMatches(lexer, patx, id, matches, state);\n                return (op === '==' ? s === patexp : s !== patexp);\n            };\n        }\n    }\n    // return the branch object\n    if (scrut === -1) {\n        return {\n            name: tkey, value: val, test: function (id, matches, state, eos) {\n                return tester(id, id, matches, state, eos);\n            }\n        };\n    }\n    else {\n        return {\n            name: tkey, value: val, test: function (id, matches, state, eos) {\n                const scrutinee = selectScrutinee(id, matches, state, scrut);\n                return tester(!scrutinee ? '' : scrutinee, id, matches, state, eos);\n            }\n        };\n    }\n}\n/**\n * Compiles an action: i.e. optimize regular expressions and case matches\n * and do many sanity checks.\n *\n * This is called only during compilation but if the lexer definition\n * contains user functions as actions (which is usually not allowed), then this\n * may be called during lexing. It is important therefore to compile common cases efficiently\n */\nfunction compileAction(lexer, ruleName, action) {\n    if (!action) {\n        return { token: '' };\n    }\n    else if (typeof (action) === 'string') {\n        return action; // { token: action };\n    }\n    else if (action.token || action.token === '') {\n        if (typeof (action.token) !== 'string') {\n            throw monarchCommon.createError(lexer, 'a \\'token\\' attribute must be of type string, in rule: ' + ruleName);\n        }\n        else {\n            // only copy specific typed fields (only happens once during compile Lexer)\n            const newAction = { token: action.token };\n            if (action.token.indexOf('$') >= 0) {\n                newAction.tokenSubst = true;\n            }\n            if (typeof (action.bracket) === 'string') {\n                if (action.bracket === '@open') {\n                    newAction.bracket = 1 /* monarchCommon.MonarchBracket.Open */;\n                }\n                else if (action.bracket === '@close') {\n                    newAction.bracket = -1 /* monarchCommon.MonarchBracket.Close */;\n                }\n                else {\n                    throw monarchCommon.createError(lexer, 'a \\'bracket\\' attribute must be either \\'@open\\' or \\'@close\\', in rule: ' + ruleName);\n                }\n            }\n            if (action.next) {\n                if (typeof (action.next) !== 'string') {\n                    throw monarchCommon.createError(lexer, 'the next state must be a string value in rule: ' + ruleName);\n                }\n                else {\n                    let next = action.next;\n                    if (!/^(@pop|@push|@popall)$/.test(next)) {\n                        if (next[0] === '@') {\n                            next = next.substr(1); // peel off starting @ sign\n                        }\n                        if (next.indexOf('$') < 0) { // no dollar substitution, we can check if the state exists\n                            if (!monarchCommon.stateExists(lexer, monarchCommon.substituteMatches(lexer, next, '', [], ''))) {\n                                throw monarchCommon.createError(lexer, 'the next state \\'' + action.next + '\\' is not defined in rule: ' + ruleName);\n                            }\n                        }\n                    }\n                    newAction.next = next;\n                }\n            }\n            if (typeof (action.goBack) === 'number') {\n                newAction.goBack = action.goBack;\n            }\n            if (typeof (action.switchTo) === 'string') {\n                newAction.switchTo = action.switchTo;\n            }\n            if (typeof (action.log) === 'string') {\n                newAction.log = action.log;\n            }\n            if (typeof (action.nextEmbedded) === 'string') {\n                newAction.nextEmbedded = action.nextEmbedded;\n                lexer.usesEmbedded = true;\n            }\n            return newAction;\n        }\n    }\n    else if (Array.isArray(action)) {\n        const results = [];\n        for (let i = 0, len = action.length; i < len; i++) {\n            results[i] = compileAction(lexer, ruleName, action[i]);\n        }\n        return { group: results };\n    }\n    else if (action.cases) {\n        // build an array of test cases\n        const cases = [];\n        // for each case, push a test function and result value\n        for (const tkey in action.cases) {\n            if (action.cases.hasOwnProperty(tkey)) {\n                const val = compileAction(lexer, ruleName, action.cases[tkey]);\n                // what kind of case\n                if (tkey === '@default' || tkey === '@' || tkey === '') {\n                    cases.push({ test: undefined, value: val, name: tkey });\n                }\n                else if (tkey === '@eos') {\n                    cases.push({ test: function (id, matches, state, eos) { return eos; }, value: val, name: tkey });\n                }\n                else {\n                    cases.push(createGuard(lexer, ruleName, tkey, val)); // call separate function to avoid local variable capture\n                }\n            }\n        }\n        // create a matching function\n        const def = lexer.defaultToken;\n        return {\n            test: function (id, matches, state, eos) {\n                for (const _case of cases) {\n                    const didmatch = (!_case.test || _case.test(id, matches, state, eos));\n                    if (didmatch) {\n                        return _case.value;\n                    }\n                }\n                return def;\n            }\n        };\n    }\n    else {\n        throw monarchCommon.createError(lexer, 'an action must be a string, an object with a \\'token\\' or \\'cases\\' attribute, or an array of actions; in rule: ' + ruleName);\n    }\n}\n/**\n * Helper class for creating matching rules\n */\nclass Rule {\n    constructor(name) {\n        this.regex = new RegExp('');\n        this.action = { token: '' };\n        this.matchOnlyAtLineStart = false;\n        this.name = '';\n        this.name = name;\n    }\n    setRegex(lexer, re) {\n        let sregex;\n        if (typeof (re) === 'string') {\n            sregex = re;\n        }\n        else if (re instanceof RegExp) {\n            sregex = re.source;\n        }\n        else {\n            throw monarchCommon.createError(lexer, 'rules must start with a match string or regular expression: ' + this.name);\n        }\n        this.matchOnlyAtLineStart = (sregex.length > 0 && sregex[0] === '^');\n        this.name = this.name + ': ' + sregex;\n        this.regex = compileRegExp(lexer, '^(?:' + (this.matchOnlyAtLineStart ? sregex.substr(1) : sregex) + ')');\n    }\n    setAction(lexer, act) {\n        this.action = compileAction(lexer, this.name, act);\n    }\n}\n/**\n * Compiles a json description function into json where all regular expressions,\n * case matches etc, are compiled and all include rules are expanded.\n * We also compile the bracket definitions, supply defaults, and do many sanity checks.\n * If the 'jsonStrict' parameter is 'false', we allow at certain locations\n * regular expression objects and functions that get called during lexing.\n * (Currently we have no samples that need this so perhaps we should always have\n * jsonStrict to true).\n */\nexport function compile(languageId, json) {\n    if (!json || typeof (json) !== 'object') {\n        throw new Error('Monarch: expecting a language definition object');\n    }\n    // Create our lexer\n    const lexer = {};\n    lexer.languageId = languageId;\n    lexer.includeLF = bool(json.includeLF, false);\n    lexer.noThrow = false; // raise exceptions during compilation\n    lexer.maxStack = 100;\n    // Set standard fields: be defensive about types\n    lexer.start = (typeof json.start === 'string' ? json.start : null);\n    lexer.ignoreCase = bool(json.ignoreCase, false);\n    lexer.unicode = bool(json.unicode, false);\n    lexer.tokenPostfix = string(json.tokenPostfix, '.' + lexer.languageId);\n    lexer.defaultToken = string(json.defaultToken, 'source');\n    lexer.usesEmbedded = false; // becomes true if we find a nextEmbedded action\n    // For calling compileAction later on\n    const lexerMin = json;\n    lexerMin.languageId = languageId;\n    lexerMin.includeLF = lexer.includeLF;\n    lexerMin.ignoreCase = lexer.ignoreCase;\n    lexerMin.unicode = lexer.unicode;\n    lexerMin.noThrow = lexer.noThrow;\n    lexerMin.usesEmbedded = lexer.usesEmbedded;\n    lexerMin.stateNames = json.tokenizer;\n    lexerMin.defaultToken = lexer.defaultToken;\n    // Compile an array of rules into newrules where RegExp objects are created.\n    function addRules(state, newrules, rules) {\n        for (const rule of rules) {\n            let include = rule.include;\n            if (include) {\n                if (typeof (include) !== 'string') {\n                    throw monarchCommon.createError(lexer, 'an \\'include\\' attribute must be a string at: ' + state);\n                }\n                if (include[0] === '@') {\n                    include = include.substr(1); // peel off starting @\n                }\n                if (!json.tokenizer[include]) {\n                    throw monarchCommon.createError(lexer, 'include target \\'' + include + '\\' is not defined at: ' + state);\n                }\n                addRules(state + '.' + include, newrules, json.tokenizer[include]);\n            }\n            else {\n                const newrule = new Rule(state);\n                // Set up new rule attributes\n                if (Array.isArray(rule) && rule.length >= 1 && rule.length <= 3) {\n                    newrule.setRegex(lexerMin, rule[0]);\n                    if (rule.length >= 3) {\n                        if (typeof (rule[1]) === 'string') {\n                            newrule.setAction(lexerMin, { token: rule[1], next: rule[2] });\n                        }\n                        else if (typeof (rule[1]) === 'object') {\n                            const rule1 = rule[1];\n                            rule1.next = rule[2];\n                            newrule.setAction(lexerMin, rule1);\n                        }\n                        else {\n                            throw monarchCommon.createError(lexer, 'a next state as the last element of a rule can only be given if the action is either an object or a string, at: ' + state);\n                        }\n                    }\n                    else {\n                        newrule.setAction(lexerMin, rule[1]);\n                    }\n                }\n                else {\n                    if (!rule.regex) {\n                        throw monarchCommon.createError(lexer, 'a rule must either be an array, or an object with a \\'regex\\' or \\'include\\' field at: ' + state);\n                    }\n                    if (rule.name) {\n                        if (typeof rule.name === 'string') {\n                            newrule.name = rule.name;\n                        }\n                    }\n                    if (rule.matchOnlyAtStart) {\n                        newrule.matchOnlyAtLineStart = bool(rule.matchOnlyAtLineStart, false);\n                    }\n                    newrule.setRegex(lexerMin, rule.regex);\n                    newrule.setAction(lexerMin, rule.action);\n                }\n                newrules.push(newrule);\n            }\n        }\n    }\n    // compile the tokenizer rules\n    if (!json.tokenizer || typeof (json.tokenizer) !== 'object') {\n        throw monarchCommon.createError(lexer, 'a language definition must define the \\'tokenizer\\' attribute as an object');\n    }\n    lexer.tokenizer = [];\n    for (const key in json.tokenizer) {\n        if (json.tokenizer.hasOwnProperty(key)) {\n            if (!lexer.start) {\n                lexer.start = key;\n            }\n            const rules = json.tokenizer[key];\n            lexer.tokenizer[key] = new Array();\n            addRules('tokenizer.' + key, lexer.tokenizer[key], rules);\n        }\n    }\n    lexer.usesEmbedded = lexerMin.usesEmbedded; // can be set during compileAction\n    // Set simple brackets\n    if (json.brackets) {\n        if (!(Array.isArray(json.brackets))) {\n            throw monarchCommon.createError(lexer, 'the \\'brackets\\' attribute must be defined as an array');\n        }\n    }\n    else {\n        json.brackets = [\n            { open: '{', close: '}', token: 'delimiter.curly' },\n            { open: '[', close: ']', token: 'delimiter.square' },\n            { open: '(', close: ')', token: 'delimiter.parenthesis' },\n            { open: '<', close: '>', token: 'delimiter.angle' }\n        ];\n    }\n    const brackets = [];\n    for (const el of json.brackets) {\n        let desc = el;\n        if (desc && Array.isArray(desc) && desc.length === 3) {\n            desc = { token: desc[2], open: desc[0], close: desc[1] };\n        }\n        if (desc.open === desc.close) {\n            throw monarchCommon.createError(lexer, 'open and close brackets in a \\'brackets\\' attribute must be different: ' + desc.open +\n                '\\n hint: use the \\'bracket\\' attribute if matching on equal brackets is required.');\n        }\n        if (typeof desc.open === 'string' && typeof desc.token === 'string' && typeof desc.close === 'string') {\n            brackets.push({\n                token: desc.token + lexer.tokenPostfix,\n                open: monarchCommon.fixCase(lexer, desc.open),\n                close: monarchCommon.fixCase(lexer, desc.close)\n            });\n        }\n        else {\n            throw monarchCommon.createError(lexer, 'every element in the \\'brackets\\' array must be a \\'{open,close,token}\\' object or array');\n        }\n    }\n    lexer.brackets = brackets;\n    // Disable throw so the syntax highlighter goes, no matter what\n    lexer.noThrow = true;\n    return lexer;\n}\n"],"mappings":"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"}]}