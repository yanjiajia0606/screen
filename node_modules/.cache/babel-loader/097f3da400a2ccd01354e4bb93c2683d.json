{"remainingRequest":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/thread-loader/dist/cjs.js!/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js!/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js","dependencies":[{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/babel.config.js","mtime":1668271197000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js","mtime":456789000000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gIi9Vc2Vycy95YW5qaWFqaWEvRGVza3RvcC93b3Jrc3BhY2UvYXZ1ZS1kYXRhLW5ldy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcyI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiL1VzZXJzL3lhbmppYWppYS9EZXNrdG9wL3dvcmtzcGFjZS9hdnVlLWRhdGEtbmV3L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjay5qcyI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiL1VzZXJzL3lhbmppYWppYS9EZXNrdG9wL3dvcmtzcGFjZS9hdnVlLWRhdGEtbmV3L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LWJ1ZmZlci5zbGljZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbnQzMi1hcnJheS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmF0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW4uanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5ldmVyeS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGwuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXIuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQtbGFzdC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQtbGFzdC1pbmRleC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5jbHVkZXMuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZi5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pbi5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2YuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXAuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmVycm9yLmNhdXNlLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucHVzaC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRlc3QuanMiOwovKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLgogKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi8KaW1wb3J0IHsgRGlmZkNoYW5nZSB9IGZyb20gJy4vZGlmZkNoYW5nZS5qcyc7CmltcG9ydCB7IHN0cmluZ0hhc2ggfSBmcm9tICcuLi9oYXNoLmpzJzsKZXhwb3J0IHZhciBTdHJpbmdEaWZmU2VxdWVuY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIGZ1bmN0aW9uIFN0cmluZ0RpZmZTZXF1ZW5jZShzb3VyY2UpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJpbmdEaWZmU2VxdWVuY2UpOwogICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7CiAgfQogIF9jcmVhdGVDbGFzcyhTdHJpbmdEaWZmU2VxdWVuY2UsIFt7CiAgICBrZXk6ICJnZXRFbGVtZW50cyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudHMoKSB7CiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTsKICAgICAgdmFyIGNoYXJhY3RlcnMgPSBuZXcgSW50MzJBcnJheShzb3VyY2UubGVuZ3RoKTsKICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykgewogICAgICAgIGNoYXJhY3RlcnNbaV0gPSBzb3VyY2UuY2hhckNvZGVBdChpKTsKICAgICAgfQogICAgICByZXR1cm4gY2hhcmFjdGVyczsKICAgIH0KICB9XSk7CiAgcmV0dXJuIFN0cmluZ0RpZmZTZXF1ZW5jZTsKfSgpOwpleHBvcnQgZnVuY3Rpb24gc3RyaW5nRGlmZihvcmlnaW5hbCwgbW9kaWZpZWQsIHByZXR0eSkgewogIHJldHVybiBuZXcgTGNzRGlmZihuZXcgU3RyaW5nRGlmZlNlcXVlbmNlKG9yaWdpbmFsKSwgbmV3IFN0cmluZ0RpZmZTZXF1ZW5jZShtb2RpZmllZCkpLkNvbXB1dGVEaWZmKHByZXR0eSkuY2hhbmdlczsKfQovLwovLyBUaGUgY29kZSBiZWxvdyBoYXMgYmVlbiBwb3J0ZWQgZnJvbSBhIEMjIGltcGxlbWVudGF0aW9uIGluIFZTCi8vCmV4cG9ydCB2YXIgRGVidWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIGZ1bmN0aW9uIERlYnVnKCkgewogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlYnVnKTsKICB9CiAgX2NyZWF0ZUNsYXNzKERlYnVnLCBudWxsLCBbewogICAga2V5OiAiQXNzZXJ0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBBc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7CiAgICAgIGlmICghY29uZGl0aW9uKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpOwogICAgICB9CiAgICB9CiAgfV0pOwogIHJldHVybiBEZWJ1ZzsKfSgpOwpleHBvcnQgdmFyIE15QXJyYXkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIGZ1bmN0aW9uIE15QXJyYXkoKSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTXlBcnJheSk7CiAgfQogIF9jcmVhdGVDbGFzcyhNeUFycmF5LCBudWxsLCBbewogICAga2V5OiAiQ29weSIsCiAgICB2YWx1ZToKICAgIC8qKgogICAgICogQ29waWVzIGEgcmFuZ2Ugb2YgZWxlbWVudHMgZnJvbSBhbiBBcnJheSBzdGFydGluZyBhdCB0aGUgc3BlY2lmaWVkIHNvdXJjZSBpbmRleCBhbmQgcGFzdGVzCiAgICAgKiB0aGVtIHRvIGFub3RoZXIgQXJyYXkgc3RhcnRpbmcgYXQgdGhlIHNwZWNpZmllZCBkZXN0aW5hdGlvbiBpbmRleC4gVGhlIGxlbmd0aCBhbmQgdGhlIGluZGV4ZXMKICAgICAqIGFyZSBzcGVjaWZpZWQgYXMgNjQtYml0IGludGVnZXJzLgogICAgICogc291cmNlQXJyYXk6CiAgICAgKgkJVGhlIEFycmF5IHRoYXQgY29udGFpbnMgdGhlIGRhdGEgdG8gY29weS4KICAgICAqIHNvdXJjZUluZGV4OgogICAgICoJCUEgNjQtYml0IGludGVnZXIgdGhhdCByZXByZXNlbnRzIHRoZSBpbmRleCBpbiB0aGUgc291cmNlQXJyYXkgYXQgd2hpY2ggY29weWluZyBiZWdpbnMuCiAgICAgKiBkZXN0aW5hdGlvbkFycmF5OgogICAgICoJCVRoZSBBcnJheSB0aGF0IHJlY2VpdmVzIHRoZSBkYXRhLgogICAgICogZGVzdGluYXRpb25JbmRleDoKICAgICAqCQlBIDY0LWJpdCBpbnRlZ2VyIHRoYXQgcmVwcmVzZW50cyB0aGUgaW5kZXggaW4gdGhlIGRlc3RpbmF0aW9uQXJyYXkgYXQgd2hpY2ggc3RvcmluZyBiZWdpbnMuCiAgICAgKiBsZW5ndGg6CiAgICAgKgkJQSA2NC1iaXQgaW50ZWdlciB0aGF0IHJlcHJlc2VudHMgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjb3B5LgogICAgICovCiAgICBmdW5jdGlvbiBDb3B5KHNvdXJjZUFycmF5LCBzb3VyY2VJbmRleCwgZGVzdGluYXRpb25BcnJheSwgZGVzdGluYXRpb25JbmRleCwgbGVuZ3RoKSB7CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHsKICAgICAgICBkZXN0aW5hdGlvbkFycmF5W2Rlc3RpbmF0aW9uSW5kZXggKyBpXSA9IHNvdXJjZUFycmF5W3NvdXJjZUluZGV4ICsgaV07CiAgICAgIH0KICAgIH0KICB9LCB7CiAgICBrZXk6ICJDb3B5MiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gQ29weTIoc291cmNlQXJyYXksIHNvdXJjZUluZGV4LCBkZXN0aW5hdGlvbkFycmF5LCBkZXN0aW5hdGlvbkluZGV4LCBsZW5ndGgpIHsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICAgIGRlc3RpbmF0aW9uQXJyYXlbZGVzdGluYXRpb25JbmRleCArIGldID0gc291cmNlQXJyYXlbc291cmNlSW5kZXggKyBpXTsKICAgICAgfQogICAgfQogIH1dKTsKICByZXR1cm4gTXlBcnJheTsKfSgpOwovKioKICogQSB1dGlsaXR5IGNsYXNzIHdoaWNoIGhlbHBzIHRvIGNyZWF0ZSB0aGUgc2V0IG9mIERpZmZDaGFuZ2VzIGZyb20KICogYSBkaWZmZXJlbmNlIG9wZXJhdGlvbi4gVGhpcyBjbGFzcyBhY2NlcHRzIG9yaWdpbmFsIERpZmZFbGVtZW50cyBhbmQKICogbW9kaWZpZWQgRGlmZkVsZW1lbnRzIHRoYXQgYXJlIGludm9sdmVkIGluIGEgcGFydGljdWxhciBjaGFuZ2UuIFRoZQogKiBNYXJrTmV4dENoYW5nZSgpIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHRvIG1hcmsgdGhlIHNlcGFyYXRpb24gYmV0d2VlbgogKiBkaXN0aW5jdCBjaGFuZ2VzLiBBdCB0aGUgZW5kLCB0aGUgQ2hhbmdlcyBwcm9wZXJ0eSBjYW4gYmUgY2FsbGVkIHRvIHJldHJpZXZlCiAqIHRoZSBjb25zdHJ1Y3RlZCBjaGFuZ2VzLgogKi8KdmFyIERpZmZDaGFuZ2VIZWxwZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENvbnN0cnVjdHMgYSBuZXcgRGlmZkNoYW5nZUhlbHBlciBmb3IgdGhlIGdpdmVuIERpZmZTZXF1ZW5jZXMuCiAgICovCiAgZnVuY3Rpb24gRGlmZkNoYW5nZUhlbHBlcigpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaWZmQ2hhbmdlSGVscGVyKTsKICAgIHRoaXMubV9jaGFuZ2VzID0gW107CiAgICB0aGlzLm1fb3JpZ2luYWxTdGFydCA9IDEwNzM3NDE4MjQgLyogQ29uc3RhbnRzLk1BWF9TQUZFX1NNQUxMX0lOVEVHRVIgKi87CiAgICB0aGlzLm1fbW9kaWZpZWRTdGFydCA9IDEwNzM3NDE4MjQgLyogQ29uc3RhbnRzLk1BWF9TQUZFX1NNQUxMX0lOVEVHRVIgKi87CiAgICB0aGlzLm1fb3JpZ2luYWxDb3VudCA9IDA7CiAgICB0aGlzLm1fbW9kaWZpZWRDb3VudCA9IDA7CiAgfQogIC8qKgogICAqIE1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgY2hhbmdlIGluIHRoZSBzZXQgb2YgZGlmZmVyZW5jZXMuCiAgICovCiAgX2NyZWF0ZUNsYXNzKERpZmZDaGFuZ2VIZWxwZXIsIFt7CiAgICBrZXk6ICJNYXJrTmV4dENoYW5nZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gTWFya05leHRDaGFuZ2UoKSB7CiAgICAgIC8vIE9ubHkgYWRkIHRvIHRoZSBsaXN0IGlmIHRoZXJlIGlzIHNvbWV0aGluZyB0byBhZGQKICAgICAgaWYgKHRoaXMubV9vcmlnaW5hbENvdW50ID4gMCB8fCB0aGlzLm1fbW9kaWZpZWRDb3VudCA+IDApIHsKICAgICAgICAvLyBBZGQgdGhlIG5ldyBjaGFuZ2UgdG8gb3VyIGxpc3QKICAgICAgICB0aGlzLm1fY2hhbmdlcy5wdXNoKG5ldyBEaWZmQ2hhbmdlKHRoaXMubV9vcmlnaW5hbFN0YXJ0LCB0aGlzLm1fb3JpZ2luYWxDb3VudCwgdGhpcy5tX21vZGlmaWVkU3RhcnQsIHRoaXMubV9tb2RpZmllZENvdW50KSk7CiAgICAgIH0KICAgICAgLy8gUmVzZXQgZm9yIHRoZSBuZXh0IGNoYW5nZQogICAgICB0aGlzLm1fb3JpZ2luYWxDb3VudCA9IDA7CiAgICAgIHRoaXMubV9tb2RpZmllZENvdW50ID0gMDsKICAgICAgdGhpcy5tX29yaWdpbmFsU3RhcnQgPSAxMDczNzQxODI0IC8qIENvbnN0YW50cy5NQVhfU0FGRV9TTUFMTF9JTlRFR0VSICovOwogICAgICB0aGlzLm1fbW9kaWZpZWRTdGFydCA9IDEwNzM3NDE4MjQgLyogQ29uc3RhbnRzLk1BWF9TQUZFX1NNQUxMX0lOVEVHRVIgKi87CiAgICB9CiAgICAvKioKICAgICAqIEFkZHMgdGhlIG9yaWdpbmFsIGVsZW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIHRvIHRoZSBlbGVtZW50cwogICAgICogYWZmZWN0ZWQgYnkgdGhlIGN1cnJlbnQgY2hhbmdlLiBUaGUgbW9kaWZpZWQgaW5kZXggZ2l2ZXMgY29udGV4dAogICAgICogdG8gdGhlIGNoYW5nZSBwb3NpdGlvbiB3aXRoIHJlc3BlY3QgdG8gdGhlIG9yaWdpbmFsIHNlcXVlbmNlLgogICAgICogQHBhcmFtIG9yaWdpbmFsSW5kZXggVGhlIGluZGV4IG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50IHRvIGFkZC4KICAgICAqIEBwYXJhbSBtb2RpZmllZEluZGV4IFRoZSBpbmRleCBvZiB0aGUgbW9kaWZpZWQgZWxlbWVudCB0aGF0IHByb3ZpZGVzIGNvcnJlc3BvbmRpbmcgcG9zaXRpb24gaW4gdGhlIG1vZGlmaWVkIHNlcXVlbmNlLgogICAgICovCiAgfSwgewogICAga2V5OiAiQWRkT3JpZ2luYWxFbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBBZGRPcmlnaW5hbEVsZW1lbnQob3JpZ2luYWxJbmRleCwgbW9kaWZpZWRJbmRleCkgewogICAgICAvLyBUaGUgJ3RydWUnIHN0YXJ0IGluZGV4IGlzIHRoZSBzbWFsbGVzdCBvZiB0aGUgb25lcyB3ZSd2ZSBzZWVuCiAgICAgIHRoaXMubV9vcmlnaW5hbFN0YXJ0ID0gTWF0aC5taW4odGhpcy5tX29yaWdpbmFsU3RhcnQsIG9yaWdpbmFsSW5kZXgpOwogICAgICB0aGlzLm1fbW9kaWZpZWRTdGFydCA9IE1hdGgubWluKHRoaXMubV9tb2RpZmllZFN0YXJ0LCBtb2RpZmllZEluZGV4KTsKICAgICAgdGhpcy5tX29yaWdpbmFsQ291bnQrKzsKICAgIH0KICAgIC8qKgogICAgICogQWRkcyB0aGUgbW9kaWZpZWQgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gdG8gdGhlIGVsZW1lbnRzCiAgICAgKiBhZmZlY3RlZCBieSB0aGUgY3VycmVudCBjaGFuZ2UuIFRoZSBvcmlnaW5hbCBpbmRleCBnaXZlcyBjb250ZXh0CiAgICAgKiB0byB0aGUgY2hhbmdlIHBvc2l0aW9uIHdpdGggcmVzcGVjdCB0byB0aGUgbW9kaWZpZWQgc2VxdWVuY2UuCiAgICAgKiBAcGFyYW0gb3JpZ2luYWxJbmRleCBUaGUgaW5kZXggb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQgdGhhdCBwcm92aWRlcyBjb3JyZXNwb25kaW5nIHBvc2l0aW9uIGluIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZS4KICAgICAqIEBwYXJhbSBtb2RpZmllZEluZGV4IFRoZSBpbmRleCBvZiB0aGUgbW9kaWZpZWQgZWxlbWVudCB0byBhZGQuCiAgICAgKi8KICB9LCB7CiAgICBrZXk6ICJBZGRNb2RpZmllZEVsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIEFkZE1vZGlmaWVkRWxlbWVudChvcmlnaW5hbEluZGV4LCBtb2RpZmllZEluZGV4KSB7CiAgICAgIC8vIFRoZSAndHJ1ZScgc3RhcnQgaW5kZXggaXMgdGhlIHNtYWxsZXN0IG9mIHRoZSBvbmVzIHdlJ3ZlIHNlZW4KICAgICAgdGhpcy5tX29yaWdpbmFsU3RhcnQgPSBNYXRoLm1pbih0aGlzLm1fb3JpZ2luYWxTdGFydCwgb3JpZ2luYWxJbmRleCk7CiAgICAgIHRoaXMubV9tb2RpZmllZFN0YXJ0ID0gTWF0aC5taW4odGhpcy5tX21vZGlmaWVkU3RhcnQsIG1vZGlmaWVkSW5kZXgpOwogICAgICB0aGlzLm1fbW9kaWZpZWRDb3VudCsrOwogICAgfQogICAgLyoqCiAgICAgKiBSZXRyaWV2ZXMgYWxsIG9mIHRoZSBjaGFuZ2VzIG1hcmtlZCBieSB0aGUgY2xhc3MuCiAgICAgKi8KICB9LCB7CiAgICBrZXk6ICJnZXRDaGFuZ2VzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGFuZ2VzKCkgewogICAgICBpZiAodGhpcy5tX29yaWdpbmFsQ291bnQgPiAwIHx8IHRoaXMubV9tb2RpZmllZENvdW50ID4gMCkgewogICAgICAgIC8vIEZpbmlzaCB1cCBvbiB3aGF0ZXZlciBpcyBsZWZ0CiAgICAgICAgdGhpcy5NYXJrTmV4dENoYW5nZSgpOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLm1fY2hhbmdlczsKICAgIH0KICAgIC8qKgogICAgICogUmV0cmlldmVzIGFsbCBvZiB0aGUgY2hhbmdlcyBtYXJrZWQgYnkgdGhlIGNsYXNzIGluIHRoZSByZXZlcnNlIG9yZGVyCiAgICAgKi8KICB9LCB7CiAgICBrZXk6ICJnZXRSZXZlcnNlQ2hhbmdlcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmV2ZXJzZUNoYW5nZXMoKSB7CiAgICAgIGlmICh0aGlzLm1fb3JpZ2luYWxDb3VudCA+IDAgfHwgdGhpcy5tX21vZGlmaWVkQ291bnQgPiAwKSB7CiAgICAgICAgLy8gRmluaXNoIHVwIG9uIHdoYXRldmVyIGlzIGxlZnQKICAgICAgICB0aGlzLk1hcmtOZXh0Q2hhbmdlKCk7CiAgICAgIH0KICAgICAgdGhpcy5tX2NoYW5nZXMucmV2ZXJzZSgpOwogICAgICByZXR1cm4gdGhpcy5tX2NoYW5nZXM7CiAgICB9CiAgfV0pOwogIHJldHVybiBEaWZmQ2hhbmdlSGVscGVyOwp9KCk7Ci8qKgogKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZGlmZmVyZW5jZSBhbGdvcml0aG0gZGVzY3JpYmVkIGluCiAqICJBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgaXRzIHZhcmlhdGlvbnMiIGJ5IEV1Z2VuZSBXLiBNeWVycwogKi8KZXhwb3J0IHZhciBMY3NEaWZmID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICAvKioKICAgKiBDb25zdHJ1Y3RzIHRoZSBEaWZmRmluZGVyCiAgICovCiAgZnVuY3Rpb24gTGNzRGlmZihvcmlnaW5hbFNlcXVlbmNlLCBtb2RpZmllZFNlcXVlbmNlKSB7CiAgICB2YXIgY29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsOwogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExjc0RpZmYpOwogICAgdGhpcy5Db250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUgPSBjb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGU7CiAgICB0aGlzLl9vcmlnaW5hbFNlcXVlbmNlID0gb3JpZ2luYWxTZXF1ZW5jZTsKICAgIHRoaXMuX21vZGlmaWVkU2VxdWVuY2UgPSBtb2RpZmllZFNlcXVlbmNlOwogICAgdmFyIF9MY3NEaWZmJF9nZXRFbGVtZW50cyA9IExjc0RpZmYuX2dldEVsZW1lbnRzKG9yaWdpbmFsU2VxdWVuY2UpLAogICAgICBfTGNzRGlmZiRfZ2V0RWxlbWVudHMyID0gX3NsaWNlZFRvQXJyYXkoX0xjc0RpZmYkX2dldEVsZW1lbnRzLCAzKSwKICAgICAgb3JpZ2luYWxTdHJpbmdFbGVtZW50cyA9IF9MY3NEaWZmJF9nZXRFbGVtZW50czJbMF0sCiAgICAgIG9yaWdpbmFsRWxlbWVudHNPckhhc2ggPSBfTGNzRGlmZiRfZ2V0RWxlbWVudHMyWzFdLAogICAgICBvcmlnaW5hbEhhc1N0cmluZ3MgPSBfTGNzRGlmZiRfZ2V0RWxlbWVudHMyWzJdOwogICAgdmFyIF9MY3NEaWZmJF9nZXRFbGVtZW50czMgPSBMY3NEaWZmLl9nZXRFbGVtZW50cyhtb2RpZmllZFNlcXVlbmNlKSwKICAgICAgX0xjc0RpZmYkX2dldEVsZW1lbnRzNCA9IF9zbGljZWRUb0FycmF5KF9MY3NEaWZmJF9nZXRFbGVtZW50czMsIDMpLAogICAgICBtb2RpZmllZFN0cmluZ0VsZW1lbnRzID0gX0xjc0RpZmYkX2dldEVsZW1lbnRzNFswXSwKICAgICAgbW9kaWZpZWRFbGVtZW50c09ySGFzaCA9IF9MY3NEaWZmJF9nZXRFbGVtZW50czRbMV0sCiAgICAgIG1vZGlmaWVkSGFzU3RyaW5ncyA9IF9MY3NEaWZmJF9nZXRFbGVtZW50czRbMl07CiAgICB0aGlzLl9oYXNTdHJpbmdzID0gb3JpZ2luYWxIYXNTdHJpbmdzICYmIG1vZGlmaWVkSGFzU3RyaW5nczsKICAgIHRoaXMuX29yaWdpbmFsU3RyaW5nRWxlbWVudHMgPSBvcmlnaW5hbFN0cmluZ0VsZW1lbnRzOwogICAgdGhpcy5fb3JpZ2luYWxFbGVtZW50c09ySGFzaCA9IG9yaWdpbmFsRWxlbWVudHNPckhhc2g7CiAgICB0aGlzLl9tb2RpZmllZFN0cmluZ0VsZW1lbnRzID0gbW9kaWZpZWRTdHJpbmdFbGVtZW50czsKICAgIHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2ggPSBtb2RpZmllZEVsZW1lbnRzT3JIYXNoOwogICAgdGhpcy5tX2ZvcndhcmRIaXN0b3J5ID0gW107CiAgICB0aGlzLm1fcmV2ZXJzZUhpc3RvcnkgPSBbXTsKICB9CiAgX2NyZWF0ZUNsYXNzKExjc0RpZmYsIFt7CiAgICBrZXk6ICJFbGVtZW50c0FyZUVxdWFsIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBFbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsSW5kZXgsIG5ld0luZGV4KSB7CiAgICAgIGlmICh0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoW29yaWdpbmFsSW5kZXhdICE9PSB0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoW25ld0luZGV4XSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5faGFzU3RyaW5ncyA/IHRoaXMuX29yaWdpbmFsU3RyaW5nRWxlbWVudHNbb3JpZ2luYWxJbmRleF0gPT09IHRoaXMuX21vZGlmaWVkU3RyaW5nRWxlbWVudHNbbmV3SW5kZXhdIDogdHJ1ZTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJFbGVtZW50c0FyZVN0cmljdEVxdWFsIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBFbGVtZW50c0FyZVN0cmljdEVxdWFsKG9yaWdpbmFsSW5kZXgsIG5ld0luZGV4KSB7CiAgICAgIGlmICghdGhpcy5FbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsSW5kZXgsIG5ld0luZGV4KSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgICB2YXIgb3JpZ2luYWxFbGVtZW50ID0gTGNzRGlmZi5fZ2V0U3RyaWN0RWxlbWVudCh0aGlzLl9vcmlnaW5hbFNlcXVlbmNlLCBvcmlnaW5hbEluZGV4KTsKICAgICAgdmFyIG1vZGlmaWVkRWxlbWVudCA9IExjc0RpZmYuX2dldFN0cmljdEVsZW1lbnQodGhpcy5fbW9kaWZpZWRTZXF1ZW5jZSwgbmV3SW5kZXgpOwogICAgICByZXR1cm4gb3JpZ2luYWxFbGVtZW50ID09PSBtb2RpZmllZEVsZW1lbnQ7CiAgICB9CiAgfSwgewogICAga2V5OiAiT3JpZ2luYWxFbGVtZW50c0FyZUVxdWFsIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBPcmlnaW5hbEVsZW1lbnRzQXJlRXF1YWwoaW5kZXgxLCBpbmRleDIpIHsKICAgICAgaWYgKHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2hbaW5kZXgxXSAhPT0gdGhpcy5fb3JpZ2luYWxFbGVtZW50c09ySGFzaFtpbmRleDJdKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLl9oYXNTdHJpbmdzID8gdGhpcy5fb3JpZ2luYWxTdHJpbmdFbGVtZW50c1tpbmRleDFdID09PSB0aGlzLl9vcmlnaW5hbFN0cmluZ0VsZW1lbnRzW2luZGV4Ml0gOiB0cnVlOwogICAgfQogIH0sIHsKICAgIGtleTogIk1vZGlmaWVkRWxlbWVudHNBcmVFcXVhbCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gTW9kaWZpZWRFbGVtZW50c0FyZUVxdWFsKGluZGV4MSwgaW5kZXgyKSB7CiAgICAgIGlmICh0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoW2luZGV4MV0gIT09IHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2hbaW5kZXgyXSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5faGFzU3RyaW5ncyA/IHRoaXMuX21vZGlmaWVkU3RyaW5nRWxlbWVudHNbaW5kZXgxXSA9PT0gdGhpcy5fbW9kaWZpZWRTdHJpbmdFbGVtZW50c1tpbmRleDJdIDogdHJ1ZTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJDb21wdXRlRGlmZiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gQ29tcHV0ZURpZmYocHJldHR5KSB7CiAgICAgIHJldHVybiB0aGlzLl9Db21wdXRlRGlmZigwLCB0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoLmxlbmd0aCAtIDEsIDAsIHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2gubGVuZ3RoIC0gMSwgcHJldHR5KTsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZXMgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIG9yaWdpbmFsIGFuZCBtb2RpZmllZCBpbnB1dAogICAgICogc2VxdWVuY2VzIG9uIHRoZSBib3VuZGVkIHJhbmdlLgogICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIHR3byBpbnB1dCBzZXF1ZW5jZXMuCiAgICAgKi8KICB9LCB7CiAgICBrZXk6ICJfQ29tcHV0ZURpZmYiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9Db21wdXRlRGlmZihvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQsIHByZXR0eSkgewogICAgICB2YXIgcXVpdEVhcmx5QXJyID0gW2ZhbHNlXTsKICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLkNvbXB1dGVEaWZmUmVjdXJzaXZlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCwgcXVpdEVhcmx5QXJyKTsKICAgICAgaWYgKHByZXR0eSkgewogICAgICAgIC8vIFdlIGhhdmUgdG8gY2xlYW4gdXAgdGhlIGNvbXB1dGVkIGRpZmYgdG8gYmUgbW9yZSBpbnR1aXRpdmUKICAgICAgICAvLyBidXQgaXQgdHVybnMgb3V0IHRoaXMgY2Fubm90IGJlIGRvbmUgY29ycmVjdGx5IHVudGlsIHRoZSBlbnRpcmUgc2V0CiAgICAgICAgLy8gb2YgZGlmZnMgaGF2ZSBiZWVuIGNvbXB1dGVkCiAgICAgICAgY2hhbmdlcyA9IHRoaXMuUHJldHRpZnlDaGFuZ2VzKGNoYW5nZXMpOwogICAgICB9CiAgICAgIHJldHVybiB7CiAgICAgICAgcXVpdEVhcmx5OiBxdWl0RWFybHlBcnJbMF0sCiAgICAgICAgY2hhbmdlczogY2hhbmdlcwogICAgICB9OwogICAgfQogICAgLyoqCiAgICAgKiBQcml2YXRlIGhlbHBlciBtZXRob2Qgd2hpY2ggY29tcHV0ZXMgdGhlIGRpZmZlcmVuY2VzIG9uIHRoZSBib3VuZGVkIHJhbmdlCiAgICAgKiByZWN1cnNpdmVseS4KICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28gaW5wdXQgc2VxdWVuY2VzLgogICAgICovCiAgfSwgewogICAga2V5OiAiQ29tcHV0ZURpZmZSZWN1cnNpdmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIENvbXB1dGVEaWZmUmVjdXJzaXZlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCwgcXVpdEVhcmx5QXJyKSB7CiAgICAgIHF1aXRFYXJseUFyclswXSA9IGZhbHNlOwogICAgICAvLyBGaW5kIHRoZSBzdGFydCBvZiB0aGUgZGlmZmVyZW5jZXMKICAgICAgd2hpbGUgKG9yaWdpbmFsU3RhcnQgPD0gb3JpZ2luYWxFbmQgJiYgbW9kaWZpZWRTdGFydCA8PSBtb2RpZmllZEVuZCAmJiB0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxTdGFydCwgbW9kaWZpZWRTdGFydCkpIHsKICAgICAgICBvcmlnaW5hbFN0YXJ0Kys7CiAgICAgICAgbW9kaWZpZWRTdGFydCsrOwogICAgICB9CiAgICAgIC8vIEZpbmQgdGhlIGVuZCBvZiB0aGUgZGlmZmVyZW5jZXMKICAgICAgd2hpbGUgKG9yaWdpbmFsRW5kID49IG9yaWdpbmFsU3RhcnQgJiYgbW9kaWZpZWRFbmQgPj0gbW9kaWZpZWRTdGFydCAmJiB0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxFbmQsIG1vZGlmaWVkRW5kKSkgewogICAgICAgIG9yaWdpbmFsRW5kLS07CiAgICAgICAgbW9kaWZpZWRFbmQtLTsKICAgICAgfQogICAgICAvLyBJbiB0aGUgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIGVpdGhlciBoYXZlIGFsbCBpbnNlcnRpb25zIG9yIGFsbCBkZWxldGlvbnMgb3IgdGhlIHNlcXVlbmNlcyBhcmUgaWRlbnRpY2FsCiAgICAgIGlmIChvcmlnaW5hbFN0YXJ0ID4gb3JpZ2luYWxFbmQgfHwgbW9kaWZpZWRTdGFydCA+IG1vZGlmaWVkRW5kKSB7CiAgICAgICAgdmFyIGNoYW5nZXM7CiAgICAgICAgaWYgKG1vZGlmaWVkU3RhcnQgPD0gbW9kaWZpZWRFbmQpIHsKICAgICAgICAgIERlYnVnLkFzc2VydChvcmlnaW5hbFN0YXJ0ID09PSBvcmlnaW5hbEVuZCArIDEsICdvcmlnaW5hbFN0YXJ0IHNob3VsZCBvbmx5IGJlIG9uZSBtb3JlIHRoYW4gb3JpZ2luYWxFbmQnKTsKICAgICAgICAgIC8vIEFsbCBpbnNlcnRpb25zCiAgICAgICAgICBjaGFuZ2VzID0gW25ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnQsIDAsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydCArIDEpXTsKICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsU3RhcnQgPD0gb3JpZ2luYWxFbmQpIHsKICAgICAgICAgIERlYnVnLkFzc2VydChtb2RpZmllZFN0YXJ0ID09PSBtb2RpZmllZEVuZCArIDEsICdtb2RpZmllZFN0YXJ0IHNob3VsZCBvbmx5IGJlIG9uZSBtb3JlIHRoYW4gbW9kaWZpZWRFbmQnKTsKICAgICAgICAgIC8vIEFsbCBkZWxldGlvbnMKICAgICAgICAgIGNoYW5nZXMgPSBbbmV3IERpZmZDaGFuZ2Uob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0ICsgMSwgbW9kaWZpZWRTdGFydCwgMCldOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBEZWJ1Zy5Bc3NlcnQob3JpZ2luYWxTdGFydCA9PT0gb3JpZ2luYWxFbmQgKyAxLCAnb3JpZ2luYWxTdGFydCBzaG91bGQgb25seSBiZSBvbmUgbW9yZSB0aGFuIG9yaWdpbmFsRW5kJyk7CiAgICAgICAgICBEZWJ1Zy5Bc3NlcnQobW9kaWZpZWRTdGFydCA9PT0gbW9kaWZpZWRFbmQgKyAxLCAnbW9kaWZpZWRTdGFydCBzaG91bGQgb25seSBiZSBvbmUgbW9yZSB0aGFuIG1vZGlmaWVkRW5kJyk7CiAgICAgICAgICAvLyBJZGVudGljYWwgc2VxdWVuY2VzIC0gTm8gZGlmZmVyZW5jZXMKICAgICAgICAgIGNoYW5nZXMgPSBbXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGNoYW5nZXM7CiAgICAgIH0KICAgICAgLy8gVGhpcyBwcm9ibGVtIGNhbiBiZSBzb2x2ZWQgdXNpbmcgdGhlIERpdmlkZS1BbmQtQ29ucXVlciB0ZWNobmlxdWUuCiAgICAgIHZhciBtaWRPcmlnaW5hbEFyciA9IFswXTsKICAgICAgdmFyIG1pZE1vZGlmaWVkQXJyID0gWzBdOwogICAgICB2YXIgcmVzdWx0ID0gdGhpcy5Db21wdXRlUmVjdXJzaW9uUG9pbnQob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kLCBtaWRPcmlnaW5hbEFyciwgbWlkTW9kaWZpZWRBcnIsIHF1aXRFYXJseUFycik7CiAgICAgIHZhciBtaWRPcmlnaW5hbCA9IG1pZE9yaWdpbmFsQXJyWzBdOwogICAgICB2YXIgbWlkTW9kaWZpZWQgPSBtaWRNb2RpZmllZEFyclswXTsKICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkgewogICAgICAgIC8vIFJlc3VsdCBpcyBub3QtbnVsbCB3aGVuIHRoZXJlIHdhcyBlbm91Z2ggbWVtb3J5IHRvIGNvbXB1dGUgdGhlIGNoYW5nZXMgd2hpbGUKICAgICAgICAvLyBzZWFyY2hpbmcgZm9yIHRoZSByZWN1cnNpb24gcG9pbnQKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9IGVsc2UgaWYgKCFxdWl0RWFybHlBcnJbMF0pIHsKICAgICAgICAvLyBXZSBjYW4gYnJlYWsgdGhlIHByb2JsZW0gZG93biByZWN1cnNpdmVseSBieSBmaW5kaW5nIHRoZSBjaGFuZ2VzIGluIHRoZQogICAgICAgIC8vIEZpcnN0IEhhbGY6ICAgKG9yaWdpbmFsU3RhcnQsIG1vZGlmaWVkU3RhcnQpIHRvIChtaWRPcmlnaW5hbCwgbWlkTW9kaWZpZWQpCiAgICAgICAgLy8gU2Vjb25kIEhhbGY6ICAobWlkT3JpZ2luYWwgKyAxLCBtaW5Nb2RpZmllZCArIDEpIHRvIChvcmlnaW5hbEVuZCwgbW9kaWZpZWRFbmQpCiAgICAgICAgLy8gTk9URTogQ29tcHV0ZURpZmYoKSBpcyBpbmNsdXNpdmUsIHRoZXJlZm9yZSB0aGUgc2Vjb25kIHJhbmdlIHN0YXJ0cyBvbiB0aGUgbmV4dCBwb2ludAogICAgICAgIHZhciBsZWZ0Q2hhbmdlcyA9IHRoaXMuQ29tcHV0ZURpZmZSZWN1cnNpdmUob3JpZ2luYWxTdGFydCwgbWlkT3JpZ2luYWwsIG1vZGlmaWVkU3RhcnQsIG1pZE1vZGlmaWVkLCBxdWl0RWFybHlBcnIpOwogICAgICAgIHZhciByaWdodENoYW5nZXMgPSBbXTsKICAgICAgICBpZiAoIXF1aXRFYXJseUFyclswXSkgewogICAgICAgICAgcmlnaHRDaGFuZ2VzID0gdGhpcy5Db21wdXRlRGlmZlJlY3Vyc2l2ZShtaWRPcmlnaW5hbCArIDEsIG9yaWdpbmFsRW5kLCBtaWRNb2RpZmllZCArIDEsIG1vZGlmaWVkRW5kLCBxdWl0RWFybHlBcnIpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyBXZSBkaWRuJ3QgaGF2ZSB0aW1lIHRvIGZpbmlzaCB0aGUgZmlyc3QgaGFsZiwgc28gd2UgZG9uJ3QgaGF2ZSB0aW1lIHRvIGNvbXB1dGUgdGhpcyBoYWxmLgogICAgICAgICAgLy8gQ29uc2lkZXIgdGhlIGVudGlyZSByZXN0IG9mIHRoZSBzZXF1ZW5jZSBkaWZmZXJlbnQuCiAgICAgICAgICByaWdodENoYW5nZXMgPSBbbmV3IERpZmZDaGFuZ2UobWlkT3JpZ2luYWwgKyAxLCBvcmlnaW5hbEVuZCAtIChtaWRPcmlnaW5hbCArIDEpICsgMSwgbWlkTW9kaWZpZWQgKyAxLCBtb2RpZmllZEVuZCAtIChtaWRNb2RpZmllZCArIDEpICsgMSldOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpcy5Db25jYXRlbmF0ZUNoYW5nZXMobGVmdENoYW5nZXMsIHJpZ2h0Q2hhbmdlcyk7CiAgICAgIH0KICAgICAgLy8gSWYgd2UgaGl0IGhlcmUsIHdlIHF1aXQgZWFybHksIGFuZCBzbyBjYW4ndCByZXR1cm4gYW55dGhpbmcgbWVhbmluZ2Z1bAogICAgICByZXR1cm4gW25ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCArIDEsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydCArIDEpXTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJXQUxLVFJBQ0UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIFdBTEtUUkFDRShkaWFnb25hbEZvcndhcmRCYXNlLCBkaWFnb25hbEZvcndhcmRTdGFydCwgZGlhZ29uYWxGb3J3YXJkRW5kLCBkaWFnb25hbEZvcndhcmRPZmZzZXQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCBkaWFnb25hbFJldmVyc2VFbmQsIGRpYWdvbmFsUmV2ZXJzZU9mZnNldCwgZm9yd2FyZFBvaW50cywgcmV2ZXJzZVBvaW50cywgb3JpZ2luYWxJbmRleCwgb3JpZ2luYWxFbmQsIG1pZE9yaWdpbmFsQXJyLCBtb2RpZmllZEluZGV4LCBtb2RpZmllZEVuZCwgbWlkTW9kaWZpZWRBcnIsIGRlbHRhSXNFdmVuLCBxdWl0RWFybHlBcnIpIHsKICAgICAgdmFyIGZvcndhcmRDaGFuZ2VzID0gbnVsbDsKICAgICAgdmFyIHJldmVyc2VDaGFuZ2VzID0gbnVsbDsKICAgICAgLy8gRmlyc3QsIHdhbGsgYmFja3dhcmQgdGhyb3VnaCB0aGUgZm9yd2FyZCBkaWFnb25hbHMgaGlzdG9yeQogICAgICB2YXIgY2hhbmdlSGVscGVyID0gbmV3IERpZmZDaGFuZ2VIZWxwZXIoKTsKICAgICAgdmFyIGRpYWdvbmFsTWluID0gZGlhZ29uYWxGb3J3YXJkU3RhcnQ7CiAgICAgIHZhciBkaWFnb25hbE1heCA9IGRpYWdvbmFsRm9yd2FyZEVuZDsKICAgICAgdmFyIGRpYWdvbmFsUmVsYXRpdmUgPSBtaWRPcmlnaW5hbEFyclswXSAtIG1pZE1vZGlmaWVkQXJyWzBdIC0gZGlhZ29uYWxGb3J3YXJkT2Zmc2V0OwogICAgICB2YXIgbGFzdE9yaWdpbmFsSW5kZXggPSAtMTA3Mzc0MTgyNCAvKiBDb25zdGFudHMuTUlOX1NBRkVfU01BTExfSU5URUdFUiAqLzsKICAgICAgdmFyIGhpc3RvcnlJbmRleCA9IHRoaXMubV9mb3J3YXJkSGlzdG9yeS5sZW5ndGggLSAxOwogICAgICBkbyB7CiAgICAgICAgLy8gR2V0IHRoZSBkaWFnb25hbCBpbmRleCBmcm9tIHRoZSByZWxhdGl2ZSBkaWFnb25hbCBudW1iZXIKICAgICAgICB2YXIgZGlhZ29uYWwgPSBkaWFnb25hbFJlbGF0aXZlICsgZGlhZ29uYWxGb3J3YXJkQmFzZTsKICAgICAgICAvLyBGaWd1cmUgb3V0IHdoZXJlIHdlIGNhbWUgZnJvbQogICAgICAgIGlmIChkaWFnb25hbCA9PT0gZGlhZ29uYWxNaW4gfHwgZGlhZ29uYWwgPCBkaWFnb25hbE1heCAmJiBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsIC0gMV0gPCBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsICsgMV0pIHsKICAgICAgICAgIC8vIFZlcnRpY2FsIGxpbmUgKHRoZSBlbGVtZW50IGlzIGFuIGluc2VydCkKICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsICsgMV07CiAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIGRpYWdvbmFsUmVsYXRpdmUgLSBkaWFnb25hbEZvcndhcmRPZmZzZXQ7CiAgICAgICAgICBpZiAob3JpZ2luYWxJbmRleCA8IGxhc3RPcmlnaW5hbEluZGV4KSB7CiAgICAgICAgICAgIGNoYW5nZUhlbHBlci5NYXJrTmV4dENoYW5nZSgpOwogICAgICAgICAgfQogICAgICAgICAgbGFzdE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4OwogICAgICAgICAgY2hhbmdlSGVscGVyLkFkZE1vZGlmaWVkRWxlbWVudChvcmlnaW5hbEluZGV4ICsgMSwgbW9kaWZpZWRJbmRleCk7CiAgICAgICAgICBkaWFnb25hbFJlbGF0aXZlID0gZGlhZ29uYWwgKyAxIC0gZGlhZ29uYWxGb3J3YXJkQmFzZTsgLy9TZXR1cCBmb3IgdGhlIG5leHQgaXRlcmF0aW9uCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIEhvcml6b250YWwgbGluZSAodGhlIGVsZW1lbnQgaXMgYSBkZWxldGlvbikKICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsIC0gMV0gKyAxOwogICAgICAgICAgbW9kaWZpZWRJbmRleCA9IG9yaWdpbmFsSW5kZXggLSBkaWFnb25hbFJlbGF0aXZlIC0gZGlhZ29uYWxGb3J3YXJkT2Zmc2V0OwogICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPCBsYXN0T3JpZ2luYWxJbmRleCkgewogICAgICAgICAgICBjaGFuZ2VIZWxwZXIuTWFya05leHRDaGFuZ2UoKTsKICAgICAgICAgIH0KICAgICAgICAgIGxhc3RPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIDE7CiAgICAgICAgICBjaGFuZ2VIZWxwZXIuQWRkT3JpZ2luYWxFbGVtZW50KG9yaWdpbmFsSW5kZXgsIG1vZGlmaWVkSW5kZXggKyAxKTsKICAgICAgICAgIGRpYWdvbmFsUmVsYXRpdmUgPSBkaWFnb25hbCAtIDEgLSBkaWFnb25hbEZvcndhcmRCYXNlOyAvL1NldHVwIGZvciB0aGUgbmV4dCBpdGVyYXRpb24KICAgICAgICB9CgogICAgICAgIGlmIChoaXN0b3J5SW5kZXggPj0gMCkgewogICAgICAgICAgZm9yd2FyZFBvaW50cyA9IHRoaXMubV9mb3J3YXJkSGlzdG9yeVtoaXN0b3J5SW5kZXhdOwogICAgICAgICAgZGlhZ29uYWxGb3J3YXJkQmFzZSA9IGZvcndhcmRQb2ludHNbMF07IC8vV2Ugc3RvcmVkIHRoaXMgaW4gdGhlIGZpcnN0IHNwb3QKICAgICAgICAgIGRpYWdvbmFsTWluID0gMTsKICAgICAgICAgIGRpYWdvbmFsTWF4ID0gZm9yd2FyZFBvaW50cy5sZW5ndGggLSAxOwogICAgICAgIH0KICAgICAgfSB3aGlsZSAoLS1oaXN0b3J5SW5kZXggPj0gLTEpOwogICAgICAvLyBJcm9uaWNhbGx5LCB3ZSBnZXQgdGhlIGZvcndhcmQgY2hhbmdlcyBhcyB0aGUgcmV2ZXJzZSBvZiB0aGUKICAgICAgLy8gb3JkZXIgd2UgYWRkZWQgdGhlbSBzaW5jZSB3ZSB0ZWNobmljYWxseSBhZGRlZCB0aGVtIGJhY2t3YXJkcwogICAgICBmb3J3YXJkQ2hhbmdlcyA9IGNoYW5nZUhlbHBlci5nZXRSZXZlcnNlQ2hhbmdlcygpOwogICAgICBpZiAocXVpdEVhcmx5QXJyWzBdKSB7CiAgICAgICAgLy8gVE9ETzogQ2FsY3VsYXRlIGEgcGFydGlhbCBmcm9tIHRoZSByZXZlcnNlIGRpYWdvbmFscy4KICAgICAgICAvLyAgICAgICBGb3Igbm93LCBqdXN0IGFzc3VtZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBtaWRPcmlnaW5hbC9taWRNb2RpZmllZCBwb2ludCBpcyBhIGRpZmYKICAgICAgICB2YXIgb3JpZ2luYWxTdGFydFBvaW50ID0gbWlkT3JpZ2luYWxBcnJbMF0gKyAxOwogICAgICAgIHZhciBtb2RpZmllZFN0YXJ0UG9pbnQgPSBtaWRNb2RpZmllZEFyclswXSArIDE7CiAgICAgICAgaWYgKGZvcndhcmRDaGFuZ2VzICE9PSBudWxsICYmIGZvcndhcmRDaGFuZ2VzLmxlbmd0aCA+IDApIHsKICAgICAgICAgIHZhciBsYXN0Rm9yd2FyZENoYW5nZSA9IGZvcndhcmRDaGFuZ2VzW2ZvcndhcmRDaGFuZ2VzLmxlbmd0aCAtIDFdOwogICAgICAgICAgb3JpZ2luYWxTdGFydFBvaW50ID0gTWF0aC5tYXgob3JpZ2luYWxTdGFydFBvaW50LCBsYXN0Rm9yd2FyZENoYW5nZS5nZXRPcmlnaW5hbEVuZCgpKTsKICAgICAgICAgIG1vZGlmaWVkU3RhcnRQb2ludCA9IE1hdGgubWF4KG1vZGlmaWVkU3RhcnRQb2ludCwgbGFzdEZvcndhcmRDaGFuZ2UuZ2V0TW9kaWZpZWRFbmQoKSk7CiAgICAgICAgfQogICAgICAgIHJldmVyc2VDaGFuZ2VzID0gW25ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnRQb2ludCwgb3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0UG9pbnQgKyAxLCBtb2RpZmllZFN0YXJ0UG9pbnQsIG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydFBvaW50ICsgMSldOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIE5vdyB3YWxrIGJhY2t3YXJkIHRocm91Z2ggdGhlIHJldmVyc2UgZGlhZ29uYWxzIGhpc3RvcnkKICAgICAgICBjaGFuZ2VIZWxwZXIgPSBuZXcgRGlmZkNoYW5nZUhlbHBlcigpOwogICAgICAgIGRpYWdvbmFsTWluID0gZGlhZ29uYWxSZXZlcnNlU3RhcnQ7CiAgICAgICAgZGlhZ29uYWxNYXggPSBkaWFnb25hbFJldmVyc2VFbmQ7CiAgICAgICAgZGlhZ29uYWxSZWxhdGl2ZSA9IG1pZE9yaWdpbmFsQXJyWzBdIC0gbWlkTW9kaWZpZWRBcnJbMF0gLSBkaWFnb25hbFJldmVyc2VPZmZzZXQ7CiAgICAgICAgbGFzdE9yaWdpbmFsSW5kZXggPSAxMDczNzQxODI0IC8qIENvbnN0YW50cy5NQVhfU0FGRV9TTUFMTF9JTlRFR0VSICovOwogICAgICAgIGhpc3RvcnlJbmRleCA9IGRlbHRhSXNFdmVuID8gdGhpcy5tX3JldmVyc2VIaXN0b3J5Lmxlbmd0aCAtIDEgOiB0aGlzLm1fcmV2ZXJzZUhpc3RvcnkubGVuZ3RoIC0gMjsKICAgICAgICBkbyB7CiAgICAgICAgICAvLyBHZXQgdGhlIGRpYWdvbmFsIGluZGV4IGZyb20gdGhlIHJlbGF0aXZlIGRpYWdvbmFsIG51bWJlcgogICAgICAgICAgdmFyIF9kaWFnb25hbCA9IGRpYWdvbmFsUmVsYXRpdmUgKyBkaWFnb25hbFJldmVyc2VCYXNlOwogICAgICAgICAgLy8gRmlndXJlIG91dCB3aGVyZSB3ZSBjYW1lIGZyb20KICAgICAgICAgIGlmIChfZGlhZ29uYWwgPT09IGRpYWdvbmFsTWluIHx8IF9kaWFnb25hbCA8IGRpYWdvbmFsTWF4ICYmIHJldmVyc2VQb2ludHNbX2RpYWdvbmFsIC0gMV0gPj0gcmV2ZXJzZVBvaW50c1tfZGlhZ29uYWwgKyAxXSkgewogICAgICAgICAgICAvLyBIb3Jpem9udGFsIGxpbmUgKHRoZSBlbGVtZW50IGlzIGEgZGVsZXRpb24pKQogICAgICAgICAgICBvcmlnaW5hbEluZGV4ID0gcmV2ZXJzZVBvaW50c1tfZGlhZ29uYWwgKyAxXSAtIDE7CiAgICAgICAgICAgIG1vZGlmaWVkSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gZGlhZ29uYWxSZWxhdGl2ZSAtIGRpYWdvbmFsUmV2ZXJzZU9mZnNldDsKICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPiBsYXN0T3JpZ2luYWxJbmRleCkgewogICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5NYXJrTmV4dENoYW5nZSgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxhc3RPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleCArIDE7CiAgICAgICAgICAgIGNoYW5nZUhlbHBlci5BZGRPcmlnaW5hbEVsZW1lbnQob3JpZ2luYWxJbmRleCArIDEsIG1vZGlmaWVkSW5kZXggKyAxKTsKICAgICAgICAgICAgZGlhZ29uYWxSZWxhdGl2ZSA9IF9kaWFnb25hbCArIDEgLSBkaWFnb25hbFJldmVyc2VCYXNlOyAvL1NldHVwIGZvciB0aGUgbmV4dCBpdGVyYXRpb24KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIFZlcnRpY2FsIGxpbmUgKHRoZSBlbGVtZW50IGlzIGFuIGluc2VydGlvbikKICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IHJldmVyc2VQb2ludHNbX2RpYWdvbmFsIC0gMV07CiAgICAgICAgICAgIG1vZGlmaWVkSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gZGlhZ29uYWxSZWxhdGl2ZSAtIGRpYWdvbmFsUmV2ZXJzZU9mZnNldDsKICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPiBsYXN0T3JpZ2luYWxJbmRleCkgewogICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5NYXJrTmV4dENoYW5nZSgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxhc3RPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleDsKICAgICAgICAgICAgY2hhbmdlSGVscGVyLkFkZE1vZGlmaWVkRWxlbWVudChvcmlnaW5hbEluZGV4ICsgMSwgbW9kaWZpZWRJbmRleCArIDEpOwogICAgICAgICAgICBkaWFnb25hbFJlbGF0aXZlID0gX2RpYWdvbmFsIC0gMSAtIGRpYWdvbmFsUmV2ZXJzZUJhc2U7IC8vU2V0dXAgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbgogICAgICAgICAgfQoKICAgICAgICAgIGlmIChoaXN0b3J5SW5kZXggPj0gMCkgewogICAgICAgICAgICByZXZlcnNlUG9pbnRzID0gdGhpcy5tX3JldmVyc2VIaXN0b3J5W2hpc3RvcnlJbmRleF07CiAgICAgICAgICAgIGRpYWdvbmFsUmV2ZXJzZUJhc2UgPSByZXZlcnNlUG9pbnRzWzBdOyAvL1dlIHN0b3JlZCB0aGlzIGluIHRoZSBmaXJzdCBzcG90CiAgICAgICAgICAgIGRpYWdvbmFsTWluID0gMTsKICAgICAgICAgICAgZGlhZ29uYWxNYXggPSByZXZlcnNlUG9pbnRzLmxlbmd0aCAtIDE7CiAgICAgICAgICB9CiAgICAgICAgfSB3aGlsZSAoLS1oaXN0b3J5SW5kZXggPj0gLTEpOwogICAgICAgIC8vIFRoZXJlIGFyZSBjYXNlcyB3aGVyZSB0aGUgcmV2ZXJzZSBoaXN0b3J5IHdpbGwgZmluZCBkaWZmcyB0aGF0CiAgICAgICAgLy8gYXJlIGNvcnJlY3QsIGJ1dCBub3QgaW50dWl0aXZlLCBzbyB3ZSBuZWVkIHNoaWZ0IHRoZW0uCiAgICAgICAgcmV2ZXJzZUNoYW5nZXMgPSBjaGFuZ2VIZWxwZXIuZ2V0Q2hhbmdlcygpOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLkNvbmNhdGVuYXRlQ2hhbmdlcyhmb3J3YXJkQ2hhbmdlcywgcmV2ZXJzZUNoYW5nZXMpOwogICAgfQogICAgLyoqCiAgICAgKiBHaXZlbiB0aGUgcmFuZ2UgdG8gY29tcHV0ZSB0aGUgZGlmZiBvbiwgdGhpcyBtZXRob2QgZmluZHMgdGhlIHBvaW50OgogICAgICogKG1pZE9yaWdpbmFsLCBtaWRNb2RpZmllZCkKICAgICAqIHRoYXQgZXhpc3RzIGluIHRoZSBtaWRkbGUgb2YgdGhlIExDUyBvZiB0aGUgdHdvIHNlcXVlbmNlcyBhbmQKICAgICAqIGlzIHRoZSBwb2ludCBhdCB3aGljaCB0aGUgTENTIHByb2JsZW0gbWF5IGJlIGJyb2tlbiBkb3duIHJlY3Vyc2l2ZWx5LgogICAgICogVGhpcyBtZXRob2Qgd2lsbCB0cnkgdG8ga2VlcCB0aGUgTENTIHRyYWNlIGluIG1lbW9yeS4gSWYgdGhlIExDUyByZWN1cnNpb24KICAgICAqIHBvaW50IGlzIGNhbGN1bGF0ZWQgYW5kIHRoZSBmdWxsIHRyYWNlIGlzIGF2YWlsYWJsZSBpbiBtZW1vcnksIHRoZW4gdGhpcyBtZXRob2QKICAgICAqIHdpbGwgcmV0dXJuIHRoZSBjaGFuZ2UgbGlzdC4KICAgICAqIEBwYXJhbSBvcmlnaW5hbFN0YXJ0IFRoZSBzdGFydCBib3VuZCBvZiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UgcmFuZ2UKICAgICAqIEBwYXJhbSBvcmlnaW5hbEVuZCBUaGUgZW5kIGJvdW5kIG9mIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZSByYW5nZQogICAgICogQHBhcmFtIG1vZGlmaWVkU3RhcnQgVGhlIHN0YXJ0IGJvdW5kIG9mIHRoZSBtb2RpZmllZCBzZXF1ZW5jZSByYW5nZQogICAgICogQHBhcmFtIG1vZGlmaWVkRW5kIFRoZSBlbmQgYm91bmQgb2YgdGhlIG1vZGlmaWVkIHNlcXVlbmNlIHJhbmdlCiAgICAgKiBAcGFyYW0gbWlkT3JpZ2luYWwgVGhlIG1pZGRsZSBwb2ludCBvZiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UgcmFuZ2UKICAgICAqIEBwYXJhbSBtaWRNb2RpZmllZCBUaGUgbWlkZGxlIHBvaW50IG9mIHRoZSBtb2RpZmllZCBzZXF1ZW5jZSByYW5nZQogICAgICogQHJldHVybnMgVGhlIGRpZmYgY2hhbmdlcywgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgbnVsbAogICAgICovCiAgfSwgewogICAga2V5OiAiQ29tcHV0ZVJlY3Vyc2lvblBvaW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBDb21wdXRlUmVjdXJzaW9uUG9pbnQob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kLCBtaWRPcmlnaW5hbEFyciwgbWlkTW9kaWZpZWRBcnIsIHF1aXRFYXJseUFycikgewogICAgICB2YXIgb3JpZ2luYWxJbmRleCA9IDAsCiAgICAgICAgbW9kaWZpZWRJbmRleCA9IDA7CiAgICAgIHZhciBkaWFnb25hbEZvcndhcmRTdGFydCA9IDAsCiAgICAgICAgZGlhZ29uYWxGb3J3YXJkRW5kID0gMDsKICAgICAgdmFyIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0ID0gMCwKICAgICAgICBkaWFnb25hbFJldmVyc2VFbmQgPSAwOwogICAgICAvLyBUbyB0cmF2ZXJzZSB0aGUgZWRpdCBncmFwaCBhbmQgcHJvZHVjZSB0aGUgcHJvcGVyIExDUywgb3VyIGFjdHVhbAogICAgICAvLyBzdGFydCBwb3NpdGlvbiBpcyBqdXN0IG91dHNpZGUgdGhlIGdpdmVuIGJvdW5kYXJ5CiAgICAgIG9yaWdpbmFsU3RhcnQtLTsKICAgICAgbW9kaWZpZWRTdGFydC0tOwogICAgICAvLyBXZSBzZXQgdGhlc2UgdXAgdG8gbWFrZSB0aGUgY29tcGlsZXIgaGFwcHksIGJ1dCB0aGV5IHdpbGwKICAgICAgLy8gYmUgcmVwbGFjZWQgYmVmb3JlIHdlIHJldHVybiB3aXRoIHRoZSBhY3R1YWwgcmVjdXJzaW9uIHBvaW50CiAgICAgIG1pZE9yaWdpbmFsQXJyWzBdID0gMDsKICAgICAgbWlkTW9kaWZpZWRBcnJbMF0gPSAwOwogICAgICAvLyBDbGVhciBvdXQgdGhlIGhpc3RvcnkKICAgICAgdGhpcy5tX2ZvcndhcmRIaXN0b3J5ID0gW107CiAgICAgIHRoaXMubV9yZXZlcnNlSGlzdG9yeSA9IFtdOwogICAgICAvLyBFYWNoIGNlbGwgaW4gdGhlIHR3byBhcnJheXMgY29ycmVzcG9uZHMgdG8gYSBkaWFnb25hbCBpbiB0aGUgZWRpdCBncmFwaC4KICAgICAgLy8gVGhlIGludGVnZXIgdmFsdWUgaW4gdGhlIGNlbGwgcmVwcmVzZW50cyB0aGUgb3JpZ2luYWxJbmRleCBvZiB0aGUgZnVydGhlc3QKICAgICAgLy8gcmVhY2hpbmcgcG9pbnQgZm91bmQgc28gZmFyIHRoYXQgZW5kcyBpbiB0aGF0IGRpYWdvbmFsLgogICAgICAvLyBUaGUgbW9kaWZpZWRJbmRleCBjYW4gYmUgY29tcHV0ZWQgbWF0aGVtYXRpY2FsbHkgZnJvbSB0aGUgb3JpZ2luYWxJbmRleCBhbmQgdGhlIGRpYWdvbmFsIG51bWJlci4KICAgICAgdmFyIG1heERpZmZlcmVuY2VzID0gb3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0ICsgKG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydCk7CiAgICAgIHZhciBudW1EaWFnb25hbHMgPSBtYXhEaWZmZXJlbmNlcyArIDE7CiAgICAgIHZhciBmb3J3YXJkUG9pbnRzID0gbmV3IEludDMyQXJyYXkobnVtRGlhZ29uYWxzKTsKICAgICAgdmFyIHJldmVyc2VQb2ludHMgPSBuZXcgSW50MzJBcnJheShudW1EaWFnb25hbHMpOwogICAgICAvLyBkaWFnb25hbEZvcndhcmRCYXNlOiBJbmRleCBpbnRvIGZvcndhcmRQb2ludHMgb2YgdGhlIGRpYWdvbmFsIHdoaWNoIHBhc3NlcyB0aHJvdWdoIChvcmlnaW5hbFN0YXJ0LCBtb2RpZmllZFN0YXJ0KQogICAgICAvLyBkaWFnb25hbFJldmVyc2VCYXNlOiBJbmRleCBpbnRvIHJldmVyc2VQb2ludHMgb2YgdGhlIGRpYWdvbmFsIHdoaWNoIHBhc3NlcyB0aHJvdWdoIChvcmlnaW5hbEVuZCwgbW9kaWZpZWRFbmQpCiAgICAgIHZhciBkaWFnb25hbEZvcndhcmRCYXNlID0gbW9kaWZpZWRFbmQgLSBtb2RpZmllZFN0YXJ0OwogICAgICB2YXIgZGlhZ29uYWxSZXZlcnNlQmFzZSA9IG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydDsKICAgICAgLy8gZGlhZ29uYWxGb3J3YXJkT2Zmc2V0OiBHZW9tZXRyaWMgb2Zmc2V0IHdoaWNoIGFsbG93cyBtb2RpZmllZEluZGV4IHRvIGJlIGNvbXB1dGVkIGZyb20gb3JpZ2luYWxJbmRleCBhbmQgdGhlCiAgICAgIC8vICAgIGRpYWdvbmFsIG51bWJlciAocmVsYXRpdmUgdG8gZGlhZ29uYWxGb3J3YXJkQmFzZSkKICAgICAgLy8gZGlhZ29uYWxSZXZlcnNlT2Zmc2V0OiBHZW9tZXRyaWMgb2Zmc2V0IHdoaWNoIGFsbG93cyBtb2RpZmllZEluZGV4IHRvIGJlIGNvbXB1dGVkIGZyb20gb3JpZ2luYWxJbmRleCBhbmQgdGhlCiAgICAgIC8vICAgIGRpYWdvbmFsIG51bWJlciAocmVsYXRpdmUgdG8gZGlhZ29uYWxSZXZlcnNlQmFzZSkKICAgICAgdmFyIGRpYWdvbmFsRm9yd2FyZE9mZnNldCA9IG9yaWdpbmFsU3RhcnQgLSBtb2RpZmllZFN0YXJ0OwogICAgICB2YXIgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0ID0gb3JpZ2luYWxFbmQgLSBtb2RpZmllZEVuZDsKICAgICAgLy8gZGVsdGE6IFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGVuZCBkaWFnb25hbCBhbmQgdGhlIHN0YXJ0IGRpYWdvbmFsLiBUaGlzIGlzIHVzZWQgdG8gcmVsYXRlIGRpYWdvbmFsIG51bWJlcnMKICAgICAgLy8gICByZWxhdGl2ZSB0byB0aGUgc3RhcnQgZGlhZ29uYWwgd2l0aCBkaWFnb25hbCBudW1iZXJzIHJlbGF0aXZlIHRvIHRoZSBlbmQgZGlhZ29uYWwuCiAgICAgIC8vIFRoZSBFdmVuL09kZG4tbmVzcyBvZiB0aGlzIGRlbHRhIGlzIGltcG9ydGFudCBmb3IgZGV0ZXJtaW5pbmcgd2hlbiB3ZSBzaG91bGQgY2hlY2sgZm9yIG92ZXJsYXAKICAgICAgdmFyIGRlbHRhID0gZGlhZ29uYWxSZXZlcnNlQmFzZSAtIGRpYWdvbmFsRm9yd2FyZEJhc2U7CiAgICAgIHZhciBkZWx0YUlzRXZlbiA9IGRlbHRhICUgMiA9PT0gMDsKICAgICAgLy8gSGVyZSB3ZSBzZXQgdXAgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGFzIHRoZSBmdXJ0aGVzdCBwb2ludHMgZm91bmQgc28gZmFyCiAgICAgIC8vIGluIGJvdGggdGhlIGZvcndhcmQgYW5kIHJldmVyc2UgZGlyZWN0aW9ucywgcmVzcGVjdGl2ZWx5CiAgICAgIGZvcndhcmRQb2ludHNbZGlhZ29uYWxGb3J3YXJkQmFzZV0gPSBvcmlnaW5hbFN0YXJ0OwogICAgICByZXZlcnNlUG9pbnRzW2RpYWdvbmFsUmV2ZXJzZUJhc2VdID0gb3JpZ2luYWxFbmQ7CiAgICAgIC8vIFJlbWVtYmVyIGlmIHdlIHF1aXQgZWFybHksIGFuZCB0aHVzIG5lZWQgdG8gZG8gYSBiZXN0LWVmZm9ydCByZXN1bHQgaW5zdGVhZCBvZiBhIHJlYWwgcmVzdWx0LgogICAgICBxdWl0RWFybHlBcnJbMF0gPSBmYWxzZTsKICAgICAgLy8gQSBjb3VwbGUgb2YgcG9pbnRzOgogICAgICAvLyAtLVdpdGggdGhpcyBtZXRob2QsIHdlIGl0ZXJhdGUgb24gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28gc2VxdWVuY2VzLgogICAgICAvLyAgIFRoZSBtb3JlIGRpZmZlcmVuY2VzIHRoZXJlIGFjdHVhbGx5IGFyZSwgdGhlIGxvbmdlciB0aGlzIHdpbGwgdGFrZS4KICAgICAgLy8gLS1BbHNvLCBhcyB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzIGluY3JlYXNlcywgd2UgaGF2ZSB0byBzZWFyY2ggb24gZGlhZ29uYWxzIGZ1cnRoZXIKICAgICAgLy8gICBhd2F5IGZyb20gdGhlIHJlZmVyZW5jZSBkaWFnb25hbCAod2hpY2ggaXMgZGlhZ29uYWxGb3J3YXJkQmFzZSBmb3IgZm9yd2FyZCwgZGlhZ29uYWxSZXZlcnNlQmFzZSBmb3IgcmV2ZXJzZSkuCiAgICAgIC8vIC0tV2UgZXh0ZW5kIG9uIGV2ZW4gZGlhZ29uYWxzIChyZWxhdGl2ZSB0byB0aGUgcmVmZXJlbmNlIGRpYWdvbmFsKSBvbmx5IHdoZW4gbnVtRGlmZmVyZW5jZXMKICAgICAgLy8gICBpcyBldmVuIGFuZCBvZGQgZGlhZ29uYWxzIG9ubHkgd2hlbiBudW1EaWZmZXJlbmNlcyBpcyBvZGQuCiAgICAgIGZvciAodmFyIG51bURpZmZlcmVuY2VzID0gMTsgbnVtRGlmZmVyZW5jZXMgPD0gbWF4RGlmZmVyZW5jZXMgLyAyICsgMTsgbnVtRGlmZmVyZW5jZXMrKykgewogICAgICAgIHZhciBmdXJ0aGVzdE9yaWdpbmFsSW5kZXggPSAwOwogICAgICAgIHZhciBmdXJ0aGVzdE1vZGlmaWVkSW5kZXggPSAwOwogICAgICAgIC8vIFJ1biB0aGUgYWxnb3JpdGhtIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbgogICAgICAgIGRpYWdvbmFsRm9yd2FyZFN0YXJ0ID0gdGhpcy5DbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbEZvcndhcmRCYXNlIC0gbnVtRGlmZmVyZW5jZXMsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbEZvcndhcmRCYXNlLCBudW1EaWFnb25hbHMpOwogICAgICAgIGRpYWdvbmFsRm9yd2FyZEVuZCA9IHRoaXMuQ2xpcERpYWdvbmFsQm91bmQoZGlhZ29uYWxGb3J3YXJkQmFzZSArIG51bURpZmZlcmVuY2VzLCBudW1EaWZmZXJlbmNlcywgZGlhZ29uYWxGb3J3YXJkQmFzZSwgbnVtRGlhZ29uYWxzKTsKICAgICAgICBmb3IgKHZhciBkaWFnb25hbCA9IGRpYWdvbmFsRm9yd2FyZFN0YXJ0OyBkaWFnb25hbCA8PSBkaWFnb25hbEZvcndhcmRFbmQ7IGRpYWdvbmFsICs9IDIpIHsKICAgICAgICAgIC8vIFNURVAgMTogV2UgZXh0ZW5kIHRoZSBmdXJ0aGVzdCByZWFjaGluZyBwb2ludCBpbiB0aGUgcHJlc2VudCBkaWFnb25hbAogICAgICAgICAgLy8gYnkgbG9va2luZyBhdCB0aGUgZGlhZ29uYWxzIGFib3ZlIGFuZCBiZWxvdyBhbmQgcGlja2luZyB0aGUgb25lIHdob3NlIHBvaW50CiAgICAgICAgICAvLyBpcyBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgc3RhcnQgcG9pbnQgKG9yaWdpbmFsU3RhcnQsIG1vZGlmaWVkU3RhcnQpCiAgICAgICAgICBpZiAoZGlhZ29uYWwgPT09IGRpYWdvbmFsRm9yd2FyZFN0YXJ0IHx8IGRpYWdvbmFsIDwgZGlhZ29uYWxGb3J3YXJkRW5kICYmIGZvcndhcmRQb2ludHNbZGlhZ29uYWwgLSAxXSA8IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgKyAxXSkgewogICAgICAgICAgICBvcmlnaW5hbEluZGV4ID0gZm9yd2FyZFBvaW50c1tkaWFnb25hbCArIDFdOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgLSAxXSArIDE7CiAgICAgICAgICB9CiAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIChkaWFnb25hbCAtIGRpYWdvbmFsRm9yd2FyZEJhc2UpIC0gZGlhZ29uYWxGb3J3YXJkT2Zmc2V0OwogICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBvcmlnaW5hbEluZGV4IHNvIHdlIGNhbiB0ZXN0IGZvciBmYWxzZSBvdmVybGFwIGluIHN0ZXAgMwogICAgICAgICAgdmFyIHRlbXBPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleDsKICAgICAgICAgIC8vIFNURVAgMjogV2UgY2FuIGNvbnRpbnVlIHRvIGV4dGVuZCB0aGUgZnVydGhlc3QgcmVhY2hpbmcgcG9pbnQgaW4gdGhlIHByZXNlbnQgZGlhZ29uYWwKICAgICAgICAgIC8vIHNvIGxvbmcgYXMgdGhlIGVsZW1lbnRzIGFyZSBlcXVhbC4KICAgICAgICAgIHdoaWxlIChvcmlnaW5hbEluZGV4IDwgb3JpZ2luYWxFbmQgJiYgbW9kaWZpZWRJbmRleCA8IG1vZGlmaWVkRW5kICYmIHRoaXMuRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbEluZGV4ICsgMSwgbW9kaWZpZWRJbmRleCArIDEpKSB7CiAgICAgICAgICAgIG9yaWdpbmFsSW5kZXgrKzsKICAgICAgICAgICAgbW9kaWZpZWRJbmRleCsrOwogICAgICAgICAgfQogICAgICAgICAgZm9yd2FyZFBvaW50c1tkaWFnb25hbF0gPSBvcmlnaW5hbEluZGV4OwogICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggKyBtb2RpZmllZEluZGV4ID4gZnVydGhlc3RPcmlnaW5hbEluZGV4ICsgZnVydGhlc3RNb2RpZmllZEluZGV4KSB7CiAgICAgICAgICAgIGZ1cnRoZXN0T3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXg7CiAgICAgICAgICAgIGZ1cnRoZXN0TW9kaWZpZWRJbmRleCA9IG1vZGlmaWVkSW5kZXg7CiAgICAgICAgICB9CiAgICAgICAgICAvLyBTVEVQIDM6IElmIGRlbHRhIGlzIG9kZCAob3ZlcmxhcCBmaXJzdCBoYXBwZW5zIG9uIGZvcndhcmQgd2hlbiBkZWx0YSBpcyBvZGQpCiAgICAgICAgICAvLyBhbmQgZGlhZ29uYWwgaXMgaW4gdGhlIHJhbmdlIG9mIHJldmVyc2UgZGlhZ29uYWxzIGNvbXB1dGVkIGZvciBudW1EaWZmZXJlbmNlcy0xCiAgICAgICAgICAvLyAodGhlIHByZXZpb3VzIGl0ZXJhdGlvbjsgd2UgaGF2ZW4ndCBjb21wdXRlZCByZXZlcnNlIGRpYWdvbmFscyBmb3IgbnVtRGlmZmVyZW5jZXMgeWV0KQogICAgICAgICAgLy8gdGhlbiBjaGVjayBmb3Igb3ZlcmxhcC4KICAgICAgICAgIGlmICghZGVsdGFJc0V2ZW4gJiYgTWF0aC5hYnMoZGlhZ29uYWwgLSBkaWFnb25hbFJldmVyc2VCYXNlKSA8PSBudW1EaWZmZXJlbmNlcyAtIDEpIHsKICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPj0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbF0pIHsKICAgICAgICAgICAgICBtaWRPcmlnaW5hbEFyclswXSA9IG9yaWdpbmFsSW5kZXg7CiAgICAgICAgICAgICAgbWlkTW9kaWZpZWRBcnJbMF0gPSBtb2RpZmllZEluZGV4OwogICAgICAgICAgICAgIGlmICh0ZW1wT3JpZ2luYWxJbmRleCA8PSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsXSAmJiAxNDQ3IC8qIExvY2FsQ29uc3RhbnRzLk1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyA+IDAgJiYgbnVtRGlmZmVyZW5jZXMgPD0gMTQ0NyAvKiBMb2NhbENvbnN0YW50cy5NYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8gKyAxKSB7CiAgICAgICAgICAgICAgICAvLyBCSU5HTyEgV2Ugb3ZlcmxhcHBlZCwgYW5kIHdlIGhhdmUgdGhlIGZ1bGwgdHJhY2UgaW4gbWVtb3J5IQogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuV0FMS1RSQUNFKGRpYWdvbmFsRm9yd2FyZEJhc2UsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCBkaWFnb25hbEZvcndhcmRFbmQsIGRpYWdvbmFsRm9yd2FyZE9mZnNldCwgZGlhZ29uYWxSZXZlcnNlQmFzZSwgZGlhZ29uYWxSZXZlcnNlU3RhcnQsIGRpYWdvbmFsUmV2ZXJzZUVuZCwgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0LCBmb3J3YXJkUG9pbnRzLCByZXZlcnNlUG9pbnRzLCBvcmlnaW5hbEluZGV4LCBvcmlnaW5hbEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1vZGlmaWVkSW5kZXgsIG1vZGlmaWVkRW5kLCBtaWRNb2RpZmllZEFyciwgZGVsdGFJc0V2ZW4sIHF1aXRFYXJseUFycik7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIC8vIEVpdGhlciBmYWxzZSBvdmVybGFwLCBvciB3ZSBkaWRuJ3QgaGF2ZSBlbm91Z2ggbWVtb3J5IGZvciB0aGUgZnVsbCB0cmFjZQogICAgICAgICAgICAgICAgLy8gSnVzdCByZXR1cm4gdGhlIHJlY3Vyc2lvbiBwb2ludAogICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgYmUgcXVpdHRpbmcgZWFybHksIGJlZm9yZSBtb3Zpbmcgb24gdG8gdGhlIG5leHQgaXRlcmF0aW9uLgogICAgICAgIHZhciBtYXRjaExlbmd0aE9mTG9uZ2VzdCA9IChmdXJ0aGVzdE9yaWdpbmFsSW5kZXggLSBvcmlnaW5hbFN0YXJ0ICsgKGZ1cnRoZXN0TW9kaWZpZWRJbmRleCAtIG1vZGlmaWVkU3RhcnQpIC0gbnVtRGlmZmVyZW5jZXMpIC8gMjsKICAgICAgICBpZiAodGhpcy5Db250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUgIT09IG51bGwgJiYgIXRoaXMuQ29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlKGZ1cnRoZXN0T3JpZ2luYWxJbmRleCwgbWF0Y2hMZW5ndGhPZkxvbmdlc3QpKSB7CiAgICAgICAgICAvLyBXZSBjYW4ndCBmaW5pc2gsIHNvIHNraXAgYWhlYWQgdG8gZ2VuZXJhdGluZyBhIHJlc3VsdCBmcm9tIHdoYXQgd2UgaGF2ZS4KICAgICAgICAgIHF1aXRFYXJseUFyclswXSA9IHRydWU7CiAgICAgICAgICAvLyBVc2UgdGhlIGZ1cnRoZXN0IGRpc3RhbmNlIHdlIGdvdCBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb24uCiAgICAgICAgICBtaWRPcmlnaW5hbEFyclswXSA9IGZ1cnRoZXN0T3JpZ2luYWxJbmRleDsKICAgICAgICAgIG1pZE1vZGlmaWVkQXJyWzBdID0gZnVydGhlc3RNb2RpZmllZEluZGV4OwogICAgICAgICAgaWYgKG1hdGNoTGVuZ3RoT2ZMb25nZXN0ID4gMCAmJiAxNDQ3IC8qIExvY2FsQ29uc3RhbnRzLk1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyA+IDAgJiYgbnVtRGlmZmVyZW5jZXMgPD0gMTQ0NyAvKiBMb2NhbENvbnN0YW50cy5NYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8gKyAxKSB7CiAgICAgICAgICAgIC8vIEVub3VnaCBvZiB0aGUgaGlzdG9yeSBpcyBpbiBtZW1vcnkgdG8gd2FsayBpdCBiYWNrd2FyZHMKICAgICAgICAgICAgcmV0dXJuIHRoaXMuV0FMS1RSQUNFKGRpYWdvbmFsRm9yd2FyZEJhc2UsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCBkaWFnb25hbEZvcndhcmRFbmQsIGRpYWdvbmFsRm9yd2FyZE9mZnNldCwgZGlhZ29uYWxSZXZlcnNlQmFzZSwgZGlhZ29uYWxSZXZlcnNlU3RhcnQsIGRpYWdvbmFsUmV2ZXJzZUVuZCwgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0LCBmb3J3YXJkUG9pbnRzLCByZXZlcnNlUG9pbnRzLCBvcmlnaW5hbEluZGV4LCBvcmlnaW5hbEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1vZGlmaWVkSW5kZXgsIG1vZGlmaWVkRW5kLCBtaWRNb2RpZmllZEFyciwgZGVsdGFJc0V2ZW4sIHF1aXRFYXJseUFycik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAvLyBXZSBkaWRuJ3QgYWN0dWFsbHkgcmVtZW1iZXIgZW5vdWdoIG9mIHRoZSBoaXN0b3J5LgogICAgICAgICAgICAvL1NpbmNlIHdlIGFyZSBxdWl0dGluZyB0aGUgZGlmZiBlYXJseSwgd2UgbmVlZCB0byBzaGlmdCBiYWNrIHRoZSBvcmlnaW5hbFN0YXJ0IGFuZCBtb2RpZmllZCBzdGFydAogICAgICAgICAgICAvL2JhY2sgaW50byB0aGUgYm91bmRhcnkgbGltaXRzIHNpbmNlIHdlIGRlY3JlbWVudGVkIHRoZWlyIHZhbHVlIGFib3ZlIGJleW9uZCB0aGUgYm91bmRhcnkgbGltaXQuCiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnQrKzsKICAgICAgICAgICAgbW9kaWZpZWRTdGFydCsrOwogICAgICAgICAgICByZXR1cm4gW25ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCArIDEsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydCArIDEpXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgLy8gUnVuIHRoZSBhbGdvcml0aG0gaW4gdGhlIHJldmVyc2UgZGlyZWN0aW9uCiAgICAgICAgZGlhZ29uYWxSZXZlcnNlU3RhcnQgPSB0aGlzLkNsaXBEaWFnb25hbEJvdW5kKGRpYWdvbmFsUmV2ZXJzZUJhc2UgLSBudW1EaWZmZXJlbmNlcywgbnVtRGlmZmVyZW5jZXMsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIG51bURpYWdvbmFscyk7CiAgICAgICAgZGlhZ29uYWxSZXZlcnNlRW5kID0gdGhpcy5DbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbFJldmVyc2VCYXNlICsgbnVtRGlmZmVyZW5jZXMsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbFJldmVyc2VCYXNlLCBudW1EaWFnb25hbHMpOwogICAgICAgIGZvciAodmFyIF9kaWFnb25hbDIgPSBkaWFnb25hbFJldmVyc2VTdGFydDsgX2RpYWdvbmFsMiA8PSBkaWFnb25hbFJldmVyc2VFbmQ7IF9kaWFnb25hbDIgKz0gMikgewogICAgICAgICAgLy8gU1RFUCAxOiBXZSBleHRlbmQgdGhlIGZ1cnRoZXN0IHJlYWNoaW5nIHBvaW50IGluIHRoZSBwcmVzZW50IGRpYWdvbmFsCiAgICAgICAgICAvLyBieSBsb29raW5nIGF0IHRoZSBkaWFnb25hbHMgYWJvdmUgYW5kIGJlbG93IGFuZCBwaWNraW5nIHRoZSBvbmUgd2hvc2UgcG9pbnQKICAgICAgICAgIC8vIGlzIGZ1cnRoZXIgYXdheSBmcm9tIHRoZSBzdGFydCBwb2ludCAob3JpZ2luYWxFbmQsIG1vZGlmaWVkRW5kKQogICAgICAgICAgaWYgKF9kaWFnb25hbDIgPT09IGRpYWdvbmFsUmV2ZXJzZVN0YXJ0IHx8IF9kaWFnb25hbDIgPCBkaWFnb25hbFJldmVyc2VFbmQgJiYgcmV2ZXJzZVBvaW50c1tfZGlhZ29uYWwyIC0gMV0gPj0gcmV2ZXJzZVBvaW50c1tfZGlhZ29uYWwyICsgMV0pIHsKICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IHJldmVyc2VQb2ludHNbX2RpYWdvbmFsMiArIDFdIC0gMTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSByZXZlcnNlUG9pbnRzW19kaWFnb25hbDIgLSAxXTsKICAgICAgICAgIH0KICAgICAgICAgIG1vZGlmaWVkSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gKF9kaWFnb25hbDIgLSBkaWFnb25hbFJldmVyc2VCYXNlKSAtIGRpYWdvbmFsUmV2ZXJzZU9mZnNldDsKICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgb3JpZ2luYWxJbmRleCBzbyB3ZSBjYW4gdGVzdCBmb3IgZmFsc2Ugb3ZlcmxhcAogICAgICAgICAgdmFyIF90ZW1wT3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXg7CiAgICAgICAgICAvLyBTVEVQIDI6IFdlIGNhbiBjb250aW51ZSB0byBleHRlbmQgdGhlIGZ1cnRoZXN0IHJlYWNoaW5nIHBvaW50IGluIHRoZSBwcmVzZW50IGRpYWdvbmFsCiAgICAgICAgICAvLyBhcyBsb25nIGFzIHRoZSBlbGVtZW50cyBhcmUgZXF1YWwuCiAgICAgICAgICB3aGlsZSAob3JpZ2luYWxJbmRleCA+IG9yaWdpbmFsU3RhcnQgJiYgbW9kaWZpZWRJbmRleCA+IG1vZGlmaWVkU3RhcnQgJiYgdGhpcy5FbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsSW5kZXgsIG1vZGlmaWVkSW5kZXgpKSB7CiAgICAgICAgICAgIG9yaWdpbmFsSW5kZXgtLTsKICAgICAgICAgICAgbW9kaWZpZWRJbmRleC0tOwogICAgICAgICAgfQogICAgICAgICAgcmV2ZXJzZVBvaW50c1tfZGlhZ29uYWwyXSA9IG9yaWdpbmFsSW5kZXg7CiAgICAgICAgICAvLyBTVEVQIDQ6IElmIGRlbHRhIGlzIGV2ZW4gKG92ZXJsYXAgZmlyc3QgaGFwcGVucyBvbiByZXZlcnNlIHdoZW4gZGVsdGEgaXMgZXZlbikKICAgICAgICAgIC8vIGFuZCBkaWFnb25hbCBpcyBpbiB0aGUgcmFuZ2Ugb2YgZm9yd2FyZCBkaWFnb25hbHMgY29tcHV0ZWQgZm9yIG51bURpZmZlcmVuY2VzCiAgICAgICAgICAvLyB0aGVuIGNoZWNrIGZvciBvdmVybGFwLgogICAgICAgICAgaWYgKGRlbHRhSXNFdmVuICYmIE1hdGguYWJzKF9kaWFnb25hbDIgLSBkaWFnb25hbEZvcndhcmRCYXNlKSA8PSBudW1EaWZmZXJlbmNlcykgewogICAgICAgICAgICBpZiAob3JpZ2luYWxJbmRleCA8PSBmb3J3YXJkUG9pbnRzW19kaWFnb25hbDJdKSB7CiAgICAgICAgICAgICAgbWlkT3JpZ2luYWxBcnJbMF0gPSBvcmlnaW5hbEluZGV4OwogICAgICAgICAgICAgIG1pZE1vZGlmaWVkQXJyWzBdID0gbW9kaWZpZWRJbmRleDsKICAgICAgICAgICAgICBpZiAoX3RlbXBPcmlnaW5hbEluZGV4ID49IGZvcndhcmRQb2ludHNbX2RpYWdvbmFsMl0gJiYgMTQ0NyAvKiBMb2NhbENvbnN0YW50cy5NYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8gPiAwICYmIG51bURpZmZlcmVuY2VzIDw9IDE0NDcgLyogTG9jYWxDb25zdGFudHMuTWF4RGlmZmVyZW5jZXNIaXN0b3J5ICovICsgMSkgewogICAgICAgICAgICAgICAgLy8gQklOR08hIFdlIG92ZXJsYXBwZWQsIGFuZCB3ZSBoYXZlIHRoZSBmdWxsIHRyYWNlIGluIG1lbW9yeSEKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLldBTEtUUkFDRShkaWFnb25hbEZvcndhcmRCYXNlLCBkaWFnb25hbEZvcndhcmRTdGFydCwgZGlhZ29uYWxGb3J3YXJkRW5kLCBkaWFnb25hbEZvcndhcmRPZmZzZXQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCBkaWFnb25hbFJldmVyc2VFbmQsIGRpYWdvbmFsUmV2ZXJzZU9mZnNldCwgZm9yd2FyZFBvaW50cywgcmV2ZXJzZVBvaW50cywgb3JpZ2luYWxJbmRleCwgb3JpZ2luYWxFbmQsIG1pZE9yaWdpbmFsQXJyLCBtb2RpZmllZEluZGV4LCBtb2RpZmllZEVuZCwgbWlkTW9kaWZpZWRBcnIsIGRlbHRhSXNFdmVuLCBxdWl0RWFybHlBcnIpOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgZmFsc2Ugb3ZlcmxhcCwgb3Igd2UgZGlkbid0IGhhdmUgZW5vdWdoIG1lbW9yeSBmb3IgdGhlIGZ1bGwgdHJhY2UKICAgICAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIHRoZSByZWN1cnNpb24gcG9pbnQKICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAvLyBTYXZlIGN1cnJlbnQgdmVjdG9ycyB0byBoaXN0b3J5IGJlZm9yZSB0aGUgbmV4dCBpdGVyYXRpb24KICAgICAgICBpZiAobnVtRGlmZmVyZW5jZXMgPD0gMTQ0NyAvKiBMb2NhbENvbnN0YW50cy5NYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8pIHsKICAgICAgICAgIC8vIFdlIGFyZSBhbGxvY2F0aW5nIHNwYWNlIGZvciBvbmUgZXh0cmEgaW50LCB3aGljaCB3ZSBmaWxsIHdpdGgKICAgICAgICAgIC8vIHRoZSBpbmRleCBvZiB0aGUgZGlhZ29uYWwgYmFzZSBpbmRleAogICAgICAgICAgdmFyIHRlbXAgPSBuZXcgSW50MzJBcnJheShkaWFnb25hbEZvcndhcmRFbmQgLSBkaWFnb25hbEZvcndhcmRTdGFydCArIDIpOwogICAgICAgICAgdGVtcFswXSA9IGRpYWdvbmFsRm9yd2FyZEJhc2UgLSBkaWFnb25hbEZvcndhcmRTdGFydCArIDE7CiAgICAgICAgICBNeUFycmF5LkNvcHkyKGZvcndhcmRQb2ludHMsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCB0ZW1wLCAxLCBkaWFnb25hbEZvcndhcmRFbmQgLSBkaWFnb25hbEZvcndhcmRTdGFydCArIDEpOwogICAgICAgICAgdGhpcy5tX2ZvcndhcmRIaXN0b3J5LnB1c2godGVtcCk7CiAgICAgICAgICB0ZW1wID0gbmV3IEludDMyQXJyYXkoZGlhZ29uYWxSZXZlcnNlRW5kIC0gZGlhZ29uYWxSZXZlcnNlU3RhcnQgKyAyKTsKICAgICAgICAgIHRlbXBbMF0gPSBkaWFnb25hbFJldmVyc2VCYXNlIC0gZGlhZ29uYWxSZXZlcnNlU3RhcnQgKyAxOwogICAgICAgICAgTXlBcnJheS5Db3B5MihyZXZlcnNlUG9pbnRzLCBkaWFnb25hbFJldmVyc2VTdGFydCwgdGVtcCwgMSwgZGlhZ29uYWxSZXZlcnNlRW5kIC0gZGlhZ29uYWxSZXZlcnNlU3RhcnQgKyAxKTsKICAgICAgICAgIHRoaXMubV9yZXZlcnNlSGlzdG9yeS5wdXNoKHRlbXApOwogICAgICAgIH0KICAgICAgfQogICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgdGhlbiB3ZSBoYXZlIHRoZSBmdWxsIHRyYWNlIGluIGhpc3RvcnkuIFdlIGp1c3QgaGF2ZSB0byBjb252ZXJ0IGl0IHRvIGEgY2hhbmdlIGxpc3QKICAgICAgLy8gTk9URTogVGhpcyBwYXJ0IGlzIGEgYml0IG1lc3N5CiAgICAgIHJldHVybiB0aGlzLldBTEtUUkFDRShkaWFnb25hbEZvcndhcmRCYXNlLCBkaWFnb25hbEZvcndhcmRTdGFydCwgZGlhZ29uYWxGb3J3YXJkRW5kLCBkaWFnb25hbEZvcndhcmRPZmZzZXQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCBkaWFnb25hbFJldmVyc2VFbmQsIGRpYWdvbmFsUmV2ZXJzZU9mZnNldCwgZm9yd2FyZFBvaW50cywgcmV2ZXJzZVBvaW50cywgb3JpZ2luYWxJbmRleCwgb3JpZ2luYWxFbmQsIG1pZE9yaWdpbmFsQXJyLCBtb2RpZmllZEluZGV4LCBtb2RpZmllZEVuZCwgbWlkTW9kaWZpZWRBcnIsIGRlbHRhSXNFdmVuLCBxdWl0RWFybHlBcnIpOwogICAgfQogICAgLyoqCiAgICAgKiBTaGlmdHMgdGhlIGdpdmVuIGNoYW5nZXMgdG8gcHJvdmlkZSBhIG1vcmUgaW50dWl0aXZlIGRpZmYuCiAgICAgKiBXaGlsZSB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIGRpZmYgbWF0Y2hlcyB0aGUgZmlyc3QgZWxlbWVudCBhZnRlciB0aGUgZGlmZiwKICAgICAqIHdlIHNoaWZ0IHRoZSBkaWZmIGRvd24uCiAgICAgKgogICAgICogQHBhcmFtIGNoYW5nZXMgVGhlIGxpc3Qgb2YgY2hhbmdlcyB0byBzaGlmdAogICAgICogQHJldHVybnMgVGhlIHNoaWZ0ZWQgY2hhbmdlcwogICAgICovCiAgfSwgewogICAga2V5OiAiUHJldHRpZnlDaGFuZ2VzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBQcmV0dGlmeUNoYW5nZXMoY2hhbmdlcykgewogICAgICAvLyBTaGlmdCBhbGwgdGhlIGNoYW5nZXMgZG93biBmaXJzdAogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tpXTsKICAgICAgICB2YXIgb3JpZ2luYWxTdG9wID0gaSA8IGNoYW5nZXMubGVuZ3RoIC0gMSA/IGNoYW5nZXNbaSArIDFdLm9yaWdpbmFsU3RhcnQgOiB0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoLmxlbmd0aDsKICAgICAgICB2YXIgbW9kaWZpZWRTdG9wID0gaSA8IGNoYW5nZXMubGVuZ3RoIC0gMSA/IGNoYW5nZXNbaSArIDFdLm1vZGlmaWVkU3RhcnQgOiB0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoLmxlbmd0aDsKICAgICAgICB2YXIgY2hlY2tPcmlnaW5hbCA9IGNoYW5nZS5vcmlnaW5hbExlbmd0aCA+IDA7CiAgICAgICAgdmFyIGNoZWNrTW9kaWZpZWQgPSBjaGFuZ2UubW9kaWZpZWRMZW5ndGggPiAwOwogICAgICAgIHdoaWxlIChjaGFuZ2Uub3JpZ2luYWxTdGFydCArIGNoYW5nZS5vcmlnaW5hbExlbmd0aCA8IG9yaWdpbmFsU3RvcCAmJiBjaGFuZ2UubW9kaWZpZWRTdGFydCArIGNoYW5nZS5tb2RpZmllZExlbmd0aCA8IG1vZGlmaWVkU3RvcCAmJiAoIWNoZWNrT3JpZ2luYWwgfHwgdGhpcy5PcmlnaW5hbEVsZW1lbnRzQXJlRXF1YWwoY2hhbmdlLm9yaWdpbmFsU3RhcnQsIGNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoKSkgJiYgKCFjaGVja01vZGlmaWVkIHx8IHRoaXMuTW9kaWZpZWRFbGVtZW50c0FyZUVxdWFsKGNoYW5nZS5tb2RpZmllZFN0YXJ0LCBjaGFuZ2UubW9kaWZpZWRTdGFydCArIGNoYW5nZS5tb2RpZmllZExlbmd0aCkpKSB7CiAgICAgICAgICB2YXIgc3RhcnRTdHJpY3RFcXVhbCA9IHRoaXMuRWxlbWVudHNBcmVTdHJpY3RFcXVhbChjaGFuZ2Uub3JpZ2luYWxTdGFydCwgY2hhbmdlLm1vZGlmaWVkU3RhcnQpOwogICAgICAgICAgdmFyIGVuZFN0cmljdEVxdWFsID0gdGhpcy5FbGVtZW50c0FyZVN0cmljdEVxdWFsKGNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoLCBjaGFuZ2UubW9kaWZpZWRTdGFydCArIGNoYW5nZS5tb2RpZmllZExlbmd0aCk7CiAgICAgICAgICBpZiAoZW5kU3RyaWN0RXF1YWwgJiYgIXN0YXJ0U3RyaWN0RXF1YWwpIHsKICAgICAgICAgICAgLy8gbW92aW5nIHRoZSBjaGFuZ2UgZG93biB3b3VsZCBjcmVhdGUgYW4gZXF1YWwgY2hhbmdlLCBidXQgdGhlIGVsZW1lbnRzIGFyZSBub3Qgc3RyaWN0IGVxdWFsCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgY2hhbmdlLm9yaWdpbmFsU3RhcnQrKzsKICAgICAgICAgIGNoYW5nZS5tb2RpZmllZFN0YXJ0Kys7CiAgICAgICAgfQogICAgICAgIHZhciBtZXJnZWRDaGFuZ2VBcnIgPSBbbnVsbF07CiAgICAgICAgaWYgKGkgPCBjaGFuZ2VzLmxlbmd0aCAtIDEgJiYgdGhpcy5DaGFuZ2VzT3ZlcmxhcChjaGFuZ2VzW2ldLCBjaGFuZ2VzW2kgKyAxXSwgbWVyZ2VkQ2hhbmdlQXJyKSkgewogICAgICAgICAgY2hhbmdlc1tpXSA9IG1lcmdlZENoYW5nZUFyclswXTsKICAgICAgICAgIGNoYW5nZXMuc3BsaWNlKGkgKyAxLCAxKTsKICAgICAgICAgIGktLTsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KICAgICAgfQogICAgICAvLyBTaGlmdCBjaGFuZ2VzIGJhY2sgdXAgdW50aWwgd2UgaGl0IGVtcHR5IG9yIHdoaXRlc3BhY2Utb25seSBsaW5lcwogICAgICBmb3IgKHZhciBfaSA9IGNoYW5nZXMubGVuZ3RoIC0gMTsgX2kgPj0gMDsgX2ktLSkgewogICAgICAgIHZhciBfY2hhbmdlID0gY2hhbmdlc1tfaV07CiAgICAgICAgdmFyIF9vcmlnaW5hbFN0b3AgPSAwOwogICAgICAgIHZhciBfbW9kaWZpZWRTdG9wID0gMDsKICAgICAgICBpZiAoX2kgPiAwKSB7CiAgICAgICAgICB2YXIgcHJldkNoYW5nZSA9IGNoYW5nZXNbX2kgLSAxXTsKICAgICAgICAgIF9vcmlnaW5hbFN0b3AgPSBwcmV2Q2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBwcmV2Q2hhbmdlLm9yaWdpbmFsTGVuZ3RoOwogICAgICAgICAgX21vZGlmaWVkU3RvcCA9IHByZXZDaGFuZ2UubW9kaWZpZWRTdGFydCArIHByZXZDaGFuZ2UubW9kaWZpZWRMZW5ndGg7CiAgICAgICAgfQogICAgICAgIHZhciBfY2hlY2tPcmlnaW5hbCA9IF9jaGFuZ2Uub3JpZ2luYWxMZW5ndGggPiAwOwogICAgICAgIHZhciBfY2hlY2tNb2RpZmllZCA9IF9jaGFuZ2UubW9kaWZpZWRMZW5ndGggPiAwOwogICAgICAgIHZhciBiZXN0RGVsdGEgPSAwOwogICAgICAgIHZhciBiZXN0U2NvcmUgPSB0aGlzLl9ib3VuZGFyeVNjb3JlKF9jaGFuZ2Uub3JpZ2luYWxTdGFydCwgX2NoYW5nZS5vcmlnaW5hbExlbmd0aCwgX2NoYW5nZS5tb2RpZmllZFN0YXJ0LCBfY2hhbmdlLm1vZGlmaWVkTGVuZ3RoKTsKICAgICAgICBmb3IgKHZhciBkZWx0YSA9IDE7OyBkZWx0YSsrKSB7CiAgICAgICAgICB2YXIgb3JpZ2luYWxTdGFydCA9IF9jaGFuZ2Uub3JpZ2luYWxTdGFydCAtIGRlbHRhOwogICAgICAgICAgdmFyIG1vZGlmaWVkU3RhcnQgPSBfY2hhbmdlLm1vZGlmaWVkU3RhcnQgLSBkZWx0YTsKICAgICAgICAgIGlmIChvcmlnaW5hbFN0YXJ0IDwgX29yaWdpbmFsU3RvcCB8fCBtb2RpZmllZFN0YXJ0IDwgX21vZGlmaWVkU3RvcCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChfY2hlY2tPcmlnaW5hbCAmJiAhdGhpcy5PcmlnaW5hbEVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxTdGFydCArIF9jaGFuZ2Uub3JpZ2luYWxMZW5ndGgpKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKF9jaGVja01vZGlmaWVkICYmICF0aGlzLk1vZGlmaWVkRWxlbWVudHNBcmVFcXVhbChtb2RpZmllZFN0YXJ0LCBtb2RpZmllZFN0YXJ0ICsgX2NoYW5nZS5tb2RpZmllZExlbmd0aCkpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgdG91Y2hpbmdQcmV2aW91c0NoYW5nZSA9IG9yaWdpbmFsU3RhcnQgPT09IF9vcmlnaW5hbFN0b3AgJiYgbW9kaWZpZWRTdGFydCA9PT0gX21vZGlmaWVkU3RvcDsKICAgICAgICAgIHZhciBzY29yZSA9ICh0b3VjaGluZ1ByZXZpb3VzQ2hhbmdlID8gNSA6IDApICsgdGhpcy5fYm91bmRhcnlTY29yZShvcmlnaW5hbFN0YXJ0LCBfY2hhbmdlLm9yaWdpbmFsTGVuZ3RoLCBtb2RpZmllZFN0YXJ0LCBfY2hhbmdlLm1vZGlmaWVkTGVuZ3RoKTsKICAgICAgICAgIGlmIChzY29yZSA+IGJlc3RTY29yZSkgewogICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTsKICAgICAgICAgICAgYmVzdERlbHRhID0gZGVsdGE7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIF9jaGFuZ2Uub3JpZ2luYWxTdGFydCAtPSBiZXN0RGVsdGE7CiAgICAgICAgX2NoYW5nZS5tb2RpZmllZFN0YXJ0IC09IGJlc3REZWx0YTsKICAgICAgICB2YXIgX21lcmdlZENoYW5nZUFyciA9IFtudWxsXTsKICAgICAgICBpZiAoX2kgPiAwICYmIHRoaXMuQ2hhbmdlc092ZXJsYXAoY2hhbmdlc1tfaSAtIDFdLCBjaGFuZ2VzW19pXSwgX21lcmdlZENoYW5nZUFycikpIHsKICAgICAgICAgIGNoYW5nZXNbX2kgLSAxXSA9IF9tZXJnZWRDaGFuZ2VBcnJbMF07CiAgICAgICAgICBjaGFuZ2VzLnNwbGljZShfaSwgMSk7CiAgICAgICAgICBfaSsrOwogICAgICAgICAgY29udGludWU7CiAgICAgICAgfQogICAgICB9CiAgICAgIC8vIFRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGxvbmdlc3QgY29tbW9uIHN1YnN0cmluZ3MuCiAgICAgIC8vIEdpdmUgcHJlZmVyZW5jZSB0byB0aGUgb25lcyBjb250YWluaW5nIGxvbmdlciBsaW5lcwogICAgICBpZiAodGhpcy5faGFzU3RyaW5ncykgewogICAgICAgIGZvciAodmFyIF9pMiA9IDEsIGxlbiA9IGNoYW5nZXMubGVuZ3RoOyBfaTIgPCBsZW47IF9pMisrKSB7CiAgICAgICAgICB2YXIgYUNoYW5nZSA9IGNoYW5nZXNbX2kyIC0gMV07CiAgICAgICAgICB2YXIgYkNoYW5nZSA9IGNoYW5nZXNbX2kyXTsKICAgICAgICAgIHZhciBtYXRjaGVkTGVuZ3RoID0gYkNoYW5nZS5vcmlnaW5hbFN0YXJ0IC0gYUNoYW5nZS5vcmlnaW5hbFN0YXJ0IC0gYUNoYW5nZS5vcmlnaW5hbExlbmd0aDsKICAgICAgICAgIHZhciBhT3JpZ2luYWxTdGFydCA9IGFDaGFuZ2Uub3JpZ2luYWxTdGFydDsKICAgICAgICAgIHZhciBiT3JpZ2luYWxFbmQgPSBiQ2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBiQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoOwogICAgICAgICAgdmFyIGFiT3JpZ2luYWxMZW5ndGggPSBiT3JpZ2luYWxFbmQgLSBhT3JpZ2luYWxTdGFydDsKICAgICAgICAgIHZhciBhTW9kaWZpZWRTdGFydCA9IGFDaGFuZ2UubW9kaWZpZWRTdGFydDsKICAgICAgICAgIHZhciBiTW9kaWZpZWRFbmQgPSBiQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBiQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoOwogICAgICAgICAgdmFyIGFiTW9kaWZpZWRMZW5ndGggPSBiTW9kaWZpZWRFbmQgLSBhTW9kaWZpZWRTdGFydDsKICAgICAgICAgIC8vIEF2b2lkIHdhc3RpbmcgYSBsb3Qgb2YgdGltZSB3aXRoIHRoZXNlIHNlYXJjaGVzCiAgICAgICAgICBpZiAobWF0Y2hlZExlbmd0aCA8IDUgJiYgYWJPcmlnaW5hbExlbmd0aCA8IDIwICYmIGFiTW9kaWZpZWRMZW5ndGggPCAyMCkgewogICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2ZpbmRCZXR0ZXJDb250aWd1b3VzU2VxdWVuY2UoYU9yaWdpbmFsU3RhcnQsIGFiT3JpZ2luYWxMZW5ndGgsIGFNb2RpZmllZFN0YXJ0LCBhYk1vZGlmaWVkTGVuZ3RoLCBtYXRjaGVkTGVuZ3RoKTsKICAgICAgICAgICAgaWYgKHQpIHsKICAgICAgICAgICAgICB2YXIgX3QgPSBfc2xpY2VkVG9BcnJheSh0LCAyKSwKICAgICAgICAgICAgICAgIG9yaWdpbmFsTWF0Y2hTdGFydCA9IF90WzBdLAogICAgICAgICAgICAgICAgbW9kaWZpZWRNYXRjaFN0YXJ0ID0gX3RbMV07CiAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsTWF0Y2hTdGFydCAhPT0gYUNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgYUNoYW5nZS5vcmlnaW5hbExlbmd0aCB8fCBtb2RpZmllZE1hdGNoU3RhcnQgIT09IGFDaGFuZ2UubW9kaWZpZWRTdGFydCArIGFDaGFuZ2UubW9kaWZpZWRMZW5ndGgpIHsKICAgICAgICAgICAgICAgIC8vIHN3aXRjaCB0byBhbm90aGVyIHNlcXVlbmNlIHRoYXQgaGFzIGEgYmV0dGVyIHNjb3JlCiAgICAgICAgICAgICAgICBhQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoID0gb3JpZ2luYWxNYXRjaFN0YXJ0IC0gYUNoYW5nZS5vcmlnaW5hbFN0YXJ0OwogICAgICAgICAgICAgICAgYUNoYW5nZS5tb2RpZmllZExlbmd0aCA9IG1vZGlmaWVkTWF0Y2hTdGFydCAtIGFDaGFuZ2UubW9kaWZpZWRTdGFydDsKICAgICAgICAgICAgICAgIGJDaGFuZ2Uub3JpZ2luYWxTdGFydCA9IG9yaWdpbmFsTWF0Y2hTdGFydCArIG1hdGNoZWRMZW5ndGg7CiAgICAgICAgICAgICAgICBiQ2hhbmdlLm1vZGlmaWVkU3RhcnQgPSBtb2RpZmllZE1hdGNoU3RhcnQgKyBtYXRjaGVkTGVuZ3RoOwogICAgICAgICAgICAgICAgYkNoYW5nZS5vcmlnaW5hbExlbmd0aCA9IGJPcmlnaW5hbEVuZCAtIGJDaGFuZ2Uub3JpZ2luYWxTdGFydDsKICAgICAgICAgICAgICAgIGJDaGFuZ2UubW9kaWZpZWRMZW5ndGggPSBiTW9kaWZpZWRFbmQgLSBiQ2hhbmdlLm1vZGlmaWVkU3RhcnQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBjaGFuZ2VzOwogICAgfQogIH0sIHsKICAgIGtleTogIl9maW5kQmV0dGVyQ29udGlndW91c1NlcXVlbmNlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEJldHRlckNvbnRpZ3VvdXNTZXF1ZW5jZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbExlbmd0aCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRMZW5ndGgsIGRlc2lyZWRMZW5ndGgpIHsKICAgICAgaWYgKG9yaWdpbmFsTGVuZ3RoIDwgZGVzaXJlZExlbmd0aCB8fCBtb2RpZmllZExlbmd0aCA8IGRlc2lyZWRMZW5ndGgpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQogICAgICB2YXIgb3JpZ2luYWxNYXggPSBvcmlnaW5hbFN0YXJ0ICsgb3JpZ2luYWxMZW5ndGggLSBkZXNpcmVkTGVuZ3RoICsgMTsKICAgICAgdmFyIG1vZGlmaWVkTWF4ID0gbW9kaWZpZWRTdGFydCArIG1vZGlmaWVkTGVuZ3RoIC0gZGVzaXJlZExlbmd0aCArIDE7CiAgICAgIHZhciBiZXN0U2NvcmUgPSAwOwogICAgICB2YXIgYmVzdE9yaWdpbmFsU3RhcnQgPSAwOwogICAgICB2YXIgYmVzdE1vZGlmaWVkU3RhcnQgPSAwOwogICAgICBmb3IgKHZhciBpID0gb3JpZ2luYWxTdGFydDsgaSA8IG9yaWdpbmFsTWF4OyBpKyspIHsKICAgICAgICBmb3IgKHZhciBqID0gbW9kaWZpZWRTdGFydDsgaiA8IG1vZGlmaWVkTWF4OyBqKyspIHsKICAgICAgICAgIHZhciBzY29yZSA9IHRoaXMuX2NvbnRpZ3VvdXNTZXF1ZW5jZVNjb3JlKGksIGosIGRlc2lyZWRMZW5ndGgpOwogICAgICAgICAgaWYgKHNjb3JlID4gMCAmJiBzY29yZSA+IGJlc3RTY29yZSkgewogICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTsKICAgICAgICAgICAgYmVzdE9yaWdpbmFsU3RhcnQgPSBpOwogICAgICAgICAgICBiZXN0TW9kaWZpZWRTdGFydCA9IGo7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmIChiZXN0U2NvcmUgPiAwKSB7CiAgICAgICAgcmV0dXJuIFtiZXN0T3JpZ2luYWxTdGFydCwgYmVzdE1vZGlmaWVkU3RhcnRdOwogICAgICB9CiAgICAgIHJldHVybiBudWxsOwogICAgfQogIH0sIHsKICAgIGtleTogIl9jb250aWd1b3VzU2VxdWVuY2VTY29yZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnRpZ3VvdXNTZXF1ZW5jZVNjb3JlKG9yaWdpbmFsU3RhcnQsIG1vZGlmaWVkU3RhcnQsIGxlbmd0aCkgewogICAgICB2YXIgc2NvcmUgPSAwOwogICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxlbmd0aDsgbCsrKSB7CiAgICAgICAgaWYgKCF0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxTdGFydCArIGwsIG1vZGlmaWVkU3RhcnQgKyBsKSkgewogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIHNjb3JlICs9IHRoaXMuX29yaWdpbmFsU3RyaW5nRWxlbWVudHNbb3JpZ2luYWxTdGFydCArIGxdLmxlbmd0aDsKICAgICAgfQogICAgICByZXR1cm4gc2NvcmU7CiAgICB9CiAgfSwgewogICAga2V5OiAiX09yaWdpbmFsSXNCb3VuZGFyeSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX09yaWdpbmFsSXNCb3VuZGFyeShpbmRleCkgewogICAgICBpZiAoaW5kZXggPD0gMCB8fCBpbmRleCA+PSB0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoLmxlbmd0aCAtIDEpIHsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5faGFzU3RyaW5ncyAmJiAvXlxzKiQvLnRlc3QodGhpcy5fb3JpZ2luYWxTdHJpbmdFbGVtZW50c1tpbmRleF0pOwogICAgfQogIH0sIHsKICAgIGtleTogIl9PcmlnaW5hbFJlZ2lvbklzQm91bmRhcnkiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9PcmlnaW5hbFJlZ2lvbklzQm91bmRhcnkob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxMZW5ndGgpIHsKICAgICAgaWYgKHRoaXMuX09yaWdpbmFsSXNCb3VuZGFyeShvcmlnaW5hbFN0YXJ0KSB8fCB0aGlzLl9PcmlnaW5hbElzQm91bmRhcnkob3JpZ2luYWxTdGFydCAtIDEpKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KICAgICAgaWYgKG9yaWdpbmFsTGVuZ3RoID4gMCkgewogICAgICAgIHZhciBvcmlnaW5hbEVuZCA9IG9yaWdpbmFsU3RhcnQgKyBvcmlnaW5hbExlbmd0aDsKICAgICAgICBpZiAodGhpcy5fT3JpZ2luYWxJc0JvdW5kYXJ5KG9yaWdpbmFsRW5kIC0gMSkgfHwgdGhpcy5fT3JpZ2luYWxJc0JvdW5kYXJ5KG9yaWdpbmFsRW5kKSkgewogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJfTW9kaWZpZWRJc0JvdW5kYXJ5IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfTW9kaWZpZWRJc0JvdW5kYXJ5KGluZGV4KSB7CiAgICAgIGlmIChpbmRleCA8PSAwIHx8IGluZGV4ID49IHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2gubGVuZ3RoIC0gMSkgewogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLl9oYXNTdHJpbmdzICYmIC9eXHMqJC8udGVzdCh0aGlzLl9tb2RpZmllZFN0cmluZ0VsZW1lbnRzW2luZGV4XSk7CiAgICB9CiAgfSwgewogICAga2V5OiAiX01vZGlmaWVkUmVnaW9uSXNCb3VuZGFyeSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX01vZGlmaWVkUmVnaW9uSXNCb3VuZGFyeShtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCkgewogICAgICBpZiAodGhpcy5fTW9kaWZpZWRJc0JvdW5kYXJ5KG1vZGlmaWVkU3RhcnQpIHx8IHRoaXMuX01vZGlmaWVkSXNCb3VuZGFyeShtb2RpZmllZFN0YXJ0IC0gMSkpIHsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgICBpZiAobW9kaWZpZWRMZW5ndGggPiAwKSB7CiAgICAgICAgdmFyIG1vZGlmaWVkRW5kID0gbW9kaWZpZWRTdGFydCArIG1vZGlmaWVkTGVuZ3RoOwogICAgICAgIGlmICh0aGlzLl9Nb2RpZmllZElzQm91bmRhcnkobW9kaWZpZWRFbmQgLSAxKSB8fCB0aGlzLl9Nb2RpZmllZElzQm91bmRhcnkobW9kaWZpZWRFbmQpKSB7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogIH0sIHsKICAgIGtleTogIl9ib3VuZGFyeVNjb3JlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfYm91bmRhcnlTY29yZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbExlbmd0aCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRMZW5ndGgpIHsKICAgICAgdmFyIG9yaWdpbmFsU2NvcmUgPSB0aGlzLl9PcmlnaW5hbFJlZ2lvbklzQm91bmRhcnkob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxMZW5ndGgpID8gMSA6IDA7CiAgICAgIHZhciBtb2RpZmllZFNjb3JlID0gdGhpcy5fTW9kaWZpZWRSZWdpb25Jc0JvdW5kYXJ5KG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkTGVuZ3RoKSA/IDEgOiAwOwogICAgICByZXR1cm4gb3JpZ2luYWxTY29yZSArIG1vZGlmaWVkU2NvcmU7CiAgICB9CiAgICAvKioKICAgICAqIENvbmNhdGVuYXRlcyB0aGUgdHdvIGlucHV0IERpZmZDaGFuZ2UgbGlzdHMgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZwogICAgICogbGlzdC4KICAgICAqIEBwYXJhbSBUaGUgbGVmdCBjaGFuZ2VzCiAgICAgKiBAcGFyYW0gVGhlIHJpZ2h0IGNoYW5nZXMKICAgICAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQgbGlzdAogICAgICovCiAgfSwgewogICAga2V5OiAiQ29uY2F0ZW5hdGVDaGFuZ2VzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBDb25jYXRlbmF0ZUNoYW5nZXMobGVmdCwgcmlnaHQpIHsKICAgICAgdmFyIG1lcmdlZENoYW5nZUFyciA9IFtdOwogICAgICBpZiAobGVmdC5sZW5ndGggPT09IDAgfHwgcmlnaHQubGVuZ3RoID09PSAwKSB7CiAgICAgICAgcmV0dXJuIHJpZ2h0Lmxlbmd0aCA+IDAgPyByaWdodCA6IGxlZnQ7CiAgICAgIH0gZWxzZSBpZiAodGhpcy5DaGFuZ2VzT3ZlcmxhcChsZWZ0W2xlZnQubGVuZ3RoIC0gMV0sIHJpZ2h0WzBdLCBtZXJnZWRDaGFuZ2VBcnIpKSB7CiAgICAgICAgLy8gU2luY2Ugd2UgYnJlYWsgdGhlIHByb2JsZW0gZG93biByZWN1cnNpdmVseSwgaXQgaXMgcG9zc2libGUgdGhhdCB3ZQogICAgICAgIC8vIG1pZ2h0IHJlY3Vyc2UgaW4gdGhlIG1pZGRsZSBvZiBhIGNoYW5nZSB0aGVyZWJ5IHNwbGl0dGluZyBpdCBpbnRvCiAgICAgICAgLy8gdHdvIGNoYW5nZXMuIEhlcmUgaW4gdGhlIGNvbWJpbmluZyBzdGFnZSwgd2UgZGV0ZWN0IGFuZCBmdXNlIHRob3NlCiAgICAgICAgLy8gY2hhbmdlcyBiYWNrIHRvZ2V0aGVyCiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShsZWZ0Lmxlbmd0aCArIHJpZ2h0Lmxlbmd0aCAtIDEpOwogICAgICAgIE15QXJyYXkuQ29weShsZWZ0LCAwLCByZXN1bHQsIDAsIGxlZnQubGVuZ3RoIC0gMSk7CiAgICAgICAgcmVzdWx0W2xlZnQubGVuZ3RoIC0gMV0gPSBtZXJnZWRDaGFuZ2VBcnJbMF07CiAgICAgICAgTXlBcnJheS5Db3B5KHJpZ2h0LCAxLCByZXN1bHQsIGxlZnQubGVuZ3RoLCByaWdodC5sZW5ndGggLSAxKTsKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9IGVsc2UgewogICAgICAgIHZhciBfcmVzdWx0ID0gbmV3IEFycmF5KGxlZnQubGVuZ3RoICsgcmlnaHQubGVuZ3RoKTsKICAgICAgICBNeUFycmF5LkNvcHkobGVmdCwgMCwgX3Jlc3VsdCwgMCwgbGVmdC5sZW5ndGgpOwogICAgICAgIE15QXJyYXkuQ29weShyaWdodCwgMCwgX3Jlc3VsdCwgbGVmdC5sZW5ndGgsIHJpZ2h0Lmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIF9yZXN1bHQ7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gY2hhbmdlcyBvdmVybGFwIGFuZCBjYW4gYmUgbWVyZ2VkIGludG8gYSBzaW5nbGUKICAgICAqIGNoYW5nZQogICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgY2hhbmdlCiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IGNoYW5nZQogICAgICogQHBhcmFtIG1lcmdlZENoYW5nZSBUaGUgbWVyZ2VkIGNoYW5nZSBpZiB0aGUgdHdvIG92ZXJsYXAsIG51bGwgb3RoZXJ3aXNlCiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB0d28gY2hhbmdlcyBvdmVybGFwCiAgICAgKi8KICB9LCB7CiAgICBrZXk6ICJDaGFuZ2VzT3ZlcmxhcCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gQ2hhbmdlc092ZXJsYXAobGVmdCwgcmlnaHQsIG1lcmdlZENoYW5nZUFycikgewogICAgICBEZWJ1Zy5Bc3NlcnQobGVmdC5vcmlnaW5hbFN0YXJ0IDw9IHJpZ2h0Lm9yaWdpbmFsU3RhcnQsICdMZWZ0IGNoYW5nZSBpcyBub3QgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHJpZ2h0IGNoYW5nZScpOwogICAgICBEZWJ1Zy5Bc3NlcnQobGVmdC5tb2RpZmllZFN0YXJ0IDw9IHJpZ2h0Lm1vZGlmaWVkU3RhcnQsICdMZWZ0IGNoYW5nZSBpcyBub3QgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHJpZ2h0IGNoYW5nZScpOwogICAgICBpZiAobGVmdC5vcmlnaW5hbFN0YXJ0ICsgbGVmdC5vcmlnaW5hbExlbmd0aCA+PSByaWdodC5vcmlnaW5hbFN0YXJ0IHx8IGxlZnQubW9kaWZpZWRTdGFydCArIGxlZnQubW9kaWZpZWRMZW5ndGggPj0gcmlnaHQubW9kaWZpZWRTdGFydCkgewogICAgICAgIHZhciBvcmlnaW5hbFN0YXJ0ID0gbGVmdC5vcmlnaW5hbFN0YXJ0OwogICAgICAgIHZhciBvcmlnaW5hbExlbmd0aCA9IGxlZnQub3JpZ2luYWxMZW5ndGg7CiAgICAgICAgdmFyIG1vZGlmaWVkU3RhcnQgPSBsZWZ0Lm1vZGlmaWVkU3RhcnQ7CiAgICAgICAgdmFyIG1vZGlmaWVkTGVuZ3RoID0gbGVmdC5tb2RpZmllZExlbmd0aDsKICAgICAgICBpZiAobGVmdC5vcmlnaW5hbFN0YXJ0ICsgbGVmdC5vcmlnaW5hbExlbmd0aCA+PSByaWdodC5vcmlnaW5hbFN0YXJ0KSB7CiAgICAgICAgICBvcmlnaW5hbExlbmd0aCA9IHJpZ2h0Lm9yaWdpbmFsU3RhcnQgKyByaWdodC5vcmlnaW5hbExlbmd0aCAtIGxlZnQub3JpZ2luYWxTdGFydDsKICAgICAgICB9CiAgICAgICAgaWYgKGxlZnQubW9kaWZpZWRTdGFydCArIGxlZnQubW9kaWZpZWRMZW5ndGggPj0gcmlnaHQubW9kaWZpZWRTdGFydCkgewogICAgICAgICAgbW9kaWZpZWRMZW5ndGggPSByaWdodC5tb2RpZmllZFN0YXJ0ICsgcmlnaHQubW9kaWZpZWRMZW5ndGggLSBsZWZ0Lm1vZGlmaWVkU3RhcnQ7CiAgICAgICAgfQogICAgICAgIG1lcmdlZENoYW5nZUFyclswXSA9IG5ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsTGVuZ3RoLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbWVyZ2VkQ2hhbmdlQXJyWzBdID0gbnVsbDsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogSGVscGVyIG1ldGhvZCB1c2VkIHRvIGNsaXAgYSBkaWFnb25hbCBpbmRleCB0byB0aGUgcmFuZ2Ugb2YgdmFsaWQKICAgICAqIGRpYWdvbmFscy4gVGhpcyBhbHNvIGRlY2lkZXMgd2hldGhlciBvciBub3QgdGhlIGRpYWdvbmFsIGluZGV4LAogICAgICogaWYgaXQgZXhjZWVkcyB0aGUgYm91bmRhcnksIHNob3VsZCBiZSBjbGlwcGVkIHRvIHRoZSBib3VuZGFyeSBvciBjbGlwcGVkCiAgICAgKiBvbmUgaW5zaWRlIHRoZSBib3VuZGFyeSBkZXBlbmRpbmcgb24gdGhlIEV2ZW4vT2RkIHN0YXR1cyBvZiB0aGUgYm91bmRhcnkKICAgICAqIGFuZCBudW1EaWZmZXJlbmNlcy4KICAgICAqIEBwYXJhbSBkaWFnb25hbCBUaGUgaW5kZXggb2YgdGhlIGRpYWdvbmFsIHRvIGNsaXAuCiAgICAgKiBAcGFyYW0gbnVtRGlmZmVyZW5jZXMgVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGRpZmZlcmVuY2VzIGJlaW5nIGl0ZXJhdGVkIHVwb24uCiAgICAgKiBAcGFyYW0gZGlhZ29uYWxCYXNlSW5kZXggVGhlIGJhc2UgcmVmZXJlbmNlIGRpYWdvbmFsLgogICAgICogQHBhcmFtIG51bURpYWdvbmFscyBUaGUgdG90YWwgbnVtYmVyIG9mIGRpYWdvbmFscy4KICAgICAqIEByZXR1cm5zIFRoZSBjbGlwcGVkIGRpYWdvbmFsIGluZGV4LgogICAgICovCiAgfSwgewogICAga2V5OiAiQ2xpcERpYWdvbmFsQm91bmQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIENsaXBEaWFnb25hbEJvdW5kKGRpYWdvbmFsLCBudW1EaWZmZXJlbmNlcywgZGlhZ29uYWxCYXNlSW5kZXgsIG51bURpYWdvbmFscykgewogICAgICBpZiAoZGlhZ29uYWwgPj0gMCAmJiBkaWFnb25hbCA8IG51bURpYWdvbmFscykgewogICAgICAgIC8vIE5vdGhpbmcgdG8gY2xpcCwgaXRzIGluIHJhbmdlCiAgICAgICAgcmV0dXJuIGRpYWdvbmFsOwogICAgICB9CiAgICAgIC8vIGRpYWdvbmFsc0JlbG93OiBUaGUgbnVtYmVyIG9mIGRpYWdvbmFscyBiZWxvdyB0aGUgcmVmZXJlbmNlIGRpYWdvbmFsCiAgICAgIC8vIGRpYWdvbmFsc0Fib3ZlOiBUaGUgbnVtYmVyIG9mIGRpYWdvbmFscyBhYm92ZSB0aGUgcmVmZXJlbmNlIGRpYWdvbmFsCiAgICAgIHZhciBkaWFnb25hbHNCZWxvdyA9IGRpYWdvbmFsQmFzZUluZGV4OwogICAgICB2YXIgZGlhZ29uYWxzQWJvdmUgPSBudW1EaWFnb25hbHMgLSBkaWFnb25hbEJhc2VJbmRleCAtIDE7CiAgICAgIHZhciBkaWZmRXZlbiA9IG51bURpZmZlcmVuY2VzICUgMiA9PT0gMDsKICAgICAgaWYgKGRpYWdvbmFsIDwgMCkgewogICAgICAgIHZhciBsb3dlckJvdW5kRXZlbiA9IGRpYWdvbmFsc0JlbG93ICUgMiA9PT0gMDsKICAgICAgICByZXR1cm4gZGlmZkV2ZW4gPT09IGxvd2VyQm91bmRFdmVuID8gMCA6IDE7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFyIHVwcGVyQm91bmRFdmVuID0gZGlhZ29uYWxzQWJvdmUgJSAyID09PSAwOwogICAgICAgIHJldHVybiBkaWZmRXZlbiA9PT0gdXBwZXJCb3VuZEV2ZW4gPyBudW1EaWFnb25hbHMgLSAxIDogbnVtRGlhZ29uYWxzIC0gMjsKICAgICAgfQogICAgfQogIH1dLCBbewogICAga2V5OiAiX2lzU3RyaW5nQXJyYXkiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1N0cmluZ0FycmF5KGFycikgewogICAgICByZXR1cm4gYXJyLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyclswXSA9PT0gJ3N0cmluZyc7CiAgICB9CiAgfSwgewogICAga2V5OiAiX2dldEVsZW1lbnRzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RWxlbWVudHMoc2VxdWVuY2UpIHsKICAgICAgdmFyIGVsZW1lbnRzID0gc2VxdWVuY2UuZ2V0RWxlbWVudHMoKTsKICAgICAgaWYgKExjc0RpZmYuX2lzU3RyaW5nQXJyYXkoZWxlbWVudHMpKSB7CiAgICAgICAgdmFyIGhhc2hlcyA9IG5ldyBJbnQzMkFycmF5KGVsZW1lbnRzLmxlbmd0aCk7CiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICBoYXNoZXNbaV0gPSBzdHJpbmdIYXNoKGVsZW1lbnRzW2ldLCAwKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIFtlbGVtZW50cywgaGFzaGVzLCB0cnVlXTsKICAgICAgfQogICAgICBpZiAoZWxlbWVudHMgaW5zdGFuY2VvZiBJbnQzMkFycmF5KSB7CiAgICAgICAgcmV0dXJuIFtbXSwgZWxlbWVudHMsIGZhbHNlXTsKICAgICAgfQogICAgICByZXR1cm4gW1tdLCBuZXcgSW50MzJBcnJheShlbGVtZW50cyksIGZhbHNlXTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJfZ2V0U3RyaWN0RWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0cmljdEVsZW1lbnQoc2VxdWVuY2UsIGluZGV4KSB7CiAgICAgIGlmICh0eXBlb2Ygc2VxdWVuY2UuZ2V0U3RyaWN0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgIHJldHVybiBzZXF1ZW5jZS5nZXRTdHJpY3RFbGVtZW50KGluZGV4KTsKICAgICAgfQogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICB9XSk7CiAgcmV0dXJuIExjc0RpZmY7Cn0oKTs="},{"version":3,"names":["DiffChange","stringHash","StringDiffSequence","source","characters","Int32Array","length","i","len","charCodeAt","stringDiff","original","modified","pretty","LcsDiff","ComputeDiff","changes","Debug","condition","message","Error","MyArray","sourceArray","sourceIndex","destinationArray","destinationIndex","DiffChangeHelper","m_changes","m_originalStart","m_modifiedStart","m_originalCount","m_modifiedCount","push","originalIndex","modifiedIndex","Math","min","MarkNextChange","reverse","originalSequence","modifiedSequence","continueProcessingPredicate","ContinueProcessingPredicate","_originalSequence","_modifiedSequence","_getElements","originalStringElements","originalElementsOrHash","originalHasStrings","modifiedStringElements","modifiedElementsOrHash","modifiedHasStrings","_hasStrings","_originalStringElements","_originalElementsOrHash","_modifiedStringElements","_modifiedElementsOrHash","m_forwardHistory","m_reverseHistory","newIndex","ElementsAreEqual","originalElement","_getStrictElement","modifiedElement","index1","index2","_ComputeDiff","originalStart","originalEnd","modifiedStart","modifiedEnd","quitEarlyArr","ComputeDiffRecursive","PrettifyChanges","quitEarly","Assert","midOriginalArr","midModifiedArr","result","ComputeRecursionPoint","midOriginal","midModified","leftChanges","rightChanges","ConcatenateChanges","diagonalForwardBase","diagonalForwardStart","diagonalForwardEnd","diagonalForwardOffset","diagonalReverseBase","diagonalReverseStart","diagonalReverseEnd","diagonalReverseOffset","forwardPoints","reversePoints","deltaIsEven","forwardChanges","reverseChanges","changeHelper","diagonalMin","diagonalMax","diagonalRelative","lastOriginalIndex","historyIndex","diagonal","AddModifiedElement","AddOriginalElement","getReverseChanges","originalStartPoint","modifiedStartPoint","lastForwardChange","max","getOriginalEnd","getModifiedEnd","getChanges","maxDifferences","numDiagonals","delta","numDifferences","furthestOriginalIndex","furthestModifiedIndex","ClipDiagonalBound","tempOriginalIndex","abs","WALKTRACE","matchLengthOfLongest","temp","Copy2","change","originalStop","modifiedStop","checkOriginal","originalLength","checkModified","modifiedLength","OriginalElementsAreEqual","ModifiedElementsAreEqual","startStrictEqual","ElementsAreStrictEqual","endStrictEqual","mergedChangeArr","ChangesOverlap","splice","prevChange","bestDelta","bestScore","_boundaryScore","touchingPreviousChange","score","aChange","bChange","matchedLength","aOriginalStart","bOriginalEnd","abOriginalLength","aModifiedStart","bModifiedEnd","abModifiedLength","t","_findBetterContiguousSequence","originalMatchStart","modifiedMatchStart","desiredLength","originalMax","modifiedMax","bestOriginalStart","bestModifiedStart","j","_contiguousSequenceScore","l","index","test","_OriginalIsBoundary","_ModifiedIsBoundary","originalScore","_OriginalRegionIsBoundary","modifiedScore","_ModifiedRegionIsBoundary","left","right","Array","Copy","diagonalBaseIndex","diagonalsBelow","diagonalsAbove","diffEven","lowerBoundEven","upperBoundEven","arr","sequence","elements","getElements","_isStringArray","hashes","getStrictElement"],"sources":["/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { DiffChange } from './diffChange.js';\nimport { stringHash } from '../hash.js';\nexport class StringDiffSequence {\n    constructor(source) {\n        this.source = source;\n    }\n    getElements() {\n        const source = this.source;\n        const characters = new Int32Array(source.length);\n        for (let i = 0, len = source.length; i < len; i++) {\n            characters[i] = source.charCodeAt(i);\n        }\n        return characters;\n    }\n}\nexport function stringDiff(original, modified, pretty) {\n    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\n}\n//\n// The code below has been ported from a C# implementation in VS\n//\nexport class Debug {\n    static Assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n}\nexport class MyArray {\n    /**\n     * Copies a range of elements from an Array starting at the specified source index and pastes\n     * them to another Array starting at the specified destination index. The length and the indexes\n     * are specified as 64-bit integers.\n     * sourceArray:\n     *\t\tThe Array that contains the data to copy.\n     * sourceIndex:\n     *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n     * destinationArray:\n     *\t\tThe Array that receives the data.\n     * destinationIndex:\n     *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n     * length:\n     *\t\tA 64-bit integer that represents the number of elements to copy.\n     */\n    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (let i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    }\n    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (let i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    }\n}\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarkNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\nclass DiffChangeHelper {\n    /**\n     * Constructs a new DiffChangeHelper for the given DiffSequences.\n     */\n    constructor() {\n        this.m_changes = [];\n        this.m_originalStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        this.m_modifiedStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n    }\n    /**\n     * Marks the beginning of the next change in the set of differences.\n     */\n    MarkNextChange() {\n        // Only add to the list if there is something to add\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Add the new change to our list\n            this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\n        }\n        // Reset for the next change\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n        this.m_originalStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        this.m_modifiedStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n    }\n    /**\n     * Adds the original element at the given position to the elements\n     * affected by the current change. The modified index gives context\n     * to the change position with respect to the original sequence.\n     * @param originalIndex The index of the original element to add.\n     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n     */\n    AddOriginalElement(originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_originalCount++;\n    }\n    /**\n     * Adds the modified element at the given position to the elements\n     * affected by the current change. The original index gives context\n     * to the change position with respect to the modified sequence.\n     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n     * @param modifiedIndex The index of the modified element to add.\n     */\n    AddModifiedElement(originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_modifiedCount++;\n    }\n    /**\n     * Retrieves all of the changes marked by the class.\n     */\n    getChanges() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        return this.m_changes;\n    }\n    /**\n     * Retrieves all of the changes marked by the class in the reverse order\n     */\n    getReverseChanges() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        this.m_changes.reverse();\n        return this.m_changes;\n    }\n}\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n */\nexport class LcsDiff {\n    /**\n     * Constructs the DiffFinder\n     */\n    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {\n        this.ContinueProcessingPredicate = continueProcessingPredicate;\n        this._originalSequence = originalSequence;\n        this._modifiedSequence = modifiedSequence;\n        const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\n        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\n        this._hasStrings = (originalHasStrings && modifiedHasStrings);\n        this._originalStringElements = originalStringElements;\n        this._originalElementsOrHash = originalElementsOrHash;\n        this._modifiedStringElements = modifiedStringElements;\n        this._modifiedElementsOrHash = modifiedElementsOrHash;\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n    }\n    static _isStringArray(arr) {\n        return (arr.length > 0 && typeof arr[0] === 'string');\n    }\n    static _getElements(sequence) {\n        const elements = sequence.getElements();\n        if (LcsDiff._isStringArray(elements)) {\n            const hashes = new Int32Array(elements.length);\n            for (let i = 0, len = elements.length; i < len; i++) {\n                hashes[i] = stringHash(elements[i], 0);\n            }\n            return [elements, hashes, true];\n        }\n        if (elements instanceof Int32Array) {\n            return [[], elements, false];\n        }\n        return [[], new Int32Array(elements), false];\n    }\n    ElementsAreEqual(originalIndex, newIndex) {\n        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n            return false;\n        }\n        return (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);\n    }\n    ElementsAreStrictEqual(originalIndex, newIndex) {\n        if (!this.ElementsAreEqual(originalIndex, newIndex)) {\n            return false;\n        }\n        const originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);\n        const modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);\n        return (originalElement === modifiedElement);\n    }\n    static _getStrictElement(sequence, index) {\n        if (typeof sequence.getStrictElement === 'function') {\n            return sequence.getStrictElement(index);\n        }\n        return null;\n    }\n    OriginalElementsAreEqual(index1, index2) {\n        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n            return false;\n        }\n        return (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);\n    }\n    ModifiedElementsAreEqual(index1, index2) {\n        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n            return false;\n        }\n        return (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);\n    }\n    ComputeDiff(pretty) {\n        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n    }\n    /**\n     * Computes the differences between the original and modified input\n     * sequences on the bounded range.\n     * @returns An array of the differences between the two input sequences.\n     */\n    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n        const quitEarlyArr = [false];\n        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n        if (pretty) {\n            // We have to clean up the computed diff to be more intuitive\n            // but it turns out this cannot be done correctly until the entire set\n            // of diffs have been computed\n            changes = this.PrettifyChanges(changes);\n        }\n        return {\n            quitEarly: quitEarlyArr[0],\n            changes: changes\n        };\n    }\n    /**\n     * Private helper method which computes the differences on the bounded range\n     * recursively.\n     * @returns An array of the differences between the two input sequences.\n     */\n    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n        quitEarlyArr[0] = false;\n        // Find the start of the differences\n        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n            originalStart++;\n            modifiedStart++;\n        }\n        // Find the end of the differences\n        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n            originalEnd--;\n            modifiedEnd--;\n        }\n        // In the special case where we either have all insertions or all deletions or the sequences are identical\n        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n            let changes;\n            if (modifiedStart <= modifiedEnd) {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                // All insertions\n                changes = [\n                    new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n                ];\n            }\n            else if (originalStart <= originalEnd) {\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // All deletions\n                changes = [\n                    new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n                ];\n            }\n            else {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // Identical sequences - No differences\n                changes = [];\n            }\n            return changes;\n        }\n        // This problem can be solved using the Divide-And-Conquer technique.\n        const midOriginalArr = [0];\n        const midModifiedArr = [0];\n        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n        const midOriginal = midOriginalArr[0];\n        const midModified = midModifiedArr[0];\n        if (result !== null) {\n            // Result is not-null when there was enough memory to compute the changes while\n            // searching for the recursion point\n            return result;\n        }\n        else if (!quitEarlyArr[0]) {\n            // We can break the problem down recursively by finding the changes in the\n            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n            let rightChanges = [];\n            if (!quitEarlyArr[0]) {\n                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n            }\n            else {\n                // We didn't have time to finish the first half, so we don't have time to compute this half.\n                // Consider the entire rest of the sequence different.\n                rightChanges = [\n                    new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n                ];\n            }\n            return this.ConcatenateChanges(leftChanges, rightChanges);\n        }\n        // If we hit here, we quit early, and so can't return anything meaningful\n        return [\n            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n        ];\n    }\n    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n        let forwardChanges = null;\n        let reverseChanges = null;\n        // First, walk backward through the forward diagonals history\n        let changeHelper = new DiffChangeHelper();\n        let diagonalMin = diagonalForwardStart;\n        let diagonalMax = diagonalForwardEnd;\n        let diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\n        let lastOriginalIndex = -1073741824 /* Constants.MIN_SAFE_SMALL_INTEGER */;\n        let historyIndex = this.m_forwardHistory.length - 1;\n        do {\n            // Get the diagonal index from the relative diagonal number\n            const diagonal = diagonalRelative + diagonalForwardBase;\n            // Figure out where we came from\n            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                // Vertical line (the element is an insert)\n                originalIndex = forwardPoints[diagonal + 1];\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex;\n                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            else {\n                // Horizontal line (the element is a deletion)\n                originalIndex = forwardPoints[diagonal - 1] + 1;\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex - 1;\n                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            if (historyIndex >= 0) {\n                forwardPoints = this.m_forwardHistory[historyIndex];\n                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n                diagonalMin = 1;\n                diagonalMax = forwardPoints.length - 1;\n            }\n        } while (--historyIndex >= -1);\n        // Ironically, we get the forward changes as the reverse of the\n        // order we added them since we technically added them backwards\n        forwardChanges = changeHelper.getReverseChanges();\n        if (quitEarlyArr[0]) {\n            // TODO: Calculate a partial from the reverse diagonals.\n            //       For now, just assume everything after the midOriginal/midModified point is a diff\n            let originalStartPoint = midOriginalArr[0] + 1;\n            let modifiedStartPoint = midModifiedArr[0] + 1;\n            if (forwardChanges !== null && forwardChanges.length > 0) {\n                const lastForwardChange = forwardChanges[forwardChanges.length - 1];\n                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n            }\n            reverseChanges = [\n                new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n            ];\n        }\n        else {\n            // Now walk backward through the reverse diagonals history\n            changeHelper = new DiffChangeHelper();\n            diagonalMin = diagonalReverseStart;\n            diagonalMax = diagonalReverseEnd;\n            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\n            lastOriginalIndex = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n            do {\n                // Get the diagonal index from the relative diagonal number\n                const diagonal = diagonalRelative + diagonalReverseBase;\n                // Figure out where we came from\n                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    // Horizontal line (the element is a deletion))\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex + 1;\n                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                else {\n                    // Vertical line (the element is an insertion)\n                    originalIndex = reversePoints[diagonal - 1];\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex;\n                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                if (historyIndex >= 0) {\n                    reversePoints = this.m_reverseHistory[historyIndex];\n                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n                    diagonalMin = 1;\n                    diagonalMax = reversePoints.length - 1;\n                }\n            } while (--historyIndex >= -1);\n            // There are cases where the reverse history will find diffs that\n            // are correct, but not intuitive, so we need shift them.\n            reverseChanges = changeHelper.getChanges();\n        }\n        return this.ConcatenateChanges(forwardChanges, reverseChanges);\n    }\n    /**\n     * Given the range to compute the diff on, this method finds the point:\n     * (midOriginal, midModified)\n     * that exists in the middle of the LCS of the two sequences and\n     * is the point at which the LCS problem may be broken down recursively.\n     * This method will try to keep the LCS trace in memory. If the LCS recursion\n     * point is calculated and the full trace is available in memory, then this method\n     * will return the change list.\n     * @param originalStart The start bound of the original sequence range\n     * @param originalEnd The end bound of the original sequence range\n     * @param modifiedStart The start bound of the modified sequence range\n     * @param modifiedEnd The end bound of the modified sequence range\n     * @param midOriginal The middle point of the original sequence range\n     * @param midModified The middle point of the modified sequence range\n     * @returns The diff changes, if available, otherwise null\n     */\n    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n        let originalIndex = 0, modifiedIndex = 0;\n        let diagonalForwardStart = 0, diagonalForwardEnd = 0;\n        let diagonalReverseStart = 0, diagonalReverseEnd = 0;\n        // To traverse the edit graph and produce the proper LCS, our actual\n        // start position is just outside the given boundary\n        originalStart--;\n        modifiedStart--;\n        // We set these up to make the compiler happy, but they will\n        // be replaced before we return with the actual recursion point\n        midOriginalArr[0] = 0;\n        midModifiedArr[0] = 0;\n        // Clear out the history\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n        // Each cell in the two arrays corresponds to a diagonal in the edit graph.\n        // The integer value in the cell represents the originalIndex of the furthest\n        // reaching point found so far that ends in that diagonal.\n        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n        const maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\n        const numDiagonals = maxDifferences + 1;\n        const forwardPoints = new Int32Array(numDiagonals);\n        const reversePoints = new Int32Array(numDiagonals);\n        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n        const diagonalForwardBase = (modifiedEnd - modifiedStart);\n        const diagonalReverseBase = (originalEnd - originalStart);\n        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalForwardBase)\n        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalReverseBase)\n        const diagonalForwardOffset = (originalStart - modifiedStart);\n        const diagonalReverseOffset = (originalEnd - modifiedEnd);\n        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n        const delta = diagonalReverseBase - diagonalForwardBase;\n        const deltaIsEven = (delta % 2 === 0);\n        // Here we set up the start and end points as the furthest points found so far\n        // in both the forward and reverse directions, respectively\n        forwardPoints[diagonalForwardBase] = originalStart;\n        reversePoints[diagonalReverseBase] = originalEnd;\n        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n        quitEarlyArr[0] = false;\n        // A couple of points:\n        // --With this method, we iterate on the number of differences between the two sequences.\n        //   The more differences there actually are, the longer this will take.\n        // --Also, as the number of differences increases, we have to search on diagonals further\n        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n        //   is even and odd diagonals only when numDifferences is odd.\n        for (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\n            let furthestOriginalIndex = 0;\n            let furthestModifiedIndex = 0;\n            // Run the algorithm in the forward direction\n            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalStart, modifiedStart)\n                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                    originalIndex = forwardPoints[diagonal + 1];\n                }\n                else {\n                    originalIndex = forwardPoints[diagonal - 1] + 1;\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n                // Save the current originalIndex so we can test for false overlap in step 3\n                const tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // so long as the elements are equal.\n                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n                    originalIndex++;\n                    modifiedIndex++;\n                }\n                forwardPoints[diagonal] = originalIndex;\n                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n                    furthestOriginalIndex = originalIndex;\n                    furthestModifiedIndex = modifiedIndex;\n                }\n                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n                // and diagonal is in the range of reverse diagonals computed for numDifferences-1\n                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n                // then check for overlap.\n                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\n                    if (originalIndex >= reversePoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* LocalConstants.MaxDifferencesHistory */ + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Check to see if we should be quitting early, before moving on to the next iteration.\n            const matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n                // We can't finish, so skip ahead to generating a result from what we have.\n                quitEarlyArr[0] = true;\n                // Use the furthest distance we got in the forward direction.\n                midOriginalArr[0] = furthestOriginalIndex;\n                midModifiedArr[0] = furthestModifiedIndex;\n                if (matchLengthOfLongest > 0 && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* LocalConstants.MaxDifferencesHistory */ + 1)) {\n                    // Enough of the history is in memory to walk it backwards\n                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                }\n                else {\n                    // We didn't actually remember enough of the history.\n                    //Since we are quitting the diff early, we need to shift back the originalStart and modified start\n                    //back into the boundary limits since we decremented their value above beyond the boundary limit.\n                    originalStart++;\n                    modifiedStart++;\n                    return [\n                        new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n                    ];\n                }\n            }\n            // Run the algorithm in the reverse direction\n            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalEnd, modifiedEnd)\n                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                }\n                else {\n                    originalIndex = reversePoints[diagonal - 1];\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n                // Save the current originalIndex so we can test for false overlap\n                const tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // as long as the elements are equal.\n                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n                    originalIndex--;\n                    modifiedIndex--;\n                }\n                reversePoints[diagonal] = originalIndex;\n                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n                // and diagonal is in the range of forward diagonals computed for numDifferences\n                // then check for overlap.\n                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n                    if (originalIndex <= forwardPoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* LocalConstants.MaxDifferencesHistory */ + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Save current vectors to history before the next iteration\n            if (numDifferences <= 1447 /* LocalConstants.MaxDifferencesHistory */) {\n                // We are allocating space for one extra int, which we fill with\n                // the index of the diagonal base index\n                let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\n                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n                MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n                this.m_forwardHistory.push(temp);\n                temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\n                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n                MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n                this.m_reverseHistory.push(temp);\n            }\n        }\n        // If we got here, then we have the full trace in history. We just have to convert it to a change list\n        // NOTE: This part is a bit messy\n        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n    }\n    /**\n     * Shifts the given changes to provide a more intuitive diff.\n     * While the first element in a diff matches the first element after the diff,\n     * we shift the diff down.\n     *\n     * @param changes The list of changes to shift\n     * @returns The shifted changes\n     */\n    PrettifyChanges(changes) {\n        // Shift all the changes down first\n        for (let i = 0; i < changes.length; i++) {\n            const change = changes[i];\n            const originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n            const modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n            const checkOriginal = change.originalLength > 0;\n            const checkModified = change.modifiedLength > 0;\n            while (change.originalStart + change.originalLength < originalStop\n                && change.modifiedStart + change.modifiedLength < modifiedStop\n                && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength))\n                && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n                const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);\n                const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);\n                if (endStrictEqual && !startStrictEqual) {\n                    // moving the change down would create an equal change, but the elements are not strict equal\n                    break;\n                }\n                change.originalStart++;\n                change.modifiedStart++;\n            }\n            const mergedChangeArr = [null];\n            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n                changes[i] = mergedChangeArr[0];\n                changes.splice(i + 1, 1);\n                i--;\n                continue;\n            }\n        }\n        // Shift changes back up until we hit empty or whitespace-only lines\n        for (let i = changes.length - 1; i >= 0; i--) {\n            const change = changes[i];\n            let originalStop = 0;\n            let modifiedStop = 0;\n            if (i > 0) {\n                const prevChange = changes[i - 1];\n                originalStop = prevChange.originalStart + prevChange.originalLength;\n                modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n            }\n            const checkOriginal = change.originalLength > 0;\n            const checkModified = change.modifiedLength > 0;\n            let bestDelta = 0;\n            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n            for (let delta = 1;; delta++) {\n                const originalStart = change.originalStart - delta;\n                const modifiedStart = change.modifiedStart - delta;\n                if (originalStart < originalStop || modifiedStart < modifiedStop) {\n                    break;\n                }\n                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n                    break;\n                }\n                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n                    break;\n                }\n                const touchingPreviousChange = (originalStart === originalStop && modifiedStart === modifiedStop);\n                const score = ((touchingPreviousChange ? 5 : 0)\n                    + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength));\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestDelta = delta;\n                }\n            }\n            change.originalStart -= bestDelta;\n            change.modifiedStart -= bestDelta;\n            const mergedChangeArr = [null];\n            if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {\n                changes[i - 1] = mergedChangeArr[0];\n                changes.splice(i, 1);\n                i++;\n                continue;\n            }\n        }\n        // There could be multiple longest common substrings.\n        // Give preference to the ones containing longer lines\n        if (this._hasStrings) {\n            for (let i = 1, len = changes.length; i < len; i++) {\n                const aChange = changes[i - 1];\n                const bChange = changes[i];\n                const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\n                const aOriginalStart = aChange.originalStart;\n                const bOriginalEnd = bChange.originalStart + bChange.originalLength;\n                const abOriginalLength = bOriginalEnd - aOriginalStart;\n                const aModifiedStart = aChange.modifiedStart;\n                const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\n                const abModifiedLength = bModifiedEnd - aModifiedStart;\n                // Avoid wasting a lot of time with these searches\n                if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\n                    const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\n                    if (t) {\n                        const [originalMatchStart, modifiedMatchStart] = t;\n                        if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\n                            // switch to another sequence that has a better score\n                            aChange.originalLength = originalMatchStart - aChange.originalStart;\n                            aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\n                            bChange.originalStart = originalMatchStart + matchedLength;\n                            bChange.modifiedStart = modifiedMatchStart + matchedLength;\n                            bChange.originalLength = bOriginalEnd - bChange.originalStart;\n                            bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\n                        }\n                    }\n                }\n            }\n        }\n        return changes;\n    }\n    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\n        if (originalLength < desiredLength || modifiedLength < desiredLength) {\n            return null;\n        }\n        const originalMax = originalStart + originalLength - desiredLength + 1;\n        const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\n        let bestScore = 0;\n        let bestOriginalStart = 0;\n        let bestModifiedStart = 0;\n        for (let i = originalStart; i < originalMax; i++) {\n            for (let j = modifiedStart; j < modifiedMax; j++) {\n                const score = this._contiguousSequenceScore(i, j, desiredLength);\n                if (score > 0 && score > bestScore) {\n                    bestScore = score;\n                    bestOriginalStart = i;\n                    bestModifiedStart = j;\n                }\n            }\n        }\n        if (bestScore > 0) {\n            return [bestOriginalStart, bestModifiedStart];\n        }\n        return null;\n    }\n    _contiguousSequenceScore(originalStart, modifiedStart, length) {\n        let score = 0;\n        for (let l = 0; l < length; l++) {\n            if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\n                return 0;\n            }\n            score += this._originalStringElements[originalStart + l].length;\n        }\n        return score;\n    }\n    _OriginalIsBoundary(index) {\n        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\n            return true;\n        }\n        return (this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]));\n    }\n    _OriginalRegionIsBoundary(originalStart, originalLength) {\n        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n            return true;\n        }\n        if (originalLength > 0) {\n            const originalEnd = originalStart + originalLength;\n            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _ModifiedIsBoundary(index) {\n        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\n            return true;\n        }\n        return (this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]));\n    }\n    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\n        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n            return true;\n        }\n        if (modifiedLength > 0) {\n            const modifiedEnd = modifiedStart + modifiedLength;\n            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\n        const originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\n        const modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\n        return (originalScore + modifiedScore);\n    }\n    /**\n     * Concatenates the two input DiffChange lists and returns the resulting\n     * list.\n     * @param The left changes\n     * @param The right changes\n     * @returns The concatenated list\n     */\n    ConcatenateChanges(left, right) {\n        const mergedChangeArr = [];\n        if (left.length === 0 || right.length === 0) {\n            return (right.length > 0) ? right : left;\n        }\n        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n            // Since we break the problem down recursively, it is possible that we\n            // might recurse in the middle of a change thereby splitting it into\n            // two changes. Here in the combining stage, we detect and fuse those\n            // changes back together\n            const result = new Array(left.length + right.length - 1);\n            MyArray.Copy(left, 0, result, 0, left.length - 1);\n            result[left.length - 1] = mergedChangeArr[0];\n            MyArray.Copy(right, 1, result, left.length, right.length - 1);\n            return result;\n        }\n        else {\n            const result = new Array(left.length + right.length);\n            MyArray.Copy(left, 0, result, 0, left.length);\n            MyArray.Copy(right, 0, result, left.length, right.length);\n            return result;\n        }\n    }\n    /**\n     * Returns true if the two changes overlap and can be merged into a single\n     * change\n     * @param left The left change\n     * @param right The right change\n     * @param mergedChange The merged change if the two overlap, null otherwise\n     * @returns True if the two changes overlap\n     */\n    ChangesOverlap(left, right, mergedChangeArr) {\n        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n            const originalStart = left.originalStart;\n            let originalLength = left.originalLength;\n            const modifiedStart = left.modifiedStart;\n            let modifiedLength = left.modifiedLength;\n            if (left.originalStart + left.originalLength >= right.originalStart) {\n                originalLength = right.originalStart + right.originalLength - left.originalStart;\n            }\n            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n            }\n            mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n            return true;\n        }\n        else {\n            mergedChangeArr[0] = null;\n            return false;\n        }\n    }\n    /**\n     * Helper method used to clip a diagonal index to the range of valid\n     * diagonals. This also decides whether or not the diagonal index,\n     * if it exceeds the boundary, should be clipped to the boundary or clipped\n     * one inside the boundary depending on the Even/Odd status of the boundary\n     * and numDifferences.\n     * @param diagonal The index of the diagonal to clip.\n     * @param numDifferences The current number of differences being iterated upon.\n     * @param diagonalBaseIndex The base reference diagonal.\n     * @param numDiagonals The total number of diagonals.\n     * @returns The clipped diagonal index.\n     */\n    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n        if (diagonal >= 0 && diagonal < numDiagonals) {\n            // Nothing to clip, its in range\n            return diagonal;\n        }\n        // diagonalsBelow: The number of diagonals below the reference diagonal\n        // diagonalsAbove: The number of diagonals above the reference diagonal\n        const diagonalsBelow = diagonalBaseIndex;\n        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n        const diffEven = (numDifferences % 2 === 0);\n        if (diagonal < 0) {\n            const lowerBoundEven = (diagonalsBelow % 2 === 0);\n            return (diffEven === lowerBoundEven) ? 0 : 1;\n        }\n        else {\n            const upperBoundEven = (diagonalsAbove % 2 === 0);\n            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\n        }\n    }\n}\n"],"mappings":"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"}]}