{"remainingRequest":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js!/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js","dependencies":[{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/babel.config.js","mtime":1668271197000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js","mtime":456789000000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9Vc2Vycy95YW5qaWFqaWEvRGVza3RvcC93b3Jrc3BhY2UvYXZ1ZS1kYXRhLW5ldy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlci5qcyI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiL1VzZXJzL3lhbmppYWppYS9EZXNrdG9wL3dvcmtzcGFjZS9hdnVlLWRhdGEtbmV3L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjay5qcyI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiL1VzZXJzL3lhbmppYWppYS9EZXNrdG9wL3dvcmtzcGFjZS9hdnVlLWRhdGEtbmV3L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qcyI7CmltcG9ydCBfdHlwZW9mIGZyb20gIi9Vc2Vycy95YW5qaWFqaWEvRGVza3RvcC93b3Jrc3BhY2UvYXZ1ZS1kYXRhLW5ldy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LnRvLXN0cmluZy10YWcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucHVzaC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmpzb24uc3RyaW5naWZ5LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0YWxpY3MuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuYm9sZC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4uanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS1idWZmZXIuc2xpY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS51aW50MzItYXJyYXkuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5hdC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZXZlcnkuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWxsLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsdGVyLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQtaW5kZXguanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWxhc3QuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWxhc3QtaW5kZXguanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluY2x1ZGVzLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5kZXgtb2YuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmpvaW4uanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5sYXN0LWluZGV4LW9mLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlLXJpZ2h0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNldC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNsaWNlLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvcnQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zdWJhcnJheS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1zdHJpbmcuanMiOwovKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLgogKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi8KdmFyIF9fZGVjb3JhdGUgPSB0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHsKICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsCiAgICByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywKICAgIGQ7CiAgaWYgKCh0eXBlb2YgUmVmbGVjdCA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6IF90eXBlb2YoUmVmbGVjdCkpID09PSAib2JqZWN0IiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gImZ1bmN0aW9uIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO2Vsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsKICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7CiAgfQogIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7Cn07CnZhciBfX3BhcmFtID0gdGhpcyAmJiB0aGlzLl9fcGFyYW0gfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikgewogIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsKICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7CiAgfTsKfTsKaW1wb3J0IHsgVG9rZW5NZXRhZGF0YSB9IGZyb20gJy4uL2VuY29kZWRUb2tlbkF0dHJpYnV0ZXMuanMnOwppbXBvcnQgeyBJVGhlbWVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vcGxhdGZvcm0vdGhlbWUvY29tbW9uL3RoZW1lU2VydmljZS5qcyc7CmltcG9ydCB7IElMb2dTZXJ2aWNlLCBMb2dMZXZlbCB9IGZyb20gJy4uLy4uLy4uL3BsYXRmb3JtL2xvZy9jb21tb24vbG9nLmpzJzsKaW1wb3J0IHsgU3BhcnNlTXVsdGlsaW5lVG9rZW5zIH0gZnJvbSAnLi4vdG9rZW5zL3NwYXJzZU11bHRpbGluZVRva2Vucy5qcyc7CmltcG9ydCB7IElMYW5ndWFnZVNlcnZpY2UgfSBmcm9tICcuLi9sYW5ndWFnZXMvbGFuZ3VhZ2UuanMnOwp2YXIgU2VtYW50aWNUb2tlbnNQcm92aWRlclN0eWxpbmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIGZ1bmN0aW9uIFNlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nKF9sZWdlbmQsIF90aGVtZVNlcnZpY2UsIF9sYW5ndWFnZVNlcnZpY2UsIF9sb2dTZXJ2aWNlKSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VtYW50aWNUb2tlbnNQcm92aWRlclN0eWxpbmcpOwogICAgdGhpcy5fbGVnZW5kID0gX2xlZ2VuZDsKICAgIHRoaXMuX3RoZW1lU2VydmljZSA9IF90aGVtZVNlcnZpY2U7CiAgICB0aGlzLl9sYW5ndWFnZVNlcnZpY2UgPSBfbGFuZ3VhZ2VTZXJ2aWNlOwogICAgdGhpcy5fbG9nU2VydmljZSA9IF9sb2dTZXJ2aWNlOwogICAgdGhpcy5faGFzV2FybmVkT3ZlcmxhcHBpbmdUb2tlbnMgPSBmYWxzZTsKICAgIHRoaXMuX2hhc1dhcm5lZEludmFsaWRMZW5ndGhUb2tlbnMgPSBmYWxzZTsKICAgIHRoaXMuX2hhc1dhcm5lZEludmFsaWRFZGl0U3RhcnQgPSBmYWxzZTsKICAgIHRoaXMuX2hhc2hUYWJsZSA9IG5ldyBIYXNoVGFibGUoKTsKICB9CiAgX2NyZWF0ZUNsYXNzKFNlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nLCBbewogICAga2V5OiAiZ2V0TWV0YWRhdGEiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1ldGFkYXRhKHRva2VuVHlwZUluZGV4LCB0b2tlbk1vZGlmaWVyU2V0LCBsYW5ndWFnZUlkKSB7CiAgICAgIHZhciBlbmNvZGVkTGFuZ3VhZ2VJZCA9IHRoaXMuX2xhbmd1YWdlU2VydmljZS5sYW5ndWFnZUlkQ29kZWMuZW5jb2RlTGFuZ3VhZ2VJZChsYW5ndWFnZUlkKTsKICAgICAgdmFyIGVudHJ5ID0gdGhpcy5faGFzaFRhYmxlLmdldCh0b2tlblR5cGVJbmRleCwgdG9rZW5Nb2RpZmllclNldCwgZW5jb2RlZExhbmd1YWdlSWQpOwogICAgICB2YXIgbWV0YWRhdGE7CiAgICAgIGlmIChlbnRyeSkgewogICAgICAgIG1ldGFkYXRhID0gZW50cnkubWV0YWRhdGE7CiAgICAgICAgaWYgKHRoaXMuX2xvZ1NlcnZpY2UuZ2V0TGV2ZWwoKSA9PT0gTG9nTGV2ZWwuVHJhY2UpIHsKICAgICAgICAgIHRoaXMuX2xvZ1NlcnZpY2UudHJhY2UoIlNlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nIFtDQUNIRURdICIuY29uY2F0KHRva2VuVHlwZUluZGV4LCAiIC8gIikuY29uY2F0KHRva2VuTW9kaWZpZXJTZXQsICI6IGZvcmVncm91bmQgIikuY29uY2F0KFRva2VuTWV0YWRhdGEuZ2V0Rm9yZWdyb3VuZChtZXRhZGF0YSksICIsIGZvbnRTdHlsZSAiKS5jb25jYXQoVG9rZW5NZXRhZGF0YS5nZXRGb250U3R5bGUobWV0YWRhdGEpLnRvU3RyaW5nKDIpKSk7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIHZhciB0b2tlblR5cGUgPSB0aGlzLl9sZWdlbmQudG9rZW5UeXBlc1t0b2tlblR5cGVJbmRleF07CiAgICAgICAgdmFyIHRva2VuTW9kaWZpZXJzID0gW107CiAgICAgICAgaWYgKHRva2VuVHlwZSkgewogICAgICAgICAgdmFyIG1vZGlmaWVyU2V0ID0gdG9rZW5Nb2RpZmllclNldDsKICAgICAgICAgIGZvciAodmFyIG1vZGlmaWVySW5kZXggPSAwOyBtb2RpZmllclNldCA+IDAgJiYgbW9kaWZpZXJJbmRleCA8IHRoaXMuX2xlZ2VuZC50b2tlbk1vZGlmaWVycy5sZW5ndGg7IG1vZGlmaWVySW5kZXgrKykgewogICAgICAgICAgICBpZiAobW9kaWZpZXJTZXQgJiAxKSB7CiAgICAgICAgICAgICAgdG9rZW5Nb2RpZmllcnMucHVzaCh0aGlzLl9sZWdlbmQudG9rZW5Nb2RpZmllcnNbbW9kaWZpZXJJbmRleF0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG1vZGlmaWVyU2V0ID0gbW9kaWZpZXJTZXQgPj4gMTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChtb2RpZmllclNldCA+IDAgJiYgdGhpcy5fbG9nU2VydmljZS5nZXRMZXZlbCgpID09PSBMb2dMZXZlbC5UcmFjZSkgewogICAgICAgICAgICB0aGlzLl9sb2dTZXJ2aWNlLnRyYWNlKCJTZW1hbnRpY1Rva2Vuc1Byb3ZpZGVyU3R5bGluZzogdW5rbm93biB0b2tlbiBtb2RpZmllciBpbmRleDogIi5jb25jYXQodG9rZW5Nb2RpZmllclNldC50b1N0cmluZygyKSwgIiBmb3IgbGVnZW5kOiAiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkodGhpcy5fbGVnZW5kLnRva2VuTW9kaWZpZXJzKSkpOwogICAgICAgICAgICB0b2tlbk1vZGlmaWVycy5wdXNoKCdub3QtaW4tbGVnZW5kJyk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgdG9rZW5TdHlsZSA9IHRoaXMuX3RoZW1lU2VydmljZS5nZXRDb2xvclRoZW1lKCkuZ2V0VG9rZW5TdHlsZU1ldGFkYXRhKHRva2VuVHlwZSwgdG9rZW5Nb2RpZmllcnMsIGxhbmd1YWdlSWQpOwogICAgICAgICAgaWYgKHR5cGVvZiB0b2tlblN0eWxlID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICBtZXRhZGF0YSA9IDIxNDc0ODM2NDcgLyogU2VtYW50aWNUb2tlbnNQcm92aWRlclN0eWxpbmdDb25zdGFudHMuTk9fU1RZTElORyAqLzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG1ldGFkYXRhID0gMDsKICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlblN0eWxlLml0YWxpYyAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgICAgICB2YXIgaXRhbGljQml0ID0gKHRva2VuU3R5bGUuaXRhbGljID8gMSAvKiBGb250U3R5bGUuSXRhbGljICovIDogMCkgPDwgMTEgLyogTWV0YWRhdGFDb25zdHMuRk9OVF9TVFlMRV9PRkZTRVQgKi87CiAgICAgICAgICAgICAgbWV0YWRhdGEgfD0gaXRhbGljQml0IHwgMSAvKiBNZXRhZGF0YUNvbnN0cy5TRU1BTlRJQ19VU0VfSVRBTElDICovOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuU3R5bGUuYm9sZCAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgICAgICB2YXIgYm9sZEJpdCA9ICh0b2tlblN0eWxlLmJvbGQgPyAyIC8qIEZvbnRTdHlsZS5Cb2xkICovIDogMCkgPDwgMTEgLyogTWV0YWRhdGFDb25zdHMuRk9OVF9TVFlMRV9PRkZTRVQgKi87CiAgICAgICAgICAgICAgbWV0YWRhdGEgfD0gYm9sZEJpdCB8IDIgLyogTWV0YWRhdGFDb25zdHMuU0VNQU5USUNfVVNFX0JPTEQgKi87CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW5TdHlsZS51bmRlcmxpbmUgIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICAgICAgdmFyIHVuZGVybGluZUJpdCA9ICh0b2tlblN0eWxlLnVuZGVybGluZSA/IDQgLyogRm9udFN0eWxlLlVuZGVybGluZSAqLyA6IDApIDw8IDExIC8qIE1ldGFkYXRhQ29uc3RzLkZPTlRfU1RZTEVfT0ZGU0VUICovOwogICAgICAgICAgICAgIG1ldGFkYXRhIHw9IHVuZGVybGluZUJpdCB8IDQgLyogTWV0YWRhdGFDb25zdHMuU0VNQU5USUNfVVNFX1VOREVSTElORSAqLzsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlblN0eWxlLnN0cmlrZXRocm91Z2ggIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICAgICAgdmFyIHN0cmlrZXRocm91Z2hCaXQgPSAodG9rZW5TdHlsZS5zdHJpa2V0aHJvdWdoID8gOCAvKiBGb250U3R5bGUuU3RyaWtldGhyb3VnaCAqLyA6IDApIDw8IDExIC8qIE1ldGFkYXRhQ29uc3RzLkZPTlRfU1RZTEVfT0ZGU0VUICovOwogICAgICAgICAgICAgIG1ldGFkYXRhIHw9IHN0cmlrZXRocm91Z2hCaXQgfCA4IC8qIE1ldGFkYXRhQ29uc3RzLlNFTUFOVElDX1VTRV9TVFJJS0VUSFJPVUdIICovOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAodG9rZW5TdHlsZS5mb3JlZ3JvdW5kKSB7CiAgICAgICAgICAgICAgdmFyIGZvcmVncm91bmRCaXRzID0gdG9rZW5TdHlsZS5mb3JlZ3JvdW5kIDw8IDE1IC8qIE1ldGFkYXRhQ29uc3RzLkZPUkVHUk9VTkRfT0ZGU0VUICovOwogICAgICAgICAgICAgIG1ldGFkYXRhIHw9IGZvcmVncm91bmRCaXRzIHwgMTYgLyogTWV0YWRhdGFDb25zdHMuU0VNQU5USUNfVVNFX0ZPUkVHUk9VTkQgKi87CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmIChtZXRhZGF0YSA9PT0gMCkgewogICAgICAgICAgICAgIC8vIE5vdGhpbmchCiAgICAgICAgICAgICAgbWV0YWRhdGEgPSAyMTQ3NDgzNjQ3IC8qIFNlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nQ29uc3RhbnRzLk5PX1NUWUxJTkcgKi87CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKHRoaXMuX2xvZ1NlcnZpY2UuZ2V0TGV2ZWwoKSA9PT0gTG9nTGV2ZWwuVHJhY2UpIHsKICAgICAgICAgICAgdGhpcy5fbG9nU2VydmljZS50cmFjZSgiU2VtYW50aWNUb2tlbnNQcm92aWRlclN0eWxpbmc6IHVua25vd24gdG9rZW4gdHlwZSBpbmRleDogIi5jb25jYXQodG9rZW5UeXBlSW5kZXgsICIgZm9yIGxlZ2VuZDogIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KHRoaXMuX2xlZ2VuZC50b2tlblR5cGVzKSkpOwogICAgICAgICAgfQogICAgICAgICAgbWV0YWRhdGEgPSAyMTQ3NDgzNjQ3IC8qIFNlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nQ29uc3RhbnRzLk5PX1NUWUxJTkcgKi87CiAgICAgICAgICB0b2tlblR5cGUgPSAnbm90LWluLWxlZ2VuZCc7CiAgICAgICAgfQogICAgICAgIHRoaXMuX2hhc2hUYWJsZS5hZGQodG9rZW5UeXBlSW5kZXgsIHRva2VuTW9kaWZpZXJTZXQsIGVuY29kZWRMYW5ndWFnZUlkLCBtZXRhZGF0YSk7CiAgICAgICAgaWYgKHRoaXMuX2xvZ1NlcnZpY2UuZ2V0TGV2ZWwoKSA9PT0gTG9nTGV2ZWwuVHJhY2UpIHsKICAgICAgICAgIHRoaXMuX2xvZ1NlcnZpY2UudHJhY2UoIlNlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nICIuY29uY2F0KHRva2VuVHlwZUluZGV4LCAiICgiKS5jb25jYXQodG9rZW5UeXBlLCAiKSAvICIpLmNvbmNhdCh0b2tlbk1vZGlmaWVyU2V0LCAiICgiKS5jb25jYXQodG9rZW5Nb2RpZmllcnMuam9pbignICcpLCAiKTogZm9yZWdyb3VuZCAiKS5jb25jYXQoVG9rZW5NZXRhZGF0YS5nZXRGb3JlZ3JvdW5kKG1ldGFkYXRhKSwgIiwgZm9udFN0eWxlICIpLmNvbmNhdChUb2tlbk1ldGFkYXRhLmdldEZvbnRTdHlsZShtZXRhZGF0YSkudG9TdHJpbmcoMikpKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIG1ldGFkYXRhOwogICAgfQogIH0sIHsKICAgIGtleTogIndhcm5PdmVybGFwcGluZ1NlbWFudGljVG9rZW5zIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB3YXJuT3ZlcmxhcHBpbmdTZW1hbnRpY1Rva2VucyhsaW5lTnVtYmVyLCBzdGFydENvbHVtbikgewogICAgICBpZiAoIXRoaXMuX2hhc1dhcm5lZE92ZXJsYXBwaW5nVG9rZW5zKSB7CiAgICAgICAgdGhpcy5faGFzV2FybmVkT3ZlcmxhcHBpbmdUb2tlbnMgPSB0cnVlOwogICAgICAgIGNvbnNvbGUud2FybigiT3ZlcmxhcHBpbmcgc2VtYW50aWMgdG9rZW5zIGRldGVjdGVkIGF0IGxpbmVOdW1iZXIgIi5jb25jYXQobGluZU51bWJlciwgIiwgY29sdW1uICIpLmNvbmNhdChzdGFydENvbHVtbikpOwogICAgICB9CiAgICB9CiAgfSwgewogICAga2V5OiAid2FybkludmFsaWRMZW5ndGhTZW1hbnRpY1Rva2VucyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gd2FybkludmFsaWRMZW5ndGhTZW1hbnRpY1Rva2VucyhsaW5lTnVtYmVyLCBzdGFydENvbHVtbikgewogICAgICBpZiAoIXRoaXMuX2hhc1dhcm5lZEludmFsaWRMZW5ndGhUb2tlbnMpIHsKICAgICAgICB0aGlzLl9oYXNXYXJuZWRJbnZhbGlkTGVuZ3RoVG9rZW5zID0gdHJ1ZTsKICAgICAgICBjb25zb2xlLndhcm4oIlNlbWFudGljIHRva2VuIHdpdGggaW52YWxpZCBsZW5ndGggZGV0ZWN0ZWQgYXQgbGluZU51bWJlciAiLmNvbmNhdChsaW5lTnVtYmVyLCAiLCBjb2x1bW4gIikuY29uY2F0KHN0YXJ0Q29sdW1uKSk7CiAgICAgIH0KICAgIH0KICB9LCB7CiAgICBrZXk6ICJ3YXJuSW52YWxpZEVkaXRTdGFydCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gd2FybkludmFsaWRFZGl0U3RhcnQocHJldmlvdXNSZXN1bHRJZCwgcmVzdWx0SWQsIGVkaXRJbmRleCwgZWRpdFN0YXJ0LCBtYXhFeHBlY3RlZFN0YXJ0KSB7CiAgICAgIGlmICghdGhpcy5faGFzV2FybmVkSW52YWxpZEVkaXRTdGFydCkgewogICAgICAgIHRoaXMuX2hhc1dhcm5lZEludmFsaWRFZGl0U3RhcnQgPSB0cnVlOwogICAgICAgIGNvbnNvbGUud2FybigiSW52YWxpZCBzZW1hbnRpYyB0b2tlbnMgZWRpdCBkZXRlY3RlZCAocHJldmlvdXNSZXN1bHRJZDogIi5jb25jYXQocHJldmlvdXNSZXN1bHRJZCwgIiwgcmVzdWx0SWQ6ICIpLmNvbmNhdChyZXN1bHRJZCwgIikgYXQgZWRpdCAjIikuY29uY2F0KGVkaXRJbmRleCwgIjogVGhlIHByb3ZpZGVkIHN0YXJ0IG9mZnNldCAiKS5jb25jYXQoZWRpdFN0YXJ0LCAiIGlzIG91dHNpZGUgdGhlIHByZXZpb3VzIGRhdGEgKGxlbmd0aCAiKS5jb25jYXQobWF4RXhwZWN0ZWRTdGFydCwgIikuIikpOwogICAgICB9CiAgICB9CiAgfV0pOwogIHJldHVybiBTZW1hbnRpY1Rva2Vuc1Byb3ZpZGVyU3R5bGluZzsKfSgpOwpTZW1hbnRpY1Rva2Vuc1Byb3ZpZGVyU3R5bGluZyA9IF9fZGVjb3JhdGUoW19fcGFyYW0oMSwgSVRoZW1lU2VydmljZSksIF9fcGFyYW0oMiwgSUxhbmd1YWdlU2VydmljZSksIF9fcGFyYW0oMywgSUxvZ1NlcnZpY2UpXSwgU2VtYW50aWNUb2tlbnNQcm92aWRlclN0eWxpbmcpOwpleHBvcnQgeyBTZW1hbnRpY1Rva2Vuc1Byb3ZpZGVyU3R5bGluZyB9OwpleHBvcnQgZnVuY3Rpb24gdG9NdWx0aWxpbmVUb2tlbnMyKHRva2Vucywgc3R5bGluZywgbGFuZ3VhZ2VJZCkgewogIHZhciBzcmNEYXRhID0gdG9rZW5zLmRhdGE7CiAgdmFyIHRva2VuQ291bnQgPSB0b2tlbnMuZGF0YS5sZW5ndGggLyA1IHwgMDsKICB2YXIgdG9rZW5zUGVyQXJlYSA9IE1hdGgubWF4KE1hdGguY2VpbCh0b2tlbkNvdW50IC8gMTAyNCAvKiBTZW1hbnRpY0NvbG9yaW5nQ29uc3RhbnRzLkRlc2lyZWRNYXhBcmVhcyAqLyksIDQwMCAvKiBTZW1hbnRpY0NvbG9yaW5nQ29uc3RhbnRzLkRlc2lyZWRUb2tlbnNQZXJBcmVhICovKTsKICB2YXIgcmVzdWx0ID0gW107CiAgdmFyIHRva2VuSW5kZXggPSAwOwogIHZhciBsYXN0TGluZU51bWJlciA9IDE7CiAgdmFyIGxhc3RTdGFydENoYXJhY3RlciA9IDA7CiAgd2hpbGUgKHRva2VuSW5kZXggPCB0b2tlbkNvdW50KSB7CiAgICB2YXIgdG9rZW5TdGFydEluZGV4ID0gdG9rZW5JbmRleDsKICAgIHZhciB0b2tlbkVuZEluZGV4ID0gTWF0aC5taW4odG9rZW5TdGFydEluZGV4ICsgdG9rZW5zUGVyQXJlYSwgdG9rZW5Db3VudCk7CiAgICAvLyBLZWVwIHRva2VucyBvbiB0aGUgc2FtZSBsaW5lIGluIHRoZSBzYW1lIGFyZWEuLi4KICAgIGlmICh0b2tlbkVuZEluZGV4IDwgdG9rZW5Db3VudCkgewogICAgICB2YXIgc21hbGxUb2tlbkVuZEluZGV4ID0gdG9rZW5FbmRJbmRleDsKICAgICAgd2hpbGUgKHNtYWxsVG9rZW5FbmRJbmRleCAtIDEgPiB0b2tlblN0YXJ0SW5kZXggJiYgc3JjRGF0YVs1ICogc21hbGxUb2tlbkVuZEluZGV4XSA9PT0gMCkgewogICAgICAgIHNtYWxsVG9rZW5FbmRJbmRleC0tOwogICAgICB9CiAgICAgIGlmIChzbWFsbFRva2VuRW5kSW5kZXggLSAxID09PSB0b2tlblN0YXJ0SW5kZXgpIHsKICAgICAgICAvLyB0aGVyZSBhcmUgc28gbWFueSB0b2tlbnMgb24gdGhpcyBsaW5lIHRoYXQgb3VyIGFyZWEgd291bGQgYmUgZW1wdHksIHdlIG11c3Qgbm93IGdvIHJpZ2h0CiAgICAgICAgdmFyIGJpZ1Rva2VuRW5kSW5kZXggPSB0b2tlbkVuZEluZGV4OwogICAgICAgIHdoaWxlIChiaWdUb2tlbkVuZEluZGV4ICsgMSA8IHRva2VuQ291bnQgJiYgc3JjRGF0YVs1ICogYmlnVG9rZW5FbmRJbmRleF0gPT09IDApIHsKICAgICAgICAgIGJpZ1Rva2VuRW5kSW5kZXgrKzsKICAgICAgICB9CiAgICAgICAgdG9rZW5FbmRJbmRleCA9IGJpZ1Rva2VuRW5kSW5kZXg7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdG9rZW5FbmRJbmRleCA9IHNtYWxsVG9rZW5FbmRJbmRleDsKICAgICAgfQogICAgfQogICAgdmFyIGRlc3REYXRhID0gbmV3IFVpbnQzMkFycmF5KCh0b2tlbkVuZEluZGV4IC0gdG9rZW5TdGFydEluZGV4KSAqIDQpOwogICAgdmFyIGRlc3RPZmZzZXQgPSAwOwogICAgdmFyIGFyZWFMaW5lID0gMDsKICAgIHZhciBwcmV2TGluZU51bWJlciA9IDA7CiAgICB2YXIgcHJldkVuZENoYXJhY3RlciA9IDA7CiAgICB3aGlsZSAodG9rZW5JbmRleCA8IHRva2VuRW5kSW5kZXgpIHsKICAgICAgdmFyIHNyY09mZnNldCA9IDUgKiB0b2tlbkluZGV4OwogICAgICB2YXIgZGVsdGFMaW5lID0gc3JjRGF0YVtzcmNPZmZzZXRdOwogICAgICB2YXIgZGVsdGFDaGFyYWN0ZXIgPSBzcmNEYXRhW3NyY09mZnNldCArIDFdOwogICAgICAvLyBDYXN0aW5nIGJvdGggYGxpbmVOdW1iZXJgLCBgc3RhcnRDaGFyYWN0ZXJgIGFuZCBgZW5kQ2hhcmFjdGVyYCBoZXJlIHRvIHVpbnQzMiB1c2luZyBgfDBgCiAgICAgIC8vIHRvIHZhbGlkYXRlIGJlbG93IHdpdGggdGhlIGFjdHVhbCB2YWx1ZXMgdGhhdCB3aWxsIGJlIGluc2VydGVkIGluIHRoZSBVaW50MzJBcnJheSByZXN1bHQKICAgICAgdmFyIGxpbmVOdW1iZXIgPSBsYXN0TGluZU51bWJlciArIGRlbHRhTGluZSB8IDA7CiAgICAgIHZhciBzdGFydENoYXJhY3RlciA9IGRlbHRhTGluZSA9PT0gMCA/IGxhc3RTdGFydENoYXJhY3RlciArIGRlbHRhQ2hhcmFjdGVyIHwgMCA6IGRlbHRhQ2hhcmFjdGVyOwogICAgICB2YXIgbGVuZ3RoID0gc3JjRGF0YVtzcmNPZmZzZXQgKyAyXTsKICAgICAgdmFyIGVuZENoYXJhY3RlciA9IHN0YXJ0Q2hhcmFjdGVyICsgbGVuZ3RoIHwgMDsKICAgICAgdmFyIHRva2VuVHlwZUluZGV4ID0gc3JjRGF0YVtzcmNPZmZzZXQgKyAzXTsKICAgICAgdmFyIHRva2VuTW9kaWZpZXJTZXQgPSBzcmNEYXRhW3NyY09mZnNldCArIDRdOwogICAgICBpZiAoZW5kQ2hhcmFjdGVyIDw9IHN0YXJ0Q2hhcmFjdGVyKSB7CiAgICAgICAgLy8gdGhpcyB0b2tlbiBpcyBpbnZhbGlkIChtb3N0IGxpa2VseSBhIG5lZ2F0aXZlIGxlbmd0aCBjYXN0ZWQgdG8gdWludDMyKQogICAgICAgIHN0eWxpbmcud2FybkludmFsaWRMZW5ndGhTZW1hbnRpY1Rva2VucyhsaW5lTnVtYmVyLCBzdGFydENoYXJhY3RlciArIDEpOwogICAgICB9IGVsc2UgaWYgKHByZXZMaW5lTnVtYmVyID09PSBsaW5lTnVtYmVyICYmIHByZXZFbmRDaGFyYWN0ZXIgPiBzdGFydENoYXJhY3RlcikgewogICAgICAgIC8vIHRoaXMgdG9rZW4gb3ZlcmxhcHMgd2l0aCB0aGUgcHJldmlvdXMgdG9rZW4KICAgICAgICBzdHlsaW5nLndhcm5PdmVybGFwcGluZ1NlbWFudGljVG9rZW5zKGxpbmVOdW1iZXIsIHN0YXJ0Q2hhcmFjdGVyICsgMSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFyIG1ldGFkYXRhID0gc3R5bGluZy5nZXRNZXRhZGF0YSh0b2tlblR5cGVJbmRleCwgdG9rZW5Nb2RpZmllclNldCwgbGFuZ3VhZ2VJZCk7CiAgICAgICAgaWYgKG1ldGFkYXRhICE9PSAyMTQ3NDgzNjQ3IC8qIFNlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nQ29uc3RhbnRzLk5PX1NUWUxJTkcgKi8pIHsKICAgICAgICAgIGlmIChhcmVhTGluZSA9PT0gMCkgewogICAgICAgICAgICBhcmVhTGluZSA9IGxpbmVOdW1iZXI7CiAgICAgICAgICB9CiAgICAgICAgICBkZXN0RGF0YVtkZXN0T2Zmc2V0XSA9IGxpbmVOdW1iZXIgLSBhcmVhTGluZTsKICAgICAgICAgIGRlc3REYXRhW2Rlc3RPZmZzZXQgKyAxXSA9IHN0YXJ0Q2hhcmFjdGVyOwogICAgICAgICAgZGVzdERhdGFbZGVzdE9mZnNldCArIDJdID0gZW5kQ2hhcmFjdGVyOwogICAgICAgICAgZGVzdERhdGFbZGVzdE9mZnNldCArIDNdID0gbWV0YWRhdGE7CiAgICAgICAgICBkZXN0T2Zmc2V0ICs9IDQ7CiAgICAgICAgICBwcmV2TGluZU51bWJlciA9IGxpbmVOdW1iZXI7CiAgICAgICAgICBwcmV2RW5kQ2hhcmFjdGVyID0gZW5kQ2hhcmFjdGVyOwogICAgICAgIH0KICAgICAgfQogICAgICBsYXN0TGluZU51bWJlciA9IGxpbmVOdW1iZXI7CiAgICAgIGxhc3RTdGFydENoYXJhY3RlciA9IHN0YXJ0Q2hhcmFjdGVyOwogICAgICB0b2tlbkluZGV4Kys7CiAgICB9CiAgICBpZiAoZGVzdE9mZnNldCAhPT0gZGVzdERhdGEubGVuZ3RoKSB7CiAgICAgIGRlc3REYXRhID0gZGVzdERhdGEuc3ViYXJyYXkoMCwgZGVzdE9mZnNldCk7CiAgICB9CiAgICB2YXIgX3Rva2VucyA9IFNwYXJzZU11bHRpbGluZVRva2Vucy5jcmVhdGUoYXJlYUxpbmUsIGRlc3REYXRhKTsKICAgIHJlc3VsdC5wdXNoKF90b2tlbnMpOwogIH0KICByZXR1cm4gcmVzdWx0Owp9CnZhciBIYXNoVGFibGVFbnRyeSA9IC8qI19fUFVSRV9fKi9fY3JlYXRlQ2xhc3MoZnVuY3Rpb24gSGFzaFRhYmxlRW50cnkodG9rZW5UeXBlSW5kZXgsIHRva2VuTW9kaWZpZXJTZXQsIGxhbmd1YWdlSWQsIG1ldGFkYXRhKSB7CiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhhc2hUYWJsZUVudHJ5KTsKICB0aGlzLnRva2VuVHlwZUluZGV4ID0gdG9rZW5UeXBlSW5kZXg7CiAgdGhpcy50b2tlbk1vZGlmaWVyU2V0ID0gdG9rZW5Nb2RpZmllclNldDsKICB0aGlzLmxhbmd1YWdlSWQgPSBsYW5ndWFnZUlkOwogIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTsKICB0aGlzLm5leHQgPSBudWxsOwp9KTsKdmFyIEhhc2hUYWJsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7CiAgZnVuY3Rpb24gSGFzaFRhYmxlKCkgewogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhhc2hUYWJsZSk7CiAgICB0aGlzLl9lbGVtZW50c0NvdW50ID0gMDsKICAgIHRoaXMuX2N1cnJlbnRMZW5ndGhJbmRleCA9IDA7CiAgICB0aGlzLl9jdXJyZW50TGVuZ3RoID0gSGFzaFRhYmxlLl9TSVpFU1t0aGlzLl9jdXJyZW50TGVuZ3RoSW5kZXhdOwogICAgdGhpcy5fZ3Jvd0NvdW50ID0gTWF0aC5yb3VuZCh0aGlzLl9jdXJyZW50TGVuZ3RoSW5kZXggKyAxIDwgSGFzaFRhYmxlLl9TSVpFUy5sZW5ndGggPyAyIC8gMyAqIHRoaXMuX2N1cnJlbnRMZW5ndGggOiAwKTsKICAgIHRoaXMuX2VsZW1lbnRzID0gW107CiAgICBIYXNoVGFibGUuX251bGxPdXRFbnRyaWVzKHRoaXMuX2VsZW1lbnRzLCB0aGlzLl9jdXJyZW50TGVuZ3RoKTsKICB9CiAgX2NyZWF0ZUNsYXNzKEhhc2hUYWJsZSwgW3sKICAgIGtleTogIl9oYXNoMiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhc2gyKG4xLCBuMikgewogICAgICByZXR1cm4gKG4xIDw8IDUpIC0gbjEgKyBuMiB8IDA7IC8vIG4xICogMzEgKyBuMiwga2VlcCBhcyBpbnQzMgogICAgfQogIH0sIHsKICAgIGtleTogIl9oYXNoRnVuYyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhc2hGdW5jKHRva2VuVHlwZUluZGV4LCB0b2tlbk1vZGlmaWVyU2V0LCBsYW5ndWFnZUlkKSB7CiAgICAgIHJldHVybiB0aGlzLl9oYXNoMih0aGlzLl9oYXNoMih0b2tlblR5cGVJbmRleCwgdG9rZW5Nb2RpZmllclNldCksIGxhbmd1YWdlSWQpICUgdGhpcy5fY3VycmVudExlbmd0aDsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJnZXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldCh0b2tlblR5cGVJbmRleCwgdG9rZW5Nb2RpZmllclNldCwgbGFuZ3VhZ2VJZCkgewogICAgICB2YXIgaGFzaCA9IHRoaXMuX2hhc2hGdW5jKHRva2VuVHlwZUluZGV4LCB0b2tlbk1vZGlmaWVyU2V0LCBsYW5ndWFnZUlkKTsKICAgICAgdmFyIHAgPSB0aGlzLl9lbGVtZW50c1toYXNoXTsKICAgICAgd2hpbGUgKHApIHsKICAgICAgICBpZiAocC50b2tlblR5cGVJbmRleCA9PT0gdG9rZW5UeXBlSW5kZXggJiYgcC50b2tlbk1vZGlmaWVyU2V0ID09PSB0b2tlbk1vZGlmaWVyU2V0ICYmIHAubGFuZ3VhZ2VJZCA9PT0gbGFuZ3VhZ2VJZCkgewogICAgICAgICAgcmV0dXJuIHA7CiAgICAgICAgfQogICAgICAgIHAgPSBwLm5leHQ7CiAgICAgIH0KICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgfSwgewogICAga2V5OiAiYWRkIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQodG9rZW5UeXBlSW5kZXgsIHRva2VuTW9kaWZpZXJTZXQsIGxhbmd1YWdlSWQsIG1ldGFkYXRhKSB7CiAgICAgIHRoaXMuX2VsZW1lbnRzQ291bnQrKzsKICAgICAgaWYgKHRoaXMuX2dyb3dDb3VudCAhPT0gMCAmJiB0aGlzLl9lbGVtZW50c0NvdW50ID49IHRoaXMuX2dyb3dDb3VudCkgewogICAgICAgIC8vIGV4cGFuZCEKICAgICAgICB2YXIgb2xkRWxlbWVudHMgPSB0aGlzLl9lbGVtZW50czsKICAgICAgICB0aGlzLl9jdXJyZW50TGVuZ3RoSW5kZXgrKzsKICAgICAgICB0aGlzLl9jdXJyZW50TGVuZ3RoID0gSGFzaFRhYmxlLl9TSVpFU1t0aGlzLl9jdXJyZW50TGVuZ3RoSW5kZXhdOwogICAgICAgIHRoaXMuX2dyb3dDb3VudCA9IE1hdGgucm91bmQodGhpcy5fY3VycmVudExlbmd0aEluZGV4ICsgMSA8IEhhc2hUYWJsZS5fU0laRVMubGVuZ3RoID8gMiAvIDMgKiB0aGlzLl9jdXJyZW50TGVuZ3RoIDogMCk7CiAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBbXTsKICAgICAgICBIYXNoVGFibGUuX251bGxPdXRFbnRyaWVzKHRoaXMuX2VsZW1lbnRzLCB0aGlzLl9jdXJyZW50TGVuZ3RoKTsKICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIob2xkRWxlbWVudHMpLAogICAgICAgICAgX3N0ZXA7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7CiAgICAgICAgICAgIHZhciBmaXJzdCA9IF9zdGVwLnZhbHVlOwogICAgICAgICAgICB2YXIgcCA9IGZpcnN0OwogICAgICAgICAgICB3aGlsZSAocCkgewogICAgICAgICAgICAgIHZhciBvbGROZXh0ID0gcC5uZXh0OwogICAgICAgICAgICAgIHAubmV4dCA9IG51bGw7CiAgICAgICAgICAgICAgdGhpcy5fYWRkKHApOwogICAgICAgICAgICAgIHAgPSBvbGROZXh0OwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBfaXRlcmF0b3IuZigpOwogICAgICAgIH0KICAgICAgfQogICAgICB0aGlzLl9hZGQobmV3IEhhc2hUYWJsZUVudHJ5KHRva2VuVHlwZUluZGV4LCB0b2tlbk1vZGlmaWVyU2V0LCBsYW5ndWFnZUlkLCBtZXRhZGF0YSkpOwogICAgfQogIH0sIHsKICAgIGtleTogIl9hZGQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGQoZWxlbWVudCkgewogICAgICB2YXIgaGFzaCA9IHRoaXMuX2hhc2hGdW5jKGVsZW1lbnQudG9rZW5UeXBlSW5kZXgsIGVsZW1lbnQudG9rZW5Nb2RpZmllclNldCwgZWxlbWVudC5sYW5ndWFnZUlkKTsKICAgICAgZWxlbWVudC5uZXh0ID0gdGhpcy5fZWxlbWVudHNbaGFzaF07CiAgICAgIHRoaXMuX2VsZW1lbnRzW2hhc2hdID0gZWxlbWVudDsKICAgIH0KICB9XSwgW3sKICAgIGtleTogIl9udWxsT3V0RW50cmllcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX251bGxPdXRFbnRyaWVzKGVudHJpZXMsIGxlbmd0aCkgewogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgICAgZW50cmllc1tpXSA9IG51bGw7CiAgICAgIH0KICAgIH0KICB9XSk7CiAgcmV0dXJuIEhhc2hUYWJsZTsKfSgpOwpIYXNoVGFibGUuX1NJWkVTID0gWzMsIDcsIDEzLCAzMSwgNjEsIDEyNywgMjUxLCA1MDksIDEwMjEsIDIwMzksIDQwOTMsIDgxOTEsIDE2MzgxLCAzMjc0OSwgNjU1MjEsIDEzMTA3MSwgMjYyMTM5LCA1MjQyODcsIDEwNDg1NzMsIDIwOTcxNDNdOw=="},{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","TokenMetadata","IThemeService","ILogService","LogLevel","SparseMultilineTokens","ILanguageService","SemanticTokensProviderStyling","_legend","_themeService","_languageService","_logService","_hasWarnedOverlappingTokens","_hasWarnedInvalidLengthTokens","_hasWarnedInvalidEditStart","_hashTable","HashTable","tokenTypeIndex","tokenModifierSet","languageId","encodedLanguageId","languageIdCodec","encodeLanguageId","entry","get","metadata","getLevel","Trace","trace","getForeground","getFontStyle","toString","tokenType","tokenTypes","tokenModifiers","modifierSet","modifierIndex","push","JSON","stringify","tokenStyle","getColorTheme","getTokenStyleMetadata","italic","italicBit","bold","boldBit","underline","underlineBit","strikethrough","strikethroughBit","foreground","foregroundBits","add","join","lineNumber","startColumn","console","warn","previousResultId","resultId","editIndex","editStart","maxExpectedStart","toMultilineTokens2","tokens","styling","srcData","data","tokenCount","tokensPerArea","Math","max","ceil","result","tokenIndex","lastLineNumber","lastStartCharacter","tokenStartIndex","tokenEndIndex","min","smallTokenEndIndex","bigTokenEndIndex","destData","Uint32Array","destOffset","areaLine","prevLineNumber","prevEndCharacter","srcOffset","deltaLine","deltaCharacter","startCharacter","endCharacter","warnInvalidLengthSemanticTokens","warnOverlappingSemanticTokens","getMetadata","subarray","create","HashTableEntry","next","_elementsCount","_currentLengthIndex","_currentLength","_SIZES","_growCount","round","_elements","_nullOutEntries","n1","n2","_hash2","hash","_hashFunc","p","oldElements","first","oldNext","_add","element","entries"],"sources":["/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { ILogService, LogLevel } from '../../../platform/log/common/log.js';\nimport { SparseMultilineTokens } from '../tokens/sparseMultilineTokens.js';\nimport { ILanguageService } from '../languages/language.js';\nlet SemanticTokensProviderStyling = class SemanticTokensProviderStyling {\n    constructor(_legend, _themeService, _languageService, _logService) {\n        this._legend = _legend;\n        this._themeService = _themeService;\n        this._languageService = _languageService;\n        this._logService = _logService;\n        this._hasWarnedOverlappingTokens = false;\n        this._hasWarnedInvalidLengthTokens = false;\n        this._hasWarnedInvalidEditStart = false;\n        this._hashTable = new HashTable();\n    }\n    getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {\n        const encodedLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n        const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, encodedLanguageId);\n        let metadata;\n        if (entry) {\n            metadata = entry.metadata;\n            if (this._logService.getLevel() === LogLevel.Trace) {\n                this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n            }\n        }\n        else {\n            let tokenType = this._legend.tokenTypes[tokenTypeIndex];\n            const tokenModifiers = [];\n            if (tokenType) {\n                let modifierSet = tokenModifierSet;\n                for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {\n                    if (modifierSet & 1) {\n                        tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);\n                    }\n                    modifierSet = modifierSet >> 1;\n                }\n                if (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);\n                    tokenModifiers.push('not-in-legend');\n                }\n                const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId);\n                if (typeof tokenStyle === 'undefined') {\n                    metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n                }\n                else {\n                    metadata = 0;\n                    if (typeof tokenStyle.italic !== 'undefined') {\n                        const italicBit = (tokenStyle.italic ? 1 /* FontStyle.Italic */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= italicBit | 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */;\n                    }\n                    if (typeof tokenStyle.bold !== 'undefined') {\n                        const boldBit = (tokenStyle.bold ? 2 /* FontStyle.Bold */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= boldBit | 2 /* MetadataConsts.SEMANTIC_USE_BOLD */;\n                    }\n                    if (typeof tokenStyle.underline !== 'undefined') {\n                        const underlineBit = (tokenStyle.underline ? 4 /* FontStyle.Underline */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= underlineBit | 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */;\n                    }\n                    if (typeof tokenStyle.strikethrough !== 'undefined') {\n                        const strikethroughBit = (tokenStyle.strikethrough ? 8 /* FontStyle.Strikethrough */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= strikethroughBit | 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */;\n                    }\n                    if (tokenStyle.foreground) {\n                        const foregroundBits = (tokenStyle.foreground) << 15 /* MetadataConsts.FOREGROUND_OFFSET */;\n                        metadata |= foregroundBits | 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */;\n                    }\n                    if (metadata === 0) {\n                        // Nothing!\n                        metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n                    }\n                }\n            }\n            else {\n                if (this._logService.getLevel() === LogLevel.Trace) {\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);\n                }\n                metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n                tokenType = 'not-in-legend';\n            }\n            this._hashTable.add(tokenTypeIndex, tokenModifierSet, encodedLanguageId, metadata);\n            if (this._logService.getLevel() === LogLevel.Trace) {\n                this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(' ')}): foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n            }\n        }\n        return metadata;\n    }\n    warnOverlappingSemanticTokens(lineNumber, startColumn) {\n        if (!this._hasWarnedOverlappingTokens) {\n            this._hasWarnedOverlappingTokens = true;\n            console.warn(`Overlapping semantic tokens detected at lineNumber ${lineNumber}, column ${startColumn}`);\n        }\n    }\n    warnInvalidLengthSemanticTokens(lineNumber, startColumn) {\n        if (!this._hasWarnedInvalidLengthTokens) {\n            this._hasWarnedInvalidLengthTokens = true;\n            console.warn(`Semantic token with invalid length detected at lineNumber ${lineNumber}, column ${startColumn}`);\n        }\n    }\n    warnInvalidEditStart(previousResultId, resultId, editIndex, editStart, maxExpectedStart) {\n        if (!this._hasWarnedInvalidEditStart) {\n            this._hasWarnedInvalidEditStart = true;\n            console.warn(`Invalid semantic tokens edit detected (previousResultId: ${previousResultId}, resultId: ${resultId}) at edit #${editIndex}: The provided start offset ${editStart} is outside the previous data (length ${maxExpectedStart}).`);\n        }\n    }\n};\nSemanticTokensProviderStyling = __decorate([\n    __param(1, IThemeService),\n    __param(2, ILanguageService),\n    __param(3, ILogService)\n], SemanticTokensProviderStyling);\nexport { SemanticTokensProviderStyling };\nexport function toMultilineTokens2(tokens, styling, languageId) {\n    const srcData = tokens.data;\n    const tokenCount = (tokens.data.length / 5) | 0;\n    const tokensPerArea = Math.max(Math.ceil(tokenCount / 1024 /* SemanticColoringConstants.DesiredMaxAreas */), 400 /* SemanticColoringConstants.DesiredTokensPerArea */);\n    const result = [];\n    let tokenIndex = 0;\n    let lastLineNumber = 1;\n    let lastStartCharacter = 0;\n    while (tokenIndex < tokenCount) {\n        const tokenStartIndex = tokenIndex;\n        let tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);\n        // Keep tokens on the same line in the same area...\n        if (tokenEndIndex < tokenCount) {\n            let smallTokenEndIndex = tokenEndIndex;\n            while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {\n                smallTokenEndIndex--;\n            }\n            if (smallTokenEndIndex - 1 === tokenStartIndex) {\n                // there are so many tokens on this line that our area would be empty, we must now go right\n                let bigTokenEndIndex = tokenEndIndex;\n                while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {\n                    bigTokenEndIndex++;\n                }\n                tokenEndIndex = bigTokenEndIndex;\n            }\n            else {\n                tokenEndIndex = smallTokenEndIndex;\n            }\n        }\n        let destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);\n        let destOffset = 0;\n        let areaLine = 0;\n        let prevLineNumber = 0;\n        let prevEndCharacter = 0;\n        while (tokenIndex < tokenEndIndex) {\n            const srcOffset = 5 * tokenIndex;\n            const deltaLine = srcData[srcOffset];\n            const deltaCharacter = srcData[srcOffset + 1];\n            // Casting both `lineNumber`, `startCharacter` and `endCharacter` here to uint32 using `|0`\n            // to validate below with the actual values that will be inserted in the Uint32Array result\n            const lineNumber = (lastLineNumber + deltaLine) | 0;\n            const startCharacter = (deltaLine === 0 ? (lastStartCharacter + deltaCharacter) | 0 : deltaCharacter);\n            const length = srcData[srcOffset + 2];\n            const endCharacter = (startCharacter + length) | 0;\n            const tokenTypeIndex = srcData[srcOffset + 3];\n            const tokenModifierSet = srcData[srcOffset + 4];\n            if (endCharacter <= startCharacter) {\n                // this token is invalid (most likely a negative length casted to uint32)\n                styling.warnInvalidLengthSemanticTokens(lineNumber, startCharacter + 1);\n            }\n            else if (prevLineNumber === lineNumber && prevEndCharacter > startCharacter) {\n                // this token overlaps with the previous token\n                styling.warnOverlappingSemanticTokens(lineNumber, startCharacter + 1);\n            }\n            else {\n                const metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);\n                if (metadata !== 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */) {\n                    if (areaLine === 0) {\n                        areaLine = lineNumber;\n                    }\n                    destData[destOffset] = lineNumber - areaLine;\n                    destData[destOffset + 1] = startCharacter;\n                    destData[destOffset + 2] = endCharacter;\n                    destData[destOffset + 3] = metadata;\n                    destOffset += 4;\n                    prevLineNumber = lineNumber;\n                    prevEndCharacter = endCharacter;\n                }\n            }\n            lastLineNumber = lineNumber;\n            lastStartCharacter = startCharacter;\n            tokenIndex++;\n        }\n        if (destOffset !== destData.length) {\n            destData = destData.subarray(0, destOffset);\n        }\n        const tokens = SparseMultilineTokens.create(areaLine, destData);\n        result.push(tokens);\n    }\n    return result;\n}\nclass HashTableEntry {\n    constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n        this.tokenTypeIndex = tokenTypeIndex;\n        this.tokenModifierSet = tokenModifierSet;\n        this.languageId = languageId;\n        this.metadata = metadata;\n        this.next = null;\n    }\n}\nclass HashTable {\n    constructor() {\n        this._elementsCount = 0;\n        this._currentLengthIndex = 0;\n        this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n        this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n        this._elements = [];\n        HashTable._nullOutEntries(this._elements, this._currentLength);\n    }\n    static _nullOutEntries(entries, length) {\n        for (let i = 0; i < length; i++) {\n            entries[i] = null;\n        }\n    }\n    _hash2(n1, n2) {\n        return (((n1 << 5) - n1) + n2) | 0; // n1 * 31 + n2, keep as int32\n    }\n    _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {\n        return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;\n    }\n    get(tokenTypeIndex, tokenModifierSet, languageId) {\n        const hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);\n        let p = this._elements[hash];\n        while (p) {\n            if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {\n                return p;\n            }\n            p = p.next;\n        }\n        return null;\n    }\n    add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n        this._elementsCount++;\n        if (this._growCount !== 0 && this._elementsCount >= this._growCount) {\n            // expand!\n            const oldElements = this._elements;\n            this._currentLengthIndex++;\n            this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n            this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n            this._elements = [];\n            HashTable._nullOutEntries(this._elements, this._currentLength);\n            for (const first of oldElements) {\n                let p = first;\n                while (p) {\n                    const oldNext = p.next;\n                    p.next = null;\n                    this._add(p);\n                    p = oldNext;\n                }\n            }\n        }\n        this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));\n    }\n    _add(element) {\n        const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);\n        element.next = this._elements[hash];\n        this._elements[hash] = element;\n    }\n}\nHashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];\n"],"mappings":"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"}]}