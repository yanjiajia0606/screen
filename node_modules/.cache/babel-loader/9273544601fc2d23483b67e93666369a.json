{"remainingRequest":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/thread-loader/dist/cjs.js!/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js!/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/base/common/path.js","dependencies":[{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/base/common/path.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/babel.config.js","mtime":1668271197000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/babel-loader/lib/index.js","mtime":456789000000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF90eXBlb2YgZnJvbSAiL1VzZXJzL3lhbmppYWppYS9EZXNrdG9wL3dvcmtzcGFjZS9hdnVlLWRhdGEtbmV3L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YuanMiOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIi9Vc2Vycy95YW5qaWFqaWEvRGVza3RvcC93b3Jrc3BhY2UvYXZ1ZS1kYXRhLW5ldy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanMiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIi9Vc2Vycy95YW5qaWFqaWEvRGVza3RvcC93b3Jrc3BhY2UvYXZ1ZS1kYXRhLW5ldy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanMiOwppbXBvcnQgX2luaGVyaXRzIGZyb20gIi9Vc2Vycy95YW5qaWFqaWEvRGVza3RvcC93b3Jrc3BhY2UvYXZ1ZS1kYXRhLW5ldy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHMuanMiOwppbXBvcnQgX2NyZWF0ZVN1cGVyIGZyb20gIi9Vc2Vycy95YW5qaWFqaWEvRGVza3RvcC93b3Jrc3BhY2UvYXZ1ZS1kYXRhLW5ldy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlU3VwZXIuanMiOwppbXBvcnQgX3dyYXBOYXRpdmVTdXBlciBmcm9tICIvVXNlcnMveWFuamlhamlhL0Rlc2t0b3Avd29ya3NwYWNlL2F2dWUtZGF0YS1uZXcvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3dyYXBOYXRpdmVTdXBlci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5lcnJvci5jYXVzZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyI7Ci8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uCiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLwovLyBOT1RFOiBWU0NvZGUncyBjb3B5IG9mIG5vZGVqcyBwYXRoIGxpYnJhcnkgdG8gYmUgdXNhYmxlIGluIGNvbW1vbiAobm9uLW5vZGUpIG5hbWVzcGFjZQovLyBDb3BpZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjE0LjE2LjAvbGliL3BhdGguanMKLyoqCiAqIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgogKgogKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQogKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCiAqICJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcKICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAogKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0CiAqIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZQogKiBmb2xsb3dpbmcgY29uZGl0aW9uczoKICoKICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQKICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCiAqCiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCiAqIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgogKiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwKICogREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCiAqIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKICogVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KICovCmltcG9ydCAqIGFzIHByb2Nlc3MgZnJvbSAnLi9wcm9jZXNzLmpzJzsKdmFyIENIQVJfVVBQRVJDQVNFX0EgPSA2NTsgLyogQSAqLwp2YXIgQ0hBUl9MT1dFUkNBU0VfQSA9IDk3OyAvKiBhICovCnZhciBDSEFSX1VQUEVSQ0FTRV9aID0gOTA7IC8qIFogKi8KdmFyIENIQVJfTE9XRVJDQVNFX1ogPSAxMjI7IC8qIHogKi8KdmFyIENIQVJfRE9UID0gNDY7IC8qIC4gKi8KdmFyIENIQVJfRk9SV0FSRF9TTEFTSCA9IDQ3OyAvKiAvICovCnZhciBDSEFSX0JBQ0tXQVJEX1NMQVNIID0gOTI7IC8qIFwgKi8KdmFyIENIQVJfQ09MT04gPSA1ODsgLyogOiAqLwp2YXIgQ0hBUl9RVUVTVElPTl9NQVJLID0gNjM7IC8qID8gKi8KdmFyIEVycm9ySW52YWxpZEFyZ1R5cGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikgewogIF9pbmhlcml0cyhFcnJvckludmFsaWRBcmdUeXBlLCBfRXJyb3IpOwogIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRXJyb3JJbnZhbGlkQXJnVHlwZSk7CiAgZnVuY3Rpb24gRXJyb3JJbnZhbGlkQXJnVHlwZShuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7CiAgICB2YXIgX3RoaXM7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXJyb3JJbnZhbGlkQXJnVHlwZSk7CiAgICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJwogICAgdmFyIGRldGVybWluZXI7CiAgICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBleHBlY3RlZC5pbmRleE9mKCdub3QgJykgPT09IDApIHsKICAgICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7CiAgICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7CiAgICB9IGVsc2UgewogICAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnOwogICAgfQogICAgdmFyIHR5cGUgPSBuYW1lLmluZGV4T2YoJy4nKSAhPT0gLTEgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JzsKICAgIHZhciBtc2cgPSAiVGhlIFwiIi5jb25jYXQobmFtZSwgIlwiICIpLmNvbmNhdCh0eXBlLCAiICIpLmNvbmNhdChkZXRlcm1pbmVyLCAiIG9mIHR5cGUgIikuY29uY2F0KGV4cGVjdGVkKTsKICAgIG1zZyArPSAiLiBSZWNlaXZlZCB0eXBlICIuY29uY2F0KF90eXBlb2YoYWN0dWFsKSk7CiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1zZyk7CiAgICBfdGhpcy5jb2RlID0gJ0VSUl9JTlZBTElEX0FSR19UWVBFJzsKICAgIHJldHVybiBfdGhpczsKICB9CiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFcnJvckludmFsaWRBcmdUeXBlKTsKfSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTsKZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcodmFsdWUsIG5hbWUpIHsKICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgewogICAgdGhyb3cgbmV3IEVycm9ySW52YWxpZEFyZ1R5cGUobmFtZSwgJ3N0cmluZycsIHZhbHVlKTsKICB9Cn0KZnVuY3Rpb24gaXNQYXRoU2VwYXJhdG9yKGNvZGUpIHsKICByZXR1cm4gY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIIHx8IGNvZGUgPT09IENIQVJfQkFDS1dBUkRfU0xBU0g7Cn0KZnVuY3Rpb24gaXNQb3NpeFBhdGhTZXBhcmF0b3IoY29kZSkgewogIHJldHVybiBjb2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0g7Cn0KZnVuY3Rpb24gaXNXaW5kb3dzRGV2aWNlUm9vdChjb2RlKSB7CiAgcmV0dXJuIGNvZGUgPj0gQ0hBUl9VUFBFUkNBU0VfQSAmJiBjb2RlIDw9IENIQVJfVVBQRVJDQVNFX1ogfHwgY29kZSA+PSBDSEFSX0xPV0VSQ0FTRV9BICYmIGNvZGUgPD0gQ0hBUl9MT1dFUkNBU0VfWjsKfQovLyBSZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggd2l0aCBkaXJlY3RvcnkgbmFtZXMKZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nKHBhdGgsIGFsbG93QWJvdmVSb290LCBzZXBhcmF0b3IsIGlzUGF0aFNlcGFyYXRvcikgewogIHZhciByZXMgPSAnJzsKICB2YXIgbGFzdFNlZ21lbnRMZW5ndGggPSAwOwogIHZhciBsYXN0U2xhc2ggPSAtMTsKICB2YXIgZG90cyA9IDA7CiAgdmFyIGNvZGUgPSAwOwogIGZvciAodmFyIGkgPSAwOyBpIDw9IHBhdGgubGVuZ3RoOyArK2kpIHsKICAgIGlmIChpIDwgcGF0aC5sZW5ndGgpIHsKICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTsKICAgIH0gZWxzZSBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7CiAgICAgIGJyZWFrOwogICAgfSBlbHNlIHsKICAgICAgY29kZSA9IENIQVJfRk9SV0FSRF9TTEFTSDsKICAgIH0KICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHsKICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gaSAtIDEgfHwgZG90cyA9PT0gMSkgewogICAgICAgIC8vIE5PT1AKICAgICAgfSBlbHNlIGlmIChkb3RzID09PSAyKSB7CiAgICAgICAgaWYgKHJlcy5sZW5ndGggPCAyIHx8IGxhc3RTZWdtZW50TGVuZ3RoICE9PSAyIHx8IHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAxKSAhPT0gQ0hBUl9ET1QgfHwgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDIpICE9PSBDSEFSX0RPVCkgewogICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAyKSB7CiAgICAgICAgICAgIHZhciBsYXN0U2xhc2hJbmRleCA9IHJlcy5sYXN0SW5kZXhPZihzZXBhcmF0b3IpOwogICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggPT09IC0xKSB7CiAgICAgICAgICAgICAgcmVzID0gJyc7CiAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJlcyA9IHJlcy5zbGljZSgwLCBsYXN0U2xhc2hJbmRleCk7CiAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSByZXMubGVuZ3RoIC0gMSAtIHJlcy5sYXN0SW5kZXhPZihzZXBhcmF0b3IpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7CiAgICAgICAgICAgIGRvdHMgPSAwOwogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0gZWxzZSBpZiAocmVzLmxlbmd0aCAhPT0gMCkgewogICAgICAgICAgICByZXMgPSAnJzsKICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwOwogICAgICAgICAgICBsYXN0U2xhc2ggPSBpOwogICAgICAgICAgICBkb3RzID0gMDsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkgewogICAgICAgICAgcmVzICs9IHJlcy5sZW5ndGggPiAwID8gIiIuY29uY2F0KHNlcGFyYXRvciwgIi4uIikgOiAnLi4nOwogICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAyOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApIHsKICAgICAgICAgIHJlcyArPSAiIi5jb25jYXQoc2VwYXJhdG9yKS5jb25jYXQocGF0aC5zbGljZShsYXN0U2xhc2ggKyAxLCBpKSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJlcyA9IHBhdGguc2xpY2UobGFzdFNsYXNoICsgMSwgaSk7CiAgICAgICAgfQogICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gaSAtIGxhc3RTbGFzaCAtIDE7CiAgICAgIH0KICAgICAgbGFzdFNsYXNoID0gaTsKICAgICAgZG90cyA9IDA7CiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IENIQVJfRE9UICYmIGRvdHMgIT09IC0xKSB7CiAgICAgICsrZG90czsKICAgIH0gZWxzZSB7CiAgICAgIGRvdHMgPSAtMTsKICAgIH0KICB9CiAgcmV0dXJuIHJlczsKfQpmdW5jdGlvbiBfZm9ybWF0KHNlcCwgcGF0aE9iamVjdCkgewogIGlmIChwYXRoT2JqZWN0ID09PSBudWxsIHx8IF90eXBlb2YocGF0aE9iamVjdCkgIT09ICdvYmplY3QnKSB7CiAgICB0aHJvdyBuZXcgRXJyb3JJbnZhbGlkQXJnVHlwZSgncGF0aE9iamVjdCcsICdPYmplY3QnLCBwYXRoT2JqZWN0KTsKICB9CiAgdmFyIGRpciA9IHBhdGhPYmplY3QuZGlyIHx8IHBhdGhPYmplY3Qucm9vdDsKICB2YXIgYmFzZSA9IHBhdGhPYmplY3QuYmFzZSB8fCAiIi5jb25jYXQocGF0aE9iamVjdC5uYW1lIHx8ICcnKS5jb25jYXQocGF0aE9iamVjdC5leHQgfHwgJycpOwogIGlmICghZGlyKSB7CiAgICByZXR1cm4gYmFzZTsKICB9CiAgcmV0dXJuIGRpciA9PT0gcGF0aE9iamVjdC5yb290ID8gIiIuY29uY2F0KGRpcikuY29uY2F0KGJhc2UpIDogIiIuY29uY2F0KGRpcikuY29uY2F0KHNlcCkuY29uY2F0KGJhc2UpOwp9CmV4cG9ydCB2YXIgd2luMzIgPSB7CiAgLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKQogIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoKSB7CiAgICB2YXIgcmVzb2x2ZWREZXZpY2UgPSAnJzsKICAgIHZhciByZXNvbHZlZFRhaWwgPSAnJzsKICAgIHZhciByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7CiAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTE7IGktLSkgewogICAgICB2YXIgcGF0aCA9IHZvaWQgMDsKICAgICAgaWYgKGkgPj0gMCkgewogICAgICAgIHBhdGggPSBpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV07CiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTsKICAgICAgICAvLyBTa2lwIGVtcHR5IGVudHJpZXMKICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChyZXNvbHZlZERldmljZS5sZW5ndGggPT09IDApIHsKICAgICAgICBwYXRoID0gcHJvY2Vzcy5jd2QoKTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBXaW5kb3dzIGhhcyB0aGUgY29uY2VwdCBvZiBkcml2ZS1zcGVjaWZpYyBjdXJyZW50IHdvcmtpbmcKICAgICAgICAvLyBkaXJlY3Rvcmllcy4gSWYgd2UndmUgcmVzb2x2ZWQgYSBkcml2ZSBsZXR0ZXIgYnV0IG5vdCB5ZXQgYW4KICAgICAgICAvLyBhYnNvbHV0ZSBwYXRoLCBnZXQgY3dkIGZvciB0aGF0IGRyaXZlLCBvciB0aGUgcHJvY2VzcyBjd2QgaWYKICAgICAgICAvLyB0aGUgZHJpdmUgY3dkIGlzIG5vdCBhdmFpbGFibGUuIFdlJ3JlIHN1cmUgdGhlIGRldmljZSBpcyBub3QKICAgICAgICAvLyBhIFVOQyBwYXRoIGF0IHRoaXMgcG9pbnRzLCBiZWNhdXNlIFVOQyBwYXRocyBhcmUgYWx3YXlzIGFic29sdXRlLgogICAgICAgIHBhdGggPSBwcm9jZXNzLmVudlsiPSIuY29uY2F0KHJlc29sdmVkRGV2aWNlKV0gfHwgcHJvY2Vzcy5jd2QoKTsKICAgICAgICAvLyBWZXJpZnkgdGhhdCBhIGN3ZCB3YXMgZm91bmQgYW5kIHRoYXQgaXQgYWN0dWFsbHkgcG9pbnRzCiAgICAgICAgLy8gdG8gb3VyIGRyaXZlLiBJZiBub3QsIGRlZmF1bHQgdG8gdGhlIGRyaXZlJ3Mgcm9vdC4KICAgICAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkIHx8IHBhdGguc2xpY2UoMCwgMikudG9Mb3dlckNhc2UoKSAhPT0gcmVzb2x2ZWREZXZpY2UudG9Mb3dlckNhc2UoKSAmJiBwYXRoLmNoYXJDb2RlQXQoMikgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHsKICAgICAgICAgIHBhdGggPSAiIi5jb25jYXQocmVzb2x2ZWREZXZpY2UsICJcXCIpOwogICAgICAgIH0KICAgICAgfQogICAgICB2YXIgbGVuID0gcGF0aC5sZW5ndGg7CiAgICAgIHZhciByb290RW5kID0gMDsKICAgICAgdmFyIGRldmljZSA9ICcnOwogICAgICB2YXIgaXNBYnNvbHV0ZSA9IGZhbHNlOwogICAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTsKICAgICAgLy8gVHJ5IHRvIG1hdGNoIGEgcm9vdAogICAgICBpZiAobGVuID09PSAxKSB7CiAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkgewogICAgICAgICAgLy8gYHBhdGhgIGNvbnRhaW5zIGp1c3QgYSBwYXRoIHNlcGFyYXRvcgogICAgICAgICAgcm9vdEVuZCA9IDE7CiAgICAgICAgICBpc0Fic29sdXRlID0gdHJ1ZTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7CiAgICAgICAgLy8gUG9zc2libGUgVU5DIHJvb3QKICAgICAgICAvLyBJZiB3ZSBzdGFydGVkIHdpdGggYSBzZXBhcmF0b3IsIHdlIGtub3cgd2UgYXQgbGVhc3QgaGF2ZSBhbgogICAgICAgIC8vIGFic29sdXRlIHBhdGggb2Ygc29tZSBraW5kIChVTkMgb3Igb3RoZXJ3aXNlKQogICAgICAgIGlzQWJzb2x1dGUgPSB0cnVlOwogICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDEpKSkgewogICAgICAgICAgLy8gTWF0Y2hlZCBkb3VibGUgcGF0aCBzZXBhcmF0b3IgYXQgYmVnaW5uaW5nCiAgICAgICAgICB2YXIgaiA9IDI7CiAgICAgICAgICB2YXIgbGFzdCA9IGo7CiAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9ycwogICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7CiAgICAgICAgICAgIGorKzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHsKICAgICAgICAgICAgdmFyIGZpcnN0UGFydCA9IHBhdGguc2xpY2UobGFzdCwgaik7CiAgICAgICAgICAgIC8vIE1hdGNoZWQhCiAgICAgICAgICAgIGxhc3QgPSBqOwogICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgcGF0aCBzZXBhcmF0b3JzCiAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7CiAgICAgICAgICAgICAgaisrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHsKICAgICAgICAgICAgICAvLyBNYXRjaGVkIQogICAgICAgICAgICAgIGxhc3QgPSBqOwogICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzCiAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7CiAgICAgICAgICAgICAgICBqKys7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChqID09PSBsZW4gfHwgaiAhPT0gbGFzdCkgewogICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290CiAgICAgICAgICAgICAgICBkZXZpY2UgPSAiXFxcXCIuY29uY2F0KGZpcnN0UGFydCwgIlxcIikuY29uY2F0KHBhdGguc2xpY2UobGFzdCwgaikpOwogICAgICAgICAgICAgICAgcm9vdEVuZCA9IGo7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJvb3RFbmQgPSAxOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VSb290KGNvZGUpICYmIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTikgewogICAgICAgIC8vIFBvc3NpYmxlIGRldmljZSByb290CiAgICAgICAgZGV2aWNlID0gcGF0aC5zbGljZSgwLCAyKTsKICAgICAgICByb290RW5kID0gMjsKICAgICAgICBpZiAobGVuID4gMiAmJiBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDIpKSkgewogICAgICAgICAgLy8gVHJlYXQgc2VwYXJhdG9yIGZvbGxvd2luZyBkcml2ZSBuYW1lIGFzIGFuIGFic29sdXRlIHBhdGgKICAgICAgICAgIC8vIGluZGljYXRvcgogICAgICAgICAgaXNBYnNvbHV0ZSA9IHRydWU7CiAgICAgICAgICByb290RW5kID0gMzsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKGRldmljZS5sZW5ndGggPiAwKSB7CiAgICAgICAgaWYgKHJlc29sdmVkRGV2aWNlLmxlbmd0aCA+IDApIHsKICAgICAgICAgIGlmIChkZXZpY2UudG9Mb3dlckNhc2UoKSAhPT0gcmVzb2x2ZWREZXZpY2UudG9Mb3dlckNhc2UoKSkgewogICAgICAgICAgICAvLyBUaGlzIHBhdGggcG9pbnRzIHRvIGFub3RoZXIgZGV2aWNlIHNvIGl0IGlzIG5vdCBhcHBsaWNhYmxlCiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXNvbHZlZERldmljZSA9IGRldmljZTsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKHJlc29sdmVkQWJzb2x1dGUpIHsKICAgICAgICBpZiAocmVzb2x2ZWREZXZpY2UubGVuZ3RoID4gMCkgewogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIHJlc29sdmVkVGFpbCA9ICIiLmNvbmNhdChwYXRoLnNsaWNlKHJvb3RFbmQpLCAiXFwiKS5jb25jYXQocmVzb2x2ZWRUYWlsKTsKICAgICAgICByZXNvbHZlZEFic29sdXRlID0gaXNBYnNvbHV0ZTsKICAgICAgICBpZiAoaXNBYnNvbHV0ZSAmJiByZXNvbHZlZERldmljZS5sZW5ndGggPiAwKSB7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLAogICAgLy8gYnV0IGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpCiAgICAvLyBmYWlscykKICAgIC8vIE5vcm1hbGl6ZSB0aGUgdGFpbCBwYXRoCiAgICByZXNvbHZlZFRhaWwgPSBub3JtYWxpemVTdHJpbmcocmVzb2x2ZWRUYWlsLCAhcmVzb2x2ZWRBYnNvbHV0ZSwgJ1xcJywgaXNQYXRoU2VwYXJhdG9yKTsKICAgIHJldHVybiByZXNvbHZlZEFic29sdXRlID8gIiIuY29uY2F0KHJlc29sdmVkRGV2aWNlLCAiXFwiKS5jb25jYXQocmVzb2x2ZWRUYWlsKSA6ICIiLmNvbmNhdChyZXNvbHZlZERldmljZSkuY29uY2F0KHJlc29sdmVkVGFpbCkgfHwgJy4nOwogIH0sCiAgbm9ybWFsaXplOiBmdW5jdGlvbiBub3JtYWxpemUocGF0aCkgewogICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTsKICAgIHZhciBsZW4gPSBwYXRoLmxlbmd0aDsKICAgIGlmIChsZW4gPT09IDApIHsKICAgICAgcmV0dXJuICcuJzsKICAgIH0KICAgIHZhciByb290RW5kID0gMDsKICAgIHZhciBkZXZpY2U7CiAgICB2YXIgaXNBYnNvbHV0ZSA9IGZhbHNlOwogICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7CiAgICAvLyBUcnkgdG8gbWF0Y2ggYSByb290CiAgICBpZiAobGVuID09PSAxKSB7CiAgICAgIC8vIGBwYXRoYCBjb250YWlucyBqdXN0IGEgc2luZ2xlIGNoYXIsIGV4aXQgZWFybHkgdG8gYXZvaWQKICAgICAgLy8gdW5uZWNlc3Nhcnkgd29yawogICAgICByZXR1cm4gaXNQb3NpeFBhdGhTZXBhcmF0b3IoY29kZSkgPyAnXFwnIDogcGF0aDsKICAgIH0KICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHsKICAgICAgLy8gUG9zc2libGUgVU5DIHJvb3QKICAgICAgLy8gSWYgd2Ugc3RhcnRlZCB3aXRoIGEgc2VwYXJhdG9yLCB3ZSBrbm93IHdlIGF0IGxlYXN0IGhhdmUgYW4gYWJzb2x1dGUKICAgICAgLy8gcGF0aCBvZiBzb21lIGtpbmQgKFVOQyBvciBvdGhlcndpc2UpCiAgICAgIGlzQWJzb2x1dGUgPSB0cnVlOwogICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgxKSkpIHsKICAgICAgICAvLyBNYXRjaGVkIGRvdWJsZSBwYXRoIHNlcGFyYXRvciBhdCBiZWdpbm5pbmcKICAgICAgICB2YXIgaiA9IDI7CiAgICAgICAgdmFyIGxhc3QgPSBqOwogICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzCiAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7CiAgICAgICAgICBqKys7CiAgICAgICAgfQogICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHsKICAgICAgICAgIHZhciBmaXJzdFBhcnQgPSBwYXRoLnNsaWNlKGxhc3QsIGopOwogICAgICAgICAgLy8gTWF0Y2hlZCEKICAgICAgICAgIGxhc3QgPSBqOwogICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIHBhdGggc2VwYXJhdG9ycwogICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHsKICAgICAgICAgICAgaisrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkgewogICAgICAgICAgICAvLyBNYXRjaGVkIQogICAgICAgICAgICBsYXN0ID0gajsKICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnMKICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7CiAgICAgICAgICAgICAgaisrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChqID09PSBsZW4pIHsKICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3Qgb25seQogICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBVTkMgcm9vdCBzaW5jZSB0aGVyZQogICAgICAgICAgICAgIC8vIGlzIG5vdGhpbmcgbGVmdCB0byBwcm9jZXNzCiAgICAgICAgICAgICAgcmV0dXJuICJcXFxcIi5jb25jYXQoZmlyc3RQYXJ0LCAiXFwiKS5jb25jYXQocGF0aC5zbGljZShsYXN0KSwgIlxcIik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGogIT09IGxhc3QpIHsKICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3Qgd2l0aCBsZWZ0b3ZlcnMKICAgICAgICAgICAgICBkZXZpY2UgPSAiXFxcXCIuY29uY2F0KGZpcnN0UGFydCwgIlxcIikuY29uY2F0KHBhdGguc2xpY2UobGFzdCwgaikpOwogICAgICAgICAgICAgIHJvb3RFbmQgPSBqOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIHJvb3RFbmQgPSAxOwogICAgICB9CiAgICB9IGVsc2UgaWYgKGlzV2luZG93c0RldmljZVJvb3QoY29kZSkgJiYgcGF0aC5jaGFyQ29kZUF0KDEpID09PSBDSEFSX0NPTE9OKSB7CiAgICAgIC8vIFBvc3NpYmxlIGRldmljZSByb290CiAgICAgIGRldmljZSA9IHBhdGguc2xpY2UoMCwgMik7CiAgICAgIHJvb3RFbmQgPSAyOwogICAgICBpZiAobGVuID4gMiAmJiBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDIpKSkgewogICAgICAgIC8vIFRyZWF0IHNlcGFyYXRvciBmb2xsb3dpbmcgZHJpdmUgbmFtZSBhcyBhbiBhYnNvbHV0ZSBwYXRoCiAgICAgICAgLy8gaW5kaWNhdG9yCiAgICAgICAgaXNBYnNvbHV0ZSA9IHRydWU7CiAgICAgICAgcm9vdEVuZCA9IDM7CiAgICAgIH0KICAgIH0KICAgIHZhciB0YWlsID0gcm9vdEVuZCA8IGxlbiA/IG5vcm1hbGl6ZVN0cmluZyhwYXRoLnNsaWNlKHJvb3RFbmQpLCAhaXNBYnNvbHV0ZSwgJ1xcJywgaXNQYXRoU2VwYXJhdG9yKSA6ICcnOwogICAgaWYgKHRhaWwubGVuZ3RoID09PSAwICYmICFpc0Fic29sdXRlKSB7CiAgICAgIHRhaWwgPSAnLic7CiAgICB9CiAgICBpZiAodGFpbC5sZW5ndGggPiAwICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQobGVuIC0gMSkpKSB7CiAgICAgIHRhaWwgKz0gJ1xcJzsKICAgIH0KICAgIGlmIChkZXZpY2UgPT09IHVuZGVmaW5lZCkgewogICAgICByZXR1cm4gaXNBYnNvbHV0ZSA/ICJcXCIuY29uY2F0KHRhaWwpIDogdGFpbDsKICAgIH0KICAgIHJldHVybiBpc0Fic29sdXRlID8gIiIuY29uY2F0KGRldmljZSwgIlxcIikuY29uY2F0KHRhaWwpIDogIiIuY29uY2F0KGRldmljZSkuY29uY2F0KHRhaWwpOwogIH0sCiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24gaXNBYnNvbHV0ZShwYXRoKSB7CiAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpOwogICAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoOwogICAgaWYgKGxlbiA9PT0gMCkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTsKICAgIHJldHVybiBpc1BhdGhTZXBhcmF0b3IoY29kZSkgfHwKICAgIC8vIFBvc3NpYmxlIGRldmljZSByb290CiAgICBsZW4gPiAyICYmIGlzV2luZG93c0RldmljZVJvb3QoY29kZSkgJiYgcGF0aC5jaGFyQ29kZUF0KDEpID09PSBDSEFSX0NPTE9OICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMikpOwogIH0sCiAgam9pbjogZnVuY3Rpb24gam9pbigpIHsKICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiAnLic7CiAgICB9CiAgICB2YXIgam9pbmVkOwogICAgdmFyIGZpcnN0UGFydDsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7CiAgICAgIHZhciBhcmcgPSBpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV07CiAgICAgIHZhbGlkYXRlU3RyaW5nKGFyZywgJ3BhdGgnKTsKICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7CiAgICAgICAgaWYgKGpvaW5lZCA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICBqb2luZWQgPSBmaXJzdFBhcnQgPSBhcmc7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGpvaW5lZCArPSAiXFwiLmNvbmNhdChhcmcpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgaWYgKGpvaW5lZCA9PT0gdW5kZWZpbmVkKSB7CiAgICAgIHJldHVybiAnLic7CiAgICB9CiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgam9pbmVkIHBhdGggZG9lc24ndCBzdGFydCB3aXRoIHR3byBzbGFzaGVzLCBiZWNhdXNlCiAgICAvLyBub3JtYWxpemUoKSB3aWxsIG1pc3Rha2UgaXQgZm9yIGEgVU5DIHBhdGggdGhlbi4KICAgIC8vCiAgICAvLyBUaGlzIHN0ZXAgaXMgc2tpcHBlZCB3aGVuIGl0IGlzIHZlcnkgY2xlYXIgdGhhdCB0aGUgdXNlciBhY3R1YWxseQogICAgLy8gaW50ZW5kZWQgdG8gcG9pbnQgYXQgYSBVTkMgcGF0aC4gVGhpcyBpcyBhc3N1bWVkIHdoZW4gdGhlIGZpcnN0CiAgICAvLyBub24tZW1wdHkgc3RyaW5nIGFyZ3VtZW50cyBzdGFydHMgd2l0aCBleGFjdGx5IHR3byBzbGFzaGVzIGZvbGxvd2VkIGJ5CiAgICAvLyBhdCBsZWFzdCBvbmUgbW9yZSBub24tc2xhc2ggY2hhcmFjdGVyLgogICAgLy8KICAgIC8vIE5vdGUgdGhhdCBmb3Igbm9ybWFsaXplKCkgdG8gdHJlYXQgYSBwYXRoIGFzIGEgVU5DIHBhdGggaXQgbmVlZHMgdG8KICAgIC8vIGhhdmUgYXQgbGVhc3QgMiBjb21wb25lbnRzLCBzbyB3ZSBkb24ndCBmaWx0ZXIgZm9yIHRoYXQgaGVyZS4KICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgdXNlciBjYW4gdXNlIGpvaW4gdG8gY29uc3RydWN0IFVOQyBwYXRocyBmcm9tCiAgICAvLyBhIHNlcnZlciBuYW1lIGFuZCBhIHNoYXJlIG5hbWU7IGZvciBleGFtcGxlOgogICAgLy8gICBwYXRoLmpvaW4oJy8vc2VydmVyJywgJ3NoYXJlJykgLT4gJ1xcXFxzZXJ2ZXJcXHNoYXJlXFwnKQogICAgdmFyIG5lZWRzUmVwbGFjZSA9IHRydWU7CiAgICB2YXIgc2xhc2hDb3VudCA9IDA7CiAgICBpZiAodHlwZW9mIGZpcnN0UGFydCA9PT0gJ3N0cmluZycgJiYgaXNQYXRoU2VwYXJhdG9yKGZpcnN0UGFydC5jaGFyQ29kZUF0KDApKSkgewogICAgICArK3NsYXNoQ291bnQ7CiAgICAgIHZhciBmaXJzdExlbiA9IGZpcnN0UGFydC5sZW5ndGg7CiAgICAgIGlmIChmaXJzdExlbiA+IDEgJiYgaXNQYXRoU2VwYXJhdG9yKGZpcnN0UGFydC5jaGFyQ29kZUF0KDEpKSkgewogICAgICAgICsrc2xhc2hDb3VudDsKICAgICAgICBpZiAoZmlyc3RMZW4gPiAyKSB7CiAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGZpcnN0UGFydC5jaGFyQ29kZUF0KDIpKSkgewogICAgICAgICAgICArK3NsYXNoQ291bnQ7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHBhdGggaW4gdGhlIGZpcnN0IHBhcnQKICAgICAgICAgICAgbmVlZHNSZXBsYWNlID0gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBpZiAobmVlZHNSZXBsYWNlKSB7CiAgICAgIC8vIEZpbmQgYW55IG1vcmUgY29uc2VjdXRpdmUgc2xhc2hlcyB3ZSBuZWVkIHRvIHJlcGxhY2UKICAgICAgd2hpbGUgKHNsYXNoQ291bnQgPCBqb2luZWQubGVuZ3RoICYmIGlzUGF0aFNlcGFyYXRvcihqb2luZWQuY2hhckNvZGVBdChzbGFzaENvdW50KSkpIHsKICAgICAgICBzbGFzaENvdW50Kys7CiAgICAgIH0KICAgICAgLy8gUmVwbGFjZSB0aGUgc2xhc2hlcyBpZiBuZWVkZWQKICAgICAgaWYgKHNsYXNoQ291bnQgPj0gMikgewogICAgICAgIGpvaW5lZCA9ICJcXCIuY29uY2F0KGpvaW5lZC5zbGljZShzbGFzaENvdW50KSk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiB3aW4zMi5ub3JtYWxpemUoam9pbmVkKTsKICB9LAogIC8vIEl0IHdpbGwgc29sdmUgdGhlIHJlbGF0aXZlIHBhdGggZnJvbSBgZnJvbWAgdG8gYHRvYCwgZm9yIGluc3RhbmNlOgogIC8vICBmcm9tID0gJ0M6XFxvcmFuZGVhXFx0ZXN0XFxhYWEnCiAgLy8gIHRvID0gJ0M6XFxvcmFuZGVhXFxpbXBsXFxiYmInCiAgLy8gVGhlIG91dHB1dCBvZiB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlOiAnLi5cXC4uXFxpbXBsXFxiYmInCiAgcmVsYXRpdmU6IGZ1bmN0aW9uIHJlbGF0aXZlKGZyb20sIHRvKSB7CiAgICB2YWxpZGF0ZVN0cmluZyhmcm9tLCAnZnJvbScpOwogICAgdmFsaWRhdGVTdHJpbmcodG8sICd0bycpOwogICAgaWYgKGZyb20gPT09IHRvKSB7CiAgICAgIHJldHVybiAnJzsKICAgIH0KICAgIHZhciBmcm9tT3JpZyA9IHdpbjMyLnJlc29sdmUoZnJvbSk7CiAgICB2YXIgdG9PcmlnID0gd2luMzIucmVzb2x2ZSh0byk7CiAgICBpZiAoZnJvbU9yaWcgPT09IHRvT3JpZykgewogICAgICByZXR1cm4gJyc7CiAgICB9CiAgICBmcm9tID0gZnJvbU9yaWcudG9Mb3dlckNhc2UoKTsKICAgIHRvID0gdG9PcmlnLnRvTG93ZXJDYXNlKCk7CiAgICBpZiAoZnJvbSA9PT0gdG8pIHsKICAgICAgcmV0dXJuICcnOwogICAgfQogICAgLy8gVHJpbSBhbnkgbGVhZGluZyBiYWNrc2xhc2hlcwogICAgdmFyIGZyb21TdGFydCA9IDA7CiAgICB3aGlsZSAoZnJvbVN0YXJ0IDwgZnJvbS5sZW5ndGggJiYgZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHsKICAgICAgZnJvbVN0YXJ0Kys7CiAgICB9CiAgICAvLyBUcmltIHRyYWlsaW5nIGJhY2tzbGFzaGVzIChhcHBsaWNhYmxlIHRvIFVOQyBwYXRocyBvbmx5KQogICAgdmFyIGZyb21FbmQgPSBmcm9tLmxlbmd0aDsKICAgIHdoaWxlIChmcm9tRW5kIC0gMSA+IGZyb21TdGFydCAmJiBmcm9tLmNoYXJDb2RlQXQoZnJvbUVuZCAtIDEpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7CiAgICAgIGZyb21FbmQtLTsKICAgIH0KICAgIHZhciBmcm9tTGVuID0gZnJvbUVuZCAtIGZyb21TdGFydDsKICAgIC8vIFRyaW0gYW55IGxlYWRpbmcgYmFja3NsYXNoZXMKICAgIHZhciB0b1N0YXJ0ID0gMDsKICAgIHdoaWxlICh0b1N0YXJ0IDwgdG8ubGVuZ3RoICYmIHRvLmNoYXJDb2RlQXQodG9TdGFydCkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHsKICAgICAgdG9TdGFydCsrOwogICAgfQogICAgLy8gVHJpbSB0cmFpbGluZyBiYWNrc2xhc2hlcyAoYXBwbGljYWJsZSB0byBVTkMgcGF0aHMgb25seSkKICAgIHZhciB0b0VuZCA9IHRvLmxlbmd0aDsKICAgIHdoaWxlICh0b0VuZCAtIDEgPiB0b1N0YXJ0ICYmIHRvLmNoYXJDb2RlQXQodG9FbmQgLSAxKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkgewogICAgICB0b0VuZC0tOwogICAgfQogICAgdmFyIHRvTGVuID0gdG9FbmQgLSB0b1N0YXJ0OwogICAgLy8gQ29tcGFyZSBwYXRocyB0byBmaW5kIHRoZSBsb25nZXN0IGNvbW1vbiBwYXRoIGZyb20gcm9vdAogICAgdmFyIGxlbmd0aCA9IGZyb21MZW4gPCB0b0xlbiA/IGZyb21MZW4gOiB0b0xlbjsKICAgIHZhciBsYXN0Q29tbW9uU2VwID0gLTE7CiAgICB2YXIgaSA9IDA7CiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgIHZhciBmcm9tQ29kZSA9IGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKTsKICAgICAgaWYgKGZyb21Db2RlICE9PSB0by5jaGFyQ29kZUF0KHRvU3RhcnQgKyBpKSkgewogICAgICAgIGJyZWFrOwogICAgICB9IGVsc2UgaWYgKGZyb21Db2RlID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7CiAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7CiAgICAgIH0KICAgIH0KICAgIC8vIFdlIGZvdW5kIGEgbWlzbWF0Y2ggYmVmb3JlIHRoZSBmaXJzdCBjb21tb24gcGF0aCBzZXBhcmF0b3Igd2FzIHNlZW4sIHNvCiAgICAvLyByZXR1cm4gdGhlIG9yaWdpbmFsIGB0b2AuCiAgICBpZiAoaSAhPT0gbGVuZ3RoKSB7CiAgICAgIGlmIChsYXN0Q29tbW9uU2VwID09PSAtMSkgewogICAgICAgIHJldHVybiB0b09yaWc7CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIGlmICh0b0xlbiA+IGxlbmd0aCkgewogICAgICAgIGlmICh0by5jaGFyQ29kZUF0KHRvU3RhcnQgKyBpKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkgewogICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYGZyb21gIGlzIHRoZSBleGFjdCBiYXNlIHBhdGggZm9yIGB0b2AuCiAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nQzpcXGZvb1xcYmFyJzsgdG89J0M6XFxmb29cXGJhclxcYmF6JwogICAgICAgICAgcmV0dXJuIHRvT3JpZy5zbGljZSh0b1N0YXJ0ICsgaSArIDEpOwogICAgICAgIH0KICAgICAgICBpZiAoaSA9PT0gMikgewogICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYGZyb21gIGlzIHRoZSBkZXZpY2Ugcm9vdC4KICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPSdDOlxcJzsgdG89J0M6XFxmb28nCiAgICAgICAgICByZXR1cm4gdG9PcmlnLnNsaWNlKHRvU3RhcnQgKyBpKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKGZyb21MZW4gPiBsZW5ndGgpIHsKICAgICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7CiAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSBleGFjdCBiYXNlIHBhdGggZm9yIGBmcm9tYC4KICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPSdDOlxcZm9vXFxiYXInOyB0bz0nQzpcXGZvbycKICAgICAgICAgIGxhc3RDb21tb25TZXAgPSBpOwogICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMikgewogICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgZGV2aWNlIHJvb3QuCiAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nQzpcXGZvb1xcYmFyJzsgdG89J0M6XFwnCiAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gMzsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKGxhc3RDb21tb25TZXAgPT09IC0xKSB7CiAgICAgICAgbGFzdENvbW1vblNlcCA9IDA7CiAgICAgIH0KICAgIH0KICAgIHZhciBvdXQgPSAnJzsKICAgIC8vIEdlbmVyYXRlIHRoZSByZWxhdGl2ZSBwYXRoIGJhc2VkIG9uIHRoZSBwYXRoIGRpZmZlcmVuY2UgYmV0d2VlbiBgdG9gIGFuZAogICAgLy8gYGZyb21gCiAgICBmb3IgKGkgPSBmcm9tU3RhcnQgKyBsYXN0Q29tbW9uU2VwICsgMTsgaSA8PSBmcm9tRW5kOyArK2kpIHsKICAgICAgaWYgKGkgPT09IGZyb21FbmQgfHwgZnJvbS5jaGFyQ29kZUF0KGkpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7CiAgICAgICAgb3V0ICs9IG91dC5sZW5ndGggPT09IDAgPyAnLi4nIDogJ1xcLi4nOwogICAgICB9CiAgICB9CiAgICB0b1N0YXJ0ICs9IGxhc3RDb21tb25TZXA7CiAgICAvLyBMYXN0bHksIGFwcGVuZCB0aGUgcmVzdCBvZiB0aGUgZGVzdGluYXRpb24gKGB0b2ApIHBhdGggdGhhdCBjb21lcyBhZnRlcgogICAgLy8gdGhlIGNvbW1vbiBwYXRoIHBhcnRzCiAgICBpZiAob3V0Lmxlbmd0aCA+IDApIHsKICAgICAgcmV0dXJuICIiLmNvbmNhdChvdXQpLmNvbmNhdCh0b09yaWcuc2xpY2UodG9TdGFydCwgdG9FbmQpKTsKICAgIH0KICAgIGlmICh0b09yaWcuY2hhckNvZGVBdCh0b1N0YXJ0KSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkgewogICAgICArK3RvU3RhcnQ7CiAgICB9CiAgICByZXR1cm4gdG9PcmlnLnNsaWNlKHRvU3RhcnQsIHRvRW5kKTsKICB9LAogIHRvTmFtZXNwYWNlZFBhdGg6IGZ1bmN0aW9uIHRvTmFtZXNwYWNlZFBhdGgocGF0aCkgewogICAgLy8gTm90ZTogdGhpcyB3aWxsICpwcm9iYWJseSogdGhyb3cgc29tZXdoZXJlLgogICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgewogICAgICByZXR1cm4gcGF0aDsKICAgIH0KICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgewogICAgICByZXR1cm4gJyc7CiAgICB9CiAgICB2YXIgcmVzb2x2ZWRQYXRoID0gd2luMzIucmVzb2x2ZShwYXRoKTsKICAgIGlmIChyZXNvbHZlZFBhdGgubGVuZ3RoIDw9IDIpIHsKICAgICAgcmV0dXJuIHBhdGg7CiAgICB9CiAgICBpZiAocmVzb2x2ZWRQYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHsKICAgICAgLy8gUG9zc2libGUgVU5DIHJvb3QKICAgICAgaWYgKHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDEpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7CiAgICAgICAgdmFyIGNvZGUgPSByZXNvbHZlZFBhdGguY2hhckNvZGVBdCgyKTsKICAgICAgICBpZiAoY29kZSAhPT0gQ0hBUl9RVUVTVElPTl9NQVJLICYmIGNvZGUgIT09IENIQVJfRE9UKSB7CiAgICAgICAgICAvLyBNYXRjaGVkIG5vbi1sb25nIFVOQyByb290LCBjb252ZXJ0IHRoZSBwYXRoIHRvIGEgbG9uZyBVTkMgcGF0aAogICAgICAgICAgcmV0dXJuICJcXFxcP1xcVU5DXFwiLmNvbmNhdChyZXNvbHZlZFBhdGguc2xpY2UoMikpOwogICAgICAgIH0KICAgICAgfQogICAgfSBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VSb290KHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDApKSAmJiByZXNvbHZlZFBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTiAmJiByZXNvbHZlZFBhdGguY2hhckNvZGVBdCgyKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkgewogICAgICAvLyBNYXRjaGVkIGRldmljZSByb290LCBjb252ZXJ0IHRoZSBwYXRoIHRvIGEgbG9uZyBVTkMgcGF0aAogICAgICByZXR1cm4gIlxcXFw/XFwiLmNvbmNhdChyZXNvbHZlZFBhdGgpOwogICAgfQogICAgcmV0dXJuIHBhdGg7CiAgfSwKICBkaXJuYW1lOiBmdW5jdGlvbiBkaXJuYW1lKHBhdGgpIHsKICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7CiAgICB2YXIgbGVuID0gcGF0aC5sZW5ndGg7CiAgICBpZiAobGVuID09PSAwKSB7CiAgICAgIHJldHVybiAnLic7CiAgICB9CiAgICB2YXIgcm9vdEVuZCA9IC0xOwogICAgdmFyIG9mZnNldCA9IDA7CiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTsKICAgIGlmIChsZW4gPT09IDEpIHsKICAgICAgLy8gYHBhdGhgIGNvbnRhaW5zIGp1c3QgYSBwYXRoIHNlcGFyYXRvciwgZXhpdCBlYXJseSB0byBhdm9pZAogICAgICAvLyB1bm5lY2Vzc2FyeSB3b3JrIG9yIGEgZG90LgogICAgICByZXR1cm4gaXNQYXRoU2VwYXJhdG9yKGNvZGUpID8gcGF0aCA6ICcuJzsKICAgIH0KICAgIC8vIFRyeSB0byBtYXRjaCBhIHJvb3QKICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHsKICAgICAgLy8gUG9zc2libGUgVU5DIHJvb3QKICAgICAgcm9vdEVuZCA9IG9mZnNldCA9IDE7CiAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDEpKSkgewogICAgICAgIC8vIE1hdGNoZWQgZG91YmxlIHBhdGggc2VwYXJhdG9yIGF0IGJlZ2lubmluZwogICAgICAgIHZhciBqID0gMjsKICAgICAgICB2YXIgbGFzdCA9IGo7CiAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnMKICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHsKICAgICAgICAgIGorKzsKICAgICAgICB9CiAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkgewogICAgICAgICAgLy8gTWF0Y2hlZCEKICAgICAgICAgIGxhc3QgPSBqOwogICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIHBhdGggc2VwYXJhdG9ycwogICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHsKICAgICAgICAgICAgaisrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkgewogICAgICAgICAgICAvLyBNYXRjaGVkIQogICAgICAgICAgICBsYXN0ID0gajsKICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnMKICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7CiAgICAgICAgICAgICAgaisrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChqID09PSBsZW4pIHsKICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3Qgb25seQogICAgICAgICAgICAgIHJldHVybiBwYXRoOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChqICE9PSBsYXN0KSB7CiAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290IHdpdGggbGVmdG92ZXJzCiAgICAgICAgICAgICAgLy8gT2Zmc2V0IGJ5IDEgdG8gaW5jbHVkZSB0aGUgc2VwYXJhdG9yIGFmdGVyIHRoZSBVTkMgcm9vdCB0bwogICAgICAgICAgICAgIC8vIHRyZWF0IGl0IGFzIGEgIm5vcm1hbCByb290IiBvbiB0b3Agb2YgYSAoVU5DKSByb290CiAgICAgICAgICAgICAgcm9vdEVuZCA9IG9mZnNldCA9IGogKyAxOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIC8vIFBvc3NpYmxlIGRldmljZSByb290CiAgICB9IGVsc2UgaWYgKGlzV2luZG93c0RldmljZVJvb3QoY29kZSkgJiYgcGF0aC5jaGFyQ29kZUF0KDEpID09PSBDSEFSX0NPTE9OKSB7CiAgICAgIHJvb3RFbmQgPSBsZW4gPiAyICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMikpID8gMyA6IDI7CiAgICAgIG9mZnNldCA9IHJvb3RFbmQ7CiAgICB9CiAgICB2YXIgZW5kID0gLTE7CiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTsKICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IG9mZnNldDsgLS1pKSB7CiAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGkpKSkgewogICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7CiAgICAgICAgICBlbmQgPSBpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yCiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7CiAgICAgIH0KICAgIH0KICAgIGlmIChlbmQgPT09IC0xKSB7CiAgICAgIGlmIChyb290RW5kID09PSAtMSkgewogICAgICAgIHJldHVybiAnLic7CiAgICAgIH0KICAgICAgZW5kID0gcm9vdEVuZDsKICAgIH0KICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7CiAgfSwKICBiYXNlbmFtZTogZnVuY3Rpb24gYmFzZW5hbWUocGF0aCwgZXh0KSB7CiAgICBpZiAoZXh0ICE9PSB1bmRlZmluZWQpIHsKICAgICAgdmFsaWRhdGVTdHJpbmcoZXh0LCAnZXh0Jyk7CiAgICB9CiAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpOwogICAgdmFyIHN0YXJ0ID0gMDsKICAgIHZhciBlbmQgPSAtMTsKICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlOwogICAgdmFyIGk7CiAgICAvLyBDaGVjayBmb3IgYSBkcml2ZSBsZXR0ZXIgcHJlZml4IHNvIGFzIG5vdCB0byBtaXN0YWtlIHRoZSBmb2xsb3dpbmcKICAgIC8vIHBhdGggc2VwYXJhdG9yIGFzIGFuIGV4dHJhIHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoIHRoYXQgY2FuIGJlCiAgICAvLyBkaXNyZWdhcmRlZAogICAgaWYgKHBhdGgubGVuZ3RoID49IDIgJiYgaXNXaW5kb3dzRGV2aWNlUm9vdChwYXRoLmNoYXJDb2RlQXQoMCkpICYmIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTikgewogICAgICBzdGFydCA9IDI7CiAgICB9CiAgICBpZiAoZXh0ICE9PSB1bmRlZmluZWQgJiYgZXh0Lmxlbmd0aCA+IDAgJiYgZXh0Lmxlbmd0aCA8PSBwYXRoLmxlbmd0aCkgewogICAgICBpZiAoZXh0ID09PSBwYXRoKSB7CiAgICAgICAgcmV0dXJuICcnOwogICAgICB9CiAgICAgIHZhciBleHRJZHggPSBleHQubGVuZ3RoIC0gMTsKICAgICAgdmFyIGZpcnN0Tm9uU2xhc2hFbmQgPSAtMTsKICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IHN0YXJ0OyAtLWkpIHsKICAgICAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTsKICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7CiAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aAogICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93CiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkgewogICAgICAgICAgICBzdGFydCA9IGkgKyAxOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKGZpcnN0Tm9uU2xhc2hFbmQgPT09IC0xKSB7CiAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCByZW1lbWJlciB0aGlzIGluZGV4IGluIGNhc2UKICAgICAgICAgICAgLy8gd2UgbmVlZCBpdCBpZiB0aGUgZXh0ZW5zaW9uIGVuZHMgdXAgbm90IG1hdGNoaW5nCiAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlOwogICAgICAgICAgICBmaXJzdE5vblNsYXNoRW5kID0gaSArIDE7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZXh0SWR4ID49IDApIHsKICAgICAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIHRoZSBleHBsaWNpdCBleHRlbnNpb24KICAgICAgICAgICAgaWYgKGNvZGUgPT09IGV4dC5jaGFyQ29kZUF0KGV4dElkeCkpIHsKICAgICAgICAgICAgICBpZiAoLS1leHRJZHggPT09IC0xKSB7CiAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBleHRlbnNpb24sIHNvIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91ciBwYXRoCiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQKICAgICAgICAgICAgICAgIGVuZCA9IGk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIC8vIEV4dGVuc2lvbiBkb2VzIG5vdCBtYXRjaCwgc28gb3VyIHJlc3VsdCBpcyB0aGUgZW50aXJlIHBhdGgKICAgICAgICAgICAgICAvLyBjb21wb25lbnQKICAgICAgICAgICAgICBleHRJZHggPSAtMTsKICAgICAgICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7CiAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDsKICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xKSB7CiAgICAgICAgZW5kID0gcGF0aC5sZW5ndGg7CiAgICAgIH0KICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7CiAgICB9CiAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gc3RhcnQ7IC0taSkgewogICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChpKSkpIHsKICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aAogICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vdwogICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7CiAgICAgICAgICBzdGFydCA9IGkgKyAxOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHsKICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyCiAgICAgICAgLy8gcGF0aCBjb21wb25lbnQKICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTsKICAgICAgICBlbmQgPSBpICsgMTsKICAgICAgfQogICAgfQogICAgaWYgKGVuZCA9PT0gLTEpIHsKICAgICAgcmV0dXJuICcnOwogICAgfQogICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7CiAgfSwKICBleHRuYW1lOiBmdW5jdGlvbiBleHRuYW1lKHBhdGgpIHsKICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7CiAgICB2YXIgc3RhcnQgPSAwOwogICAgdmFyIHN0YXJ0RG90ID0gLTE7CiAgICB2YXIgc3RhcnRQYXJ0ID0gMDsKICAgIHZhciBlbmQgPSAtMTsKICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlOwogICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZAogICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmQKICAgIHZhciBwcmVEb3RTdGF0ZSA9IDA7CiAgICAvLyBDaGVjayBmb3IgYSBkcml2ZSBsZXR0ZXIgcHJlZml4IHNvIGFzIG5vdCB0byBtaXN0YWtlIHRoZSBmb2xsb3dpbmcKICAgIC8vIHBhdGggc2VwYXJhdG9yIGFzIGFuIGV4dHJhIHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoIHRoYXQgY2FuIGJlCiAgICAvLyBkaXNyZWdhcmRlZAogICAgaWYgKHBhdGgubGVuZ3RoID49IDIgJiYgcGF0aC5jaGFyQ29kZUF0KDEpID09PSBDSEFSX0NPTE9OICYmIGlzV2luZG93c0RldmljZVJvb3QocGF0aC5jaGFyQ29kZUF0KDApKSkgewogICAgICBzdGFydCA9IHN0YXJ0UGFydCA9IDI7CiAgICB9CiAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IHN0YXJ0OyAtLWkpIHsKICAgICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7CiAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHsKICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aAogICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vdwogICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7CiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICBpZiAoZW5kID09PSAtMSkgewogICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXIKICAgICAgICAvLyBleHRlbnNpb24KICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTsKICAgICAgICBlbmQgPSBpICsgMTsKICAgICAgfQogICAgICBpZiAoY29kZSA9PT0gQ0hBUl9ET1QpIHsKICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb24KICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKSB7CiAgICAgICAgICBzdGFydERvdCA9IGk7CiAgICAgICAgfSBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkgewogICAgICAgICAgcHJlRG90U3RhdGUgPSAxOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHsKICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZAogICAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uCiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTsKICAgICAgfQogICAgfQogICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8CiAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdAogICAgcHJlRG90U3RhdGUgPT09IDAgfHwKICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLicKICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7CiAgICAgIHJldHVybiAnJzsKICAgIH0KICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpOwogIH0sCiAgZm9ybWF0OiBfZm9ybWF0LmJpbmQobnVsbCwgJ1xcJyksCiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHBhdGgpIHsKICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7CiAgICB2YXIgcmV0ID0gewogICAgICByb290OiAnJywKICAgICAgZGlyOiAnJywKICAgICAgYmFzZTogJycsCiAgICAgIGV4dDogJycsCiAgICAgIG5hbWU6ICcnCiAgICB9OwogICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiByZXQ7CiAgICB9CiAgICB2YXIgbGVuID0gcGF0aC5sZW5ndGg7CiAgICB2YXIgcm9vdEVuZCA9IDA7CiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTsKICAgIGlmIChsZW4gPT09IDEpIHsKICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkgewogICAgICAgIC8vIGBwYXRoYCBjb250YWlucyBqdXN0IGEgcGF0aCBzZXBhcmF0b3IsIGV4aXQgZWFybHkgdG8gYXZvaWQKICAgICAgICAvLyB1bm5lY2Vzc2FyeSB3b3JrCiAgICAgICAgcmV0LnJvb3QgPSByZXQuZGlyID0gcGF0aDsKICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoOwogICAgICByZXR1cm4gcmV0OwogICAgfQogICAgLy8gVHJ5IHRvIG1hdGNoIGEgcm9vdAogICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkgewogICAgICAvLyBQb3NzaWJsZSBVTkMgcm9vdAogICAgICByb290RW5kID0gMTsKICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMSkpKSB7CiAgICAgICAgLy8gTWF0Y2hlZCBkb3VibGUgcGF0aCBzZXBhcmF0b3IgYXQgYmVnaW5uaW5nCiAgICAgICAgdmFyIGogPSAyOwogICAgICAgIHZhciBsYXN0ID0gajsKICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9ycwogICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkgewogICAgICAgICAgaisrOwogICAgICAgIH0KICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7CiAgICAgICAgICAvLyBNYXRjaGVkIQogICAgICAgICAgbGFzdCA9IGo7CiAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgcGF0aCBzZXBhcmF0b3JzCiAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkgewogICAgICAgICAgICBqKys7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7CiAgICAgICAgICAgIC8vIE1hdGNoZWQhCiAgICAgICAgICAgIGxhc3QgPSBqOwogICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9ycwogICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHsKICAgICAgICAgICAgICBqKys7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGogPT09IGxlbikgewogICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCBvbmx5CiAgICAgICAgICAgICAgcm9vdEVuZCA9IGo7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoaiAhPT0gbGFzdCkgewogICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCB3aXRoIGxlZnRvdmVycwogICAgICAgICAgICAgIHJvb3RFbmQgPSBqICsgMTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfSBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VSb290KGNvZGUpICYmIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTikgewogICAgICAvLyBQb3NzaWJsZSBkZXZpY2Ugcm9vdAogICAgICBpZiAobGVuIDw9IDIpIHsKICAgICAgICAvLyBgcGF0aGAgY29udGFpbnMganVzdCBhIGRyaXZlIHJvb3QsIGV4aXQgZWFybHkgdG8gYXZvaWQKICAgICAgICAvLyB1bm5lY2Vzc2FyeSB3b3JrCiAgICAgICAgcmV0LnJvb3QgPSByZXQuZGlyID0gcGF0aDsKICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIHJvb3RFbmQgPSAyOwogICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgyKSkpIHsKICAgICAgICBpZiAobGVuID09PSAzKSB7CiAgICAgICAgICAvLyBgcGF0aGAgY29udGFpbnMganVzdCBhIGRyaXZlIHJvb3QsIGV4aXQgZWFybHkgdG8gYXZvaWQKICAgICAgICAgIC8vIHVubmVjZXNzYXJ5IHdvcmsKICAgICAgICAgIHJldC5yb290ID0gcmV0LmRpciA9IHBhdGg7CiAgICAgICAgICByZXR1cm4gcmV0OwogICAgICAgIH0KICAgICAgICByb290RW5kID0gMzsKICAgICAgfQogICAgfQogICAgaWYgKHJvb3RFbmQgPiAwKSB7CiAgICAgIHJldC5yb290ID0gcGF0aC5zbGljZSgwLCByb290RW5kKTsKICAgIH0KICAgIHZhciBzdGFydERvdCA9IC0xOwogICAgdmFyIHN0YXJ0UGFydCA9IHJvb3RFbmQ7CiAgICB2YXIgZW5kID0gLTE7CiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTsKICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxOwogICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZAogICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmQKICAgIHZhciBwcmVEb3RTdGF0ZSA9IDA7CiAgICAvLyBHZXQgbm9uLWRpciBpbmZvCiAgICBmb3IgKDsgaSA+PSByb290RW5kOyAtLWkpIHsKICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTsKICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkgewogICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoCiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93CiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHsKICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIGNvbnRpbnVlOwogICAgICB9CiAgICAgIGlmIChlbmQgPT09IC0xKSB7CiAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91cgogICAgICAgIC8vIGV4dGVuc2lvbgogICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlOwogICAgICAgIGVuZCA9IGkgKyAxOwogICAgICB9CiAgICAgIGlmIChjb2RlID09PSBDSEFSX0RPVCkgewogICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvbgogICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHsKICAgICAgICAgIHN0YXJ0RG90ID0gaTsKICAgICAgICB9IGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKSB7CiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkgewogICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkCiAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb24KICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xOwogICAgICB9CiAgICB9CiAgICBpZiAoZW5kICE9PSAtMSkgewogICAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8CiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90CiAgICAgIHByZURvdFN0YXRlID09PSAwIHx8CiAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLicKICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHsKICAgICAgICByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydFBhcnQsIGVuZCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgc3RhcnREb3QpOwogICAgICAgIHJldC5iYXNlID0gcGF0aC5zbGljZShzdGFydFBhcnQsIGVuZCk7CiAgICAgICAgcmV0LmV4dCA9IHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7CiAgICAgIH0KICAgIH0KICAgIC8vIElmIHRoZSBkaXJlY3RvcnkgaXMgdGhlIHJvb3QsIHVzZSB0aGUgZW50aXJlIHJvb3QgYXMgdGhlIGBkaXJgIGluY2x1ZGluZwogICAgLy8gdGhlIHRyYWlsaW5nIHNsYXNoIGlmIGFueSAoYEM6XGFiY2AgLT4gYEM6XGApLiBPdGhlcndpc2UsIHN0cmlwIG91dCB0aGUKICAgIC8vIHRyYWlsaW5nIHNsYXNoIChgQzpcYWJjXGRlZmAgLT4gYEM6XGFiY2ApLgogICAgaWYgKHN0YXJ0UGFydCA+IDAgJiYgc3RhcnRQYXJ0ICE9PSByb290RW5kKSB7CiAgICAgIHJldC5kaXIgPSBwYXRoLnNsaWNlKDAsIHN0YXJ0UGFydCAtIDEpOwogICAgfSBlbHNlIHsKICAgICAgcmV0LmRpciA9IHJldC5yb290OwogICAgfQogICAgcmV0dXJuIHJldDsKICB9LAogIHNlcDogJ1xcJywKICBkZWxpbWl0ZXI6ICc7JywKICB3aW4zMjogbnVsbCwKICBwb3NpeDogbnVsbAp9OwpleHBvcnQgdmFyIHBvc2l4ID0gewogIC8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bykKICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKCkgewogICAgdmFyIHJlc29sdmVkUGF0aCA9ICcnOwogICAgdmFyIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTsKICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7CiAgICAgIHZhciBwYXRoID0gaSA+PSAwID8gaSA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTsKICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTsKICAgICAgLy8gU2tpcCBlbXB0eSBlbnRyaWVzCiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgewogICAgICAgIGNvbnRpbnVlOwogICAgICB9CiAgICAgIHJlc29sdmVkUGF0aCA9ICIiLmNvbmNhdChwYXRoLCAiLyIpLmNvbmNhdChyZXNvbHZlZFBhdGgpOwogICAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSBDSEFSX0ZPUldBUkRfU0xBU0g7CiAgICB9CiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0CiAgICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscykKICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aAogICAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplU3RyaW5nKHJlc29sdmVkUGF0aCwgIXJlc29sdmVkQWJzb2x1dGUsICcvJywgaXNQb3NpeFBhdGhTZXBhcmF0b3IpOwogICAgaWYgKHJlc29sdmVkQWJzb2x1dGUpIHsKICAgICAgcmV0dXJuICIvIi5jb25jYXQocmVzb2x2ZWRQYXRoKTsKICAgIH0KICAgIHJldHVybiByZXNvbHZlZFBhdGgubGVuZ3RoID4gMCA/IHJlc29sdmVkUGF0aCA6ICcuJzsKICB9LAogIG5vcm1hbGl6ZTogZnVuY3Rpb24gbm9ybWFsaXplKHBhdGgpIHsKICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7CiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHsKICAgICAgcmV0dXJuICcuJzsKICAgIH0KICAgIHZhciBpc0Fic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSBDSEFSX0ZPUldBUkRfU0xBU0g7CiAgICB2YXIgdHJhaWxpbmdTZXBhcmF0b3IgPSBwYXRoLmNoYXJDb2RlQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIOwogICAgLy8gTm9ybWFsaXplIHRoZSBwYXRoCiAgICBwYXRoID0gbm9ybWFsaXplU3RyaW5nKHBhdGgsICFpc0Fic29sdXRlLCAnLycsIGlzUG9zaXhQYXRoU2VwYXJhdG9yKTsKICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgewogICAgICBpZiAoaXNBYnNvbHV0ZSkgewogICAgICAgIHJldHVybiAnLyc7CiAgICAgIH0KICAgICAgcmV0dXJuIHRyYWlsaW5nU2VwYXJhdG9yID8gJy4vJyA6ICcuJzsKICAgIH0KICAgIGlmICh0cmFpbGluZ1NlcGFyYXRvcikgewogICAgICBwYXRoICs9ICcvJzsKICAgIH0KICAgIHJldHVybiBpc0Fic29sdXRlID8gIi8iLmNvbmNhdChwYXRoKSA6IHBhdGg7CiAgfSwKICBpc0Fic29sdXRlOiBmdW5jdGlvbiBpc0Fic29sdXRlKHBhdGgpIHsKICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7CiAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAwICYmIHBhdGguY2hhckNvZGVBdCgwKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIOwogIH0sCiAgam9pbjogZnVuY3Rpb24gam9pbigpIHsKICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiAnLic7CiAgICB9CiAgICB2YXIgam9pbmVkOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHsKICAgICAgdmFyIGFyZyA9IGkgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gaSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpXTsKICAgICAgdmFsaWRhdGVTdHJpbmcoYXJnLCAncGF0aCcpOwogICAgICBpZiAoYXJnLmxlbmd0aCA+IDApIHsKICAgICAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgIGpvaW5lZCA9IGFyZzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgam9pbmVkICs9ICIvIi5jb25jYXQoYXJnKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZCkgewogICAgICByZXR1cm4gJy4nOwogICAgfQogICAgcmV0dXJuIHBvc2l4Lm5vcm1hbGl6ZShqb2luZWQpOwogIH0sCiAgcmVsYXRpdmU6IGZ1bmN0aW9uIHJlbGF0aXZlKGZyb20sIHRvKSB7CiAgICB2YWxpZGF0ZVN0cmluZyhmcm9tLCAnZnJvbScpOwogICAgdmFsaWRhdGVTdHJpbmcodG8sICd0bycpOwogICAgaWYgKGZyb20gPT09IHRvKSB7CiAgICAgIHJldHVybiAnJzsKICAgIH0KICAgIC8vIFRyaW0gbGVhZGluZyBmb3J3YXJkIHNsYXNoZXMuCiAgICBmcm9tID0gcG9zaXgucmVzb2x2ZShmcm9tKTsKICAgIHRvID0gcG9zaXgucmVzb2x2ZSh0byk7CiAgICBpZiAoZnJvbSA9PT0gdG8pIHsKICAgICAgcmV0dXJuICcnOwogICAgfQogICAgdmFyIGZyb21TdGFydCA9IDE7CiAgICB2YXIgZnJvbUVuZCA9IGZyb20ubGVuZ3RoOwogICAgdmFyIGZyb21MZW4gPSBmcm9tRW5kIC0gZnJvbVN0YXJ0OwogICAgdmFyIHRvU3RhcnQgPSAxOwogICAgdmFyIHRvTGVuID0gdG8ubGVuZ3RoIC0gdG9TdGFydDsKICAgIC8vIENvbXBhcmUgcGF0aHMgdG8gZmluZCB0aGUgbG9uZ2VzdCBjb21tb24gcGF0aCBmcm9tIHJvb3QKICAgIHZhciBsZW5ndGggPSBmcm9tTGVuIDwgdG9MZW4gPyBmcm9tTGVuIDogdG9MZW47CiAgICB2YXIgbGFzdENvbW1vblNlcCA9IC0xOwogICAgdmFyIGkgPSAwOwogICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICB2YXIgZnJvbUNvZGUgPSBmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0ICsgaSk7CiAgICAgIGlmIChmcm9tQ29kZSAhPT0gdG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSkpIHsKICAgICAgICBicmVhazsKICAgICAgfSBlbHNlIGlmIChmcm9tQ29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7CiAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7CiAgICAgIH0KICAgIH0KICAgIGlmIChpID09PSBsZW5ndGgpIHsKICAgICAgaWYgKHRvTGVuID4gbGVuZ3RoKSB7CiAgICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHsKICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGBmcm9tYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgdG9gLgogICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28vYmFyJzsgdG89Jy9mb28vYmFyL2JheicKICAgICAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0ICsgaSArIDEpOwogICAgICAgIH0KICAgICAgICBpZiAoaSA9PT0gMCkgewogICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYGZyb21gIGlzIHRoZSByb290CiAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nLyc7IHRvPScvZm9vJwogICAgICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQgKyBpKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAoZnJvbUxlbiA+IGxlbmd0aCkgewogICAgICAgIGlmIChmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0ICsgaSkgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkgewogICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgZnJvbWAuCiAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvby9iYXIvYmF6JzsgdG89Jy9mb28vYmFyJwogICAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7CiAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7CiAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSByb290LgogICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28vYmFyJzsgdG89Jy8nCiAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gMDsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIHZhciBvdXQgPSAnJzsKICAgIC8vIEdlbmVyYXRlIHRoZSByZWxhdGl2ZSBwYXRoIGJhc2VkIG9uIHRoZSBwYXRoIGRpZmZlcmVuY2UgYmV0d2VlbiBgdG9gCiAgICAvLyBhbmQgYGZyb21gLgogICAgZm9yIChpID0gZnJvbVN0YXJ0ICsgbGFzdENvbW1vblNlcCArIDE7IGkgPD0gZnJvbUVuZDsgKytpKSB7CiAgICAgIGlmIChpID09PSBmcm9tRW5kIHx8IGZyb20uY2hhckNvZGVBdChpKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7CiAgICAgICAgb3V0ICs9IG91dC5sZW5ndGggPT09IDAgPyAnLi4nIDogJy8uLic7CiAgICAgIH0KICAgIH0KICAgIC8vIExhc3RseSwgYXBwZW5kIHRoZSByZXN0IG9mIHRoZSBkZXN0aW5hdGlvbiAoYHRvYCkgcGF0aCB0aGF0IGNvbWVzIGFmdGVyCiAgICAvLyB0aGUgY29tbW9uIHBhdGggcGFydHMuCiAgICByZXR1cm4gIiIuY29uY2F0KG91dCkuY29uY2F0KHRvLnNsaWNlKHRvU3RhcnQgKyBsYXN0Q29tbW9uU2VwKSk7CiAgfSwKICB0b05hbWVzcGFjZWRQYXRoOiBmdW5jdGlvbiB0b05hbWVzcGFjZWRQYXRoKHBhdGgpIHsKICAgIC8vIE5vbi1vcCBvbiBwb3NpeCBzeXN0ZW1zCiAgICByZXR1cm4gcGF0aDsKICB9LAogIGRpcm5hbWU6IGZ1bmN0aW9uIGRpcm5hbWUocGF0aCkgewogICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTsKICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgewogICAgICByZXR1cm4gJy4nOwogICAgfQogICAgdmFyIGhhc1Jvb3QgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDsKICAgIHZhciBlbmQgPSAtMTsKICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlOwogICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHsKICAgICAgaWYgKHBhdGguY2hhckNvZGVBdChpKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7CiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHsKICAgICAgICAgIGVuZCA9IGk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IKICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTsKICAgICAgfQogICAgfQogICAgaWYgKGVuZCA9PT0gLTEpIHsKICAgICAgcmV0dXJuIGhhc1Jvb3QgPyAnLycgOiAnLic7CiAgICB9CiAgICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHsKICAgICAgcmV0dXJuICcvLyc7CiAgICB9CiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpOwogIH0sCiAgYmFzZW5hbWU6IGZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgsIGV4dCkgewogICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkKSB7CiAgICAgIHZhbGlkYXRlU3RyaW5nKGV4dCwgJ2V4dCcpOwogICAgfQogICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTsKICAgIHZhciBzdGFydCA9IDA7CiAgICB2YXIgZW5kID0gLTE7CiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTsKICAgIHZhciBpOwogICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkICYmIGV4dC5sZW5ndGggPiAwICYmIGV4dC5sZW5ndGggPD0gcGF0aC5sZW5ndGgpIHsKICAgICAgaWYgKGV4dCA9PT0gcGF0aCkgewogICAgICAgIHJldHVybiAnJzsKICAgICAgfQogICAgICB2YXIgZXh0SWR4ID0gZXh0Lmxlbmd0aCAtIDE7CiAgICAgIHZhciBmaXJzdE5vblNsYXNoRW5kID0gLTE7CiAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsKICAgICAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTsKICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7CiAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aAogICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93CiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkgewogICAgICAgICAgICBzdGFydCA9IGkgKyAxOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKGZpcnN0Tm9uU2xhc2hFbmQgPT09IC0xKSB7CiAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCByZW1lbWJlciB0aGlzIGluZGV4IGluIGNhc2UKICAgICAgICAgICAgLy8gd2UgbmVlZCBpdCBpZiB0aGUgZXh0ZW5zaW9uIGVuZHMgdXAgbm90IG1hdGNoaW5nCiAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlOwogICAgICAgICAgICBmaXJzdE5vblNsYXNoRW5kID0gaSArIDE7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZXh0SWR4ID49IDApIHsKICAgICAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIHRoZSBleHBsaWNpdCBleHRlbnNpb24KICAgICAgICAgICAgaWYgKGNvZGUgPT09IGV4dC5jaGFyQ29kZUF0KGV4dElkeCkpIHsKICAgICAgICAgICAgICBpZiAoLS1leHRJZHggPT09IC0xKSB7CiAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBleHRlbnNpb24sIHNvIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91ciBwYXRoCiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQKICAgICAgICAgICAgICAgIGVuZCA9IGk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIC8vIEV4dGVuc2lvbiBkb2VzIG5vdCBtYXRjaCwgc28gb3VyIHJlc3VsdCBpcyB0aGUgZW50aXJlIHBhdGgKICAgICAgICAgICAgICAvLyBjb21wb25lbnQKICAgICAgICAgICAgICBleHRJZHggPSAtMTsKICAgICAgICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7CiAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDsKICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xKSB7CiAgICAgICAgZW5kID0gcGF0aC5sZW5ndGg7CiAgICAgIH0KICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7CiAgICB9CiAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7CiAgICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkgewogICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoCiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93CiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHsKICAgICAgICAgIHN0YXJ0ID0gaSArIDE7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkgewogICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXIKICAgICAgICAvLyBwYXRoIGNvbXBvbmVudAogICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlOwogICAgICAgIGVuZCA9IGkgKyAxOwogICAgICB9CiAgICB9CiAgICBpZiAoZW5kID09PSAtMSkgewogICAgICByZXR1cm4gJyc7CiAgICB9CiAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTsKICB9LAogIGV4dG5hbWU6IGZ1bmN0aW9uIGV4dG5hbWUocGF0aCkgewogICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTsKICAgIHZhciBzdGFydERvdCA9IC0xOwogICAgdmFyIHN0YXJ0UGFydCA9IDA7CiAgICB2YXIgZW5kID0gLTE7CiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTsKICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmQKICAgIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kCiAgICB2YXIgcHJlRG90U3RhdGUgPSAwOwogICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsKICAgICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7CiAgICAgIGlmIChjb2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHsKICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aAogICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vdwogICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7CiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICBpZiAoZW5kID09PSAtMSkgewogICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXIKICAgICAgICAvLyBleHRlbnNpb24KICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTsKICAgICAgICBlbmQgPSBpICsgMTsKICAgICAgfQogICAgICBpZiAoY29kZSA9PT0gQ0hBUl9ET1QpIHsKICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb24KICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKSB7CiAgICAgICAgICBzdGFydERvdCA9IGk7CiAgICAgICAgfSBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkgewogICAgICAgICAgcHJlRG90U3RhdGUgPSAxOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHsKICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZAogICAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uCiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTsKICAgICAgfQogICAgfQogICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8CiAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdAogICAgcHJlRG90U3RhdGUgPT09IDAgfHwKICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLicKICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7CiAgICAgIHJldHVybiAnJzsKICAgIH0KICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpOwogIH0sCiAgZm9ybWF0OiBfZm9ybWF0LmJpbmQobnVsbCwgJy8nKSwKICBwYXJzZTogZnVuY3Rpb24gcGFyc2UocGF0aCkgewogICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTsKICAgIHZhciByZXQgPSB7CiAgICAgIHJvb3Q6ICcnLAogICAgICBkaXI6ICcnLAogICAgICBiYXNlOiAnJywKICAgICAgZXh0OiAnJywKICAgICAgbmFtZTogJycKICAgIH07CiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHsKICAgICAgcmV0dXJuIHJldDsKICAgIH0KICAgIHZhciBpc0Fic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSBDSEFSX0ZPUldBUkRfU0xBU0g7CiAgICB2YXIgc3RhcnQ7CiAgICBpZiAoaXNBYnNvbHV0ZSkgewogICAgICByZXQucm9vdCA9ICcvJzsKICAgICAgc3RhcnQgPSAxOwogICAgfSBlbHNlIHsKICAgICAgc3RhcnQgPSAwOwogICAgfQogICAgdmFyIHN0YXJ0RG90ID0gLTE7CiAgICB2YXIgc3RhcnRQYXJ0ID0gMDsKICAgIHZhciBlbmQgPSAtMTsKICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlOwogICAgdmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7CiAgICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kCiAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZAogICAgdmFyIHByZURvdFN0YXRlID0gMDsKICAgIC8vIEdldCBub24tZGlyIGluZm8KICAgIGZvciAoOyBpID49IHN0YXJ0OyAtLWkpIHsKICAgICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7CiAgICAgIGlmIChjb2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHsKICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aAogICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vdwogICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7CiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICBpZiAoZW5kID09PSAtMSkgewogICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXIKICAgICAgICAvLyBleHRlbnNpb24KICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTsKICAgICAgICBlbmQgPSBpICsgMTsKICAgICAgfQogICAgICBpZiAoY29kZSA9PT0gQ0hBUl9ET1QpIHsKICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb24KICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKSB7CiAgICAgICAgICBzdGFydERvdCA9IGk7CiAgICAgICAgfSBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkgewogICAgICAgICAgcHJlRG90U3RhdGUgPSAxOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHsKICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZAogICAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uCiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTsKICAgICAgfQogICAgfQogICAgaWYgKGVuZCAhPT0gLTEpIHsKICAgICAgdmFyIF9zdGFydCA9IHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlID8gMSA6IHN0YXJ0UGFydDsKICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fAogICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdAogICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fAogICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nCiAgICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7CiAgICAgICAgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGguc2xpY2UoX3N0YXJ0LCBlbmQpOwogICAgICB9IGVsc2UgewogICAgICAgIHJldC5uYW1lID0gcGF0aC5zbGljZShfc3RhcnQsIHN0YXJ0RG90KTsKICAgICAgICByZXQuYmFzZSA9IHBhdGguc2xpY2UoX3N0YXJ0LCBlbmQpOwogICAgICAgIHJldC5leHQgPSBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpOwogICAgICB9CiAgICB9CiAgICBpZiAoc3RhcnRQYXJ0ID4gMCkgewogICAgICByZXQuZGlyID0gcGF0aC5zbGljZSgwLCBzdGFydFBhcnQgLSAxKTsKICAgIH0gZWxzZSBpZiAoaXNBYnNvbHV0ZSkgewogICAgICByZXQuZGlyID0gJy8nOwogICAgfQogICAgcmV0dXJuIHJldDsKICB9LAogIHNlcDogJy8nLAogIGRlbGltaXRlcjogJzonLAogIHdpbjMyOiBudWxsLAogIHBvc2l4OiBudWxsCn07CnBvc2l4LndpbjMyID0gd2luMzIud2luMzIgPSB3aW4zMjsKcG9zaXgucG9zaXggPSB3aW4zMi5wb3NpeCA9IHBvc2l4OwpleHBvcnQgdmFyIG5vcm1hbGl6ZSA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMi5ub3JtYWxpemUgOiBwb3NpeC5ub3JtYWxpemU7CmV4cG9ydCB2YXIgcmVzb2x2ZSA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMi5yZXNvbHZlIDogcG9zaXgucmVzb2x2ZTsKZXhwb3J0IHZhciByZWxhdGl2ZSA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMi5yZWxhdGl2ZSA6IHBvc2l4LnJlbGF0aXZlOwpleHBvcnQgdmFyIGRpcm5hbWUgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gd2luMzIuZGlybmFtZSA6IHBvc2l4LmRpcm5hbWU7CmV4cG9ydCB2YXIgYmFzZW5hbWUgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gd2luMzIuYmFzZW5hbWUgOiBwb3NpeC5iYXNlbmFtZTsKZXhwb3J0IHZhciBleHRuYW1lID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyLmV4dG5hbWUgOiBwb3NpeC5leHRuYW1lOwpleHBvcnQgdmFyIHNlcCA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMi5zZXAgOiBwb3NpeC5zZXA7"},{"version":3,"names":["process","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_DOT","CHAR_FORWARD_SLASH","CHAR_BACKWARD_SLASH","CHAR_COLON","CHAR_QUESTION_MARK","ErrorInvalidArgType","name","expected","actual","determiner","indexOf","replace","type","msg","code","Error","validateString","value","isPathSeparator","isPosixPathSeparator","isWindowsDeviceRoot","normalizeString","path","allowAboveRoot","separator","res","lastSegmentLength","lastSlash","dots","i","length","charCodeAt","lastSlashIndex","lastIndexOf","slice","_format","sep","pathObject","dir","root","base","ext","win32","resolve","resolvedDevice","resolvedTail","resolvedAbsolute","cwd","env","undefined","toLowerCase","len","rootEnd","device","isAbsolute","j","last","firstPart","normalize","tail","join","joined","arg","needsReplace","slashCount","firstLen","relative","from","to","fromOrig","toOrig","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","lastCommonSep","fromCode","out","toNamespacedPath","resolvedPath","dirname","offset","end","matchedSlash","basename","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","bind","parse","ret","delimiter","posix","trailingSeparator","hasRoot","platform"],"sources":["/Users/yanjiajia/Desktop/workspace/avue-data-new/node_modules/monaco-editor/esm/vs/base/common/path.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v14.16.0/lib/path.js\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nimport * as process from './process.js';\nconst CHAR_UPPERCASE_A = 65; /* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\nclass ErrorInvalidArgType extends Error {\n    constructor(name, expected, actual) {\n        // determiner: 'must be' or 'must not be'\n        let determiner;\n        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n            determiner = 'must not be';\n            expected = expected.replace(/^not /, '');\n        }\n        else {\n            determiner = 'must be';\n        }\n        const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n        let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n        msg += `. Received type ${typeof actual}`;\n        super(msg);\n        this.code = 'ERR_INVALID_ARG_TYPE';\n    }\n}\nfunction validateString(value, name) {\n    if (typeof value !== 'string') {\n        throw new ErrorInvalidArgType(name, 'string', value);\n    }\n}\nfunction isPathSeparator(code) {\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\nfunction isPosixPathSeparator(code) {\n    return code === CHAR_FORWARD_SLASH;\n}\nfunction isWindowsDeviceRoot(code) {\n    return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n        (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = 0;\n    for (let i = 0; i <= path.length; ++i) {\n        if (i < path.length) {\n            code = path.charCodeAt(i);\n        }\n        else if (isPathSeparator(code)) {\n            break;\n        }\n        else {\n            code = CHAR_FORWARD_SLASH;\n        }\n        if (isPathSeparator(code)) {\n            if (lastSlash === i - 1 || dots === 1) {\n                // NOOP\n            }\n            else if (dots === 2) {\n                if (res.length < 2 || lastSegmentLength !== 2 ||\n                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n                    if (res.length > 2) {\n                        const lastSlashIndex = res.lastIndexOf(separator);\n                        if (lastSlashIndex === -1) {\n                            res = '';\n                            lastSegmentLength = 0;\n                        }\n                        else {\n                            res = res.slice(0, lastSlashIndex);\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n                        }\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                    else if (res.length !== 0) {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    res += res.length > 0 ? `${separator}..` : '..';\n                    lastSegmentLength = 2;\n                }\n            }\n            else {\n                if (res.length > 0) {\n                    res += `${separator}${path.slice(lastSlash + 1, i)}`;\n                }\n                else {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === CHAR_DOT && dots !== -1) {\n            ++dots;\n        }\n        else {\n            dots = -1;\n        }\n    }\n    return res;\n}\nfunction _format(sep, pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n        throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n    }\n    const dir = pathObject.dir || pathObject.root;\n    const base = pathObject.base ||\n        `${pathObject.name || ''}${pathObject.ext || ''}`;\n    if (!dir) {\n        return base;\n    }\n    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\nexport const win32 = {\n    // path.resolve([from ...], to)\n    resolve(...pathSegments) {\n        let resolvedDevice = '';\n        let resolvedTail = '';\n        let resolvedAbsolute = false;\n        for (let i = pathSegments.length - 1; i >= -1; i--) {\n            let path;\n            if (i >= 0) {\n                path = pathSegments[i];\n                validateString(path, 'path');\n                // Skip empty entries\n                if (path.length === 0) {\n                    continue;\n                }\n            }\n            else if (resolvedDevice.length === 0) {\n                path = process.cwd();\n            }\n            else {\n                // Windows has the concept of drive-specific current working\n                // directories. If we've resolved a drive letter but not yet an\n                // absolute path, get cwd for that drive, or the process cwd if\n                // the drive cwd is not available. We're sure the device is not\n                // a UNC path at this points, because UNC paths are always absolute.\n                path = process.env[`=${resolvedDevice}`] || process.cwd();\n                // Verify that a cwd was found and that it actually points\n                // to our drive. If not, default to the drive's root.\n                if (path === undefined ||\n                    (path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n                        path.charCodeAt(2) === CHAR_BACKWARD_SLASH)) {\n                    path = `${resolvedDevice}\\\\`;\n                }\n            }\n            const len = path.length;\n            let rootEnd = 0;\n            let device = '';\n            let isAbsolute = false;\n            const code = path.charCodeAt(0);\n            // Try to match a root\n            if (len === 1) {\n                if (isPathSeparator(code)) {\n                    // `path` contains just a path separator\n                    rootEnd = 1;\n                    isAbsolute = true;\n                }\n            }\n            else if (isPathSeparator(code)) {\n                // Possible UNC root\n                // If we started with a separator, we know we at least have an\n                // absolute path of some kind (UNC or otherwise)\n                isAbsolute = true;\n                if (isPathSeparator(path.charCodeAt(1))) {\n                    // Matched double path separator at beginning\n                    let j = 2;\n                    let last = j;\n                    // Match 1 or more non-path separators\n                    while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        const firstPart = path.slice(last, j);\n                        // Matched!\n                        last = j;\n                        // Match 1 or more path separators\n                        while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j < len && j !== last) {\n                            // Matched!\n                            last = j;\n                            // Match 1 or more non-path separators\n                            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                                j++;\n                            }\n                            if (j === len || j !== last) {\n                                // We matched a UNC root\n                                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                                rootEnd = j;\n                            }\n                        }\n                    }\n                }\n                else {\n                    rootEnd = 1;\n                }\n            }\n            else if (isWindowsDeviceRoot(code) &&\n                path.charCodeAt(1) === CHAR_COLON) {\n                // Possible device root\n                device = path.slice(0, 2);\n                rootEnd = 2;\n                if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n                    // Treat separator following drive name as an absolute path\n                    // indicator\n                    isAbsolute = true;\n                    rootEnd = 3;\n                }\n            }\n            if (device.length > 0) {\n                if (resolvedDevice.length > 0) {\n                    if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n                        // This path points to another device so it is not applicable\n                        continue;\n                    }\n                }\n                else {\n                    resolvedDevice = device;\n                }\n            }\n            if (resolvedAbsolute) {\n                if (resolvedDevice.length > 0) {\n                    break;\n                }\n            }\n            else {\n                resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n                resolvedAbsolute = isAbsolute;\n                if (isAbsolute && resolvedDevice.length > 0) {\n                    break;\n                }\n            }\n        }\n        // At this point the path should be resolved to a full absolute path,\n        // but handle relative paths to be safe (might happen when process.cwd()\n        // fails)\n        // Normalize the tail path\n        resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\n        return resolvedAbsolute ?\n            `${resolvedDevice}\\\\${resolvedTail}` :\n            `${resolvedDevice}${resolvedTail}` || '.';\n    },\n    normalize(path) {\n        validateString(path, 'path');\n        const len = path.length;\n        if (len === 0) {\n            return '.';\n        }\n        let rootEnd = 0;\n        let device;\n        let isAbsolute = false;\n        const code = path.charCodeAt(0);\n        // Try to match a root\n        if (len === 1) {\n            // `path` contains just a single char, exit early to avoid\n            // unnecessary work\n            return isPosixPathSeparator(code) ? '\\\\' : path;\n        }\n        if (isPathSeparator(code)) {\n            // Possible UNC root\n            // If we started with a separator, we know we at least have an absolute\n            // path of some kind (UNC or otherwise)\n            isAbsolute = true;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                // Matched double path separator at beginning\n                let j = 2;\n                let last = j;\n                // Match 1 or more non-path separators\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                    j++;\n                }\n                if (j < len && j !== last) {\n                    const firstPart = path.slice(last, j);\n                    // Matched!\n                    last = j;\n                    // Match 1 or more path separators\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        // Matched!\n                        last = j;\n                        // Match 1 or more non-path separators\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j === len) {\n                            // We matched a UNC root only\n                            // Return the normalized version of the UNC root since there\n                            // is nothing left to process\n                            return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n                        }\n                        if (j !== last) {\n                            // We matched a UNC root with leftovers\n                            device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                            rootEnd = j;\n                        }\n                    }\n                }\n            }\n            else {\n                rootEnd = 1;\n            }\n        }\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n            // Possible device root\n            device = path.slice(0, 2);\n            rootEnd = 2;\n            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n                // Treat separator following drive name as an absolute path\n                // indicator\n                isAbsolute = true;\n                rootEnd = 3;\n            }\n        }\n        let tail = rootEnd < len ?\n            normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n            '';\n        if (tail.length === 0 && !isAbsolute) {\n            tail = '.';\n        }\n        if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n            tail += '\\\\';\n        }\n        if (device === undefined) {\n            return isAbsolute ? `\\\\${tail}` : tail;\n        }\n        return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n    },\n    isAbsolute(path) {\n        validateString(path, 'path');\n        const len = path.length;\n        if (len === 0) {\n            return false;\n        }\n        const code = path.charCodeAt(0);\n        return isPathSeparator(code) ||\n            // Possible device root\n            (len > 2 &&\n                isWindowsDeviceRoot(code) &&\n                path.charCodeAt(1) === CHAR_COLON &&\n                isPathSeparator(path.charCodeAt(2)));\n    },\n    join(...paths) {\n        if (paths.length === 0) {\n            return '.';\n        }\n        let joined;\n        let firstPart;\n        for (let i = 0; i < paths.length; ++i) {\n            const arg = paths[i];\n            validateString(arg, 'path');\n            if (arg.length > 0) {\n                if (joined === undefined) {\n                    joined = firstPart = arg;\n                }\n                else {\n                    joined += `\\\\${arg}`;\n                }\n            }\n        }\n        if (joined === undefined) {\n            return '.';\n        }\n        // Make sure that the joined path doesn't start with two slashes, because\n        // normalize() will mistake it for a UNC path then.\n        //\n        // This step is skipped when it is very clear that the user actually\n        // intended to point at a UNC path. This is assumed when the first\n        // non-empty string arguments starts with exactly two slashes followed by\n        // at least one more non-slash character.\n        //\n        // Note that for normalize() to treat a path as a UNC path it needs to\n        // have at least 2 components, so we don't filter for that here.\n        // This means that the user can use join to construct UNC paths from\n        // a server name and a share name; for example:\n        //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n        let needsReplace = true;\n        let slashCount = 0;\n        if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n            ++slashCount;\n            const firstLen = firstPart.length;\n            if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n                ++slashCount;\n                if (firstLen > 2) {\n                    if (isPathSeparator(firstPart.charCodeAt(2))) {\n                        ++slashCount;\n                    }\n                    else {\n                        // We matched a UNC path in the first part\n                        needsReplace = false;\n                    }\n                }\n            }\n        }\n        if (needsReplace) {\n            // Find any more consecutive slashes we need to replace\n            while (slashCount < joined.length &&\n                isPathSeparator(joined.charCodeAt(slashCount))) {\n                slashCount++;\n            }\n            // Replace the slashes if needed\n            if (slashCount >= 2) {\n                joined = `\\\\${joined.slice(slashCount)}`;\n            }\n        }\n        return win32.normalize(joined);\n    },\n    // It will solve the relative path from `from` to `to`, for instance:\n    //  from = 'C:\\\\orandea\\\\test\\\\aaa'\n    //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n    // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n    relative(from, to) {\n        validateString(from, 'from');\n        validateString(to, 'to');\n        if (from === to) {\n            return '';\n        }\n        const fromOrig = win32.resolve(from);\n        const toOrig = win32.resolve(to);\n        if (fromOrig === toOrig) {\n            return '';\n        }\n        from = fromOrig.toLowerCase();\n        to = toOrig.toLowerCase();\n        if (from === to) {\n            return '';\n        }\n        // Trim any leading backslashes\n        let fromStart = 0;\n        while (fromStart < from.length &&\n            from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n            fromStart++;\n        }\n        // Trim trailing backslashes (applicable to UNC paths only)\n        let fromEnd = from.length;\n        while (fromEnd - 1 > fromStart &&\n            from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n            fromEnd--;\n        }\n        const fromLen = fromEnd - fromStart;\n        // Trim any leading backslashes\n        let toStart = 0;\n        while (toStart < to.length &&\n            to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n            toStart++;\n        }\n        // Trim trailing backslashes (applicable to UNC paths only)\n        let toEnd = to.length;\n        while (toEnd - 1 > toStart &&\n            to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n            toEnd--;\n        }\n        const toLen = toEnd - toStart;\n        // Compare paths to find the longest common path from root\n        const length = fromLen < toLen ? fromLen : toLen;\n        let lastCommonSep = -1;\n        let i = 0;\n        for (; i < length; i++) {\n            const fromCode = from.charCodeAt(fromStart + i);\n            if (fromCode !== to.charCodeAt(toStart + i)) {\n                break;\n            }\n            else if (fromCode === CHAR_BACKWARD_SLASH) {\n                lastCommonSep = i;\n            }\n        }\n        // We found a mismatch before the first common path separator was seen, so\n        // return the original `to`.\n        if (i !== length) {\n            if (lastCommonSep === -1) {\n                return toOrig;\n            }\n        }\n        else {\n            if (toLen > length) {\n                if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n                    // We get here if `from` is the exact base path for `to`.\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n                    return toOrig.slice(toStart + i + 1);\n                }\n                if (i === 2) {\n                    // We get here if `from` is the device root.\n                    // For example: from='C:\\\\'; to='C:\\\\foo'\n                    return toOrig.slice(toStart + i);\n                }\n            }\n            if (fromLen > length) {\n                if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n                    // We get here if `to` is the exact base path for `from`.\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n                    lastCommonSep = i;\n                }\n                else if (i === 2) {\n                    // We get here if `to` is the device root.\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n                    lastCommonSep = 3;\n                }\n            }\n            if (lastCommonSep === -1) {\n                lastCommonSep = 0;\n            }\n        }\n        let out = '';\n        // Generate the relative path based on the path difference between `to` and\n        // `from`\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n                out += out.length === 0 ? '..' : '\\\\..';\n            }\n        }\n        toStart += lastCommonSep;\n        // Lastly, append the rest of the destination (`to`) path that comes after\n        // the common path parts\n        if (out.length > 0) {\n            return `${out}${toOrig.slice(toStart, toEnd)}`;\n        }\n        if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n            ++toStart;\n        }\n        return toOrig.slice(toStart, toEnd);\n    },\n    toNamespacedPath(path) {\n        // Note: this will *probably* throw somewhere.\n        if (typeof path !== 'string') {\n            return path;\n        }\n        if (path.length === 0) {\n            return '';\n        }\n        const resolvedPath = win32.resolve(path);\n        if (resolvedPath.length <= 2) {\n            return path;\n        }\n        if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n            // Possible UNC root\n            if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n                const code = resolvedPath.charCodeAt(2);\n                if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n                    // Matched non-long UNC root, convert the path to a long UNC path\n                    return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n                }\n            }\n        }\n        else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n            resolvedPath.charCodeAt(1) === CHAR_COLON &&\n            resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n            // Matched device root, convert the path to a long UNC path\n            return `\\\\\\\\?\\\\${resolvedPath}`;\n        }\n        return path;\n    },\n    dirname(path) {\n        validateString(path, 'path');\n        const len = path.length;\n        if (len === 0) {\n            return '.';\n        }\n        let rootEnd = -1;\n        let offset = 0;\n        const code = path.charCodeAt(0);\n        if (len === 1) {\n            // `path` contains just a path separator, exit early to avoid\n            // unnecessary work or a dot.\n            return isPathSeparator(code) ? path : '.';\n        }\n        // Try to match a root\n        if (isPathSeparator(code)) {\n            // Possible UNC root\n            rootEnd = offset = 1;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                // Matched double path separator at beginning\n                let j = 2;\n                let last = j;\n                // Match 1 or more non-path separators\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                    j++;\n                }\n                if (j < len && j !== last) {\n                    // Matched!\n                    last = j;\n                    // Match 1 or more path separators\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        // Matched!\n                        last = j;\n                        // Match 1 or more non-path separators\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j === len) {\n                            // We matched a UNC root only\n                            return path;\n                        }\n                        if (j !== last) {\n                            // We matched a UNC root with leftovers\n                            // Offset by 1 to include the separator after the UNC root to\n                            // treat it as a \"normal root\" on top of a (UNC) root\n                            rootEnd = offset = j + 1;\n                        }\n                    }\n                }\n            }\n            // Possible device root\n        }\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n            rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n            offset = rootEnd;\n        }\n        let end = -1;\n        let matchedSlash = true;\n        for (let i = len - 1; i >= offset; --i) {\n            if (isPathSeparator(path.charCodeAt(i))) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            }\n            else {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n        if (end === -1) {\n            if (rootEnd === -1) {\n                return '.';\n            }\n            end = rootEnd;\n        }\n        return path.slice(0, end);\n    },\n    basename(path, ext) {\n        if (ext !== undefined) {\n            validateString(ext, 'ext');\n        }\n        validateString(path, 'path');\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        // Check for a drive letter prefix so as not to mistake the following\n        // path separator as an extra separator at the end of the path that can be\n        // disregarded\n        if (path.length >= 2 &&\n            isWindowsDeviceRoot(path.charCodeAt(0)) &&\n            path.charCodeAt(1) === CHAR_COLON) {\n            start = 2;\n        }\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext === path) {\n                return '';\n            }\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for (i = path.length - 1; i >= start; --i) {\n                const code = path.charCodeAt(i);\n                if (isPathSeparator(code)) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else {\n                    if (firstNonSlashEnd === -1) {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) {\n                end = firstNonSlashEnd;\n            }\n            else if (end === -1) {\n                end = path.length;\n            }\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= start; --i) {\n            if (isPathSeparator(path.charCodeAt(i))) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) {\n            return '';\n        }\n        return path.slice(start, end);\n    },\n    extname(path) {\n        validateString(path, 'path');\n        let start = 0;\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        // Check for a drive letter prefix so as not to mistake the following\n        // path separator as an extra separator at the end of the path that can be\n        // disregarded\n        if (path.length >= 2 &&\n            path.charCodeAt(1) === CHAR_COLON &&\n            isWindowsDeviceRoot(path.charCodeAt(0))) {\n            start = startPart = 2;\n        }\n        for (let i = path.length - 1; i >= start; --i) {\n            const code = path.charCodeAt(i);\n            if (isPathSeparator(code)) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 ||\n            end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            (preDotState === 1 &&\n                startDot === end - 1 &&\n                startDot === startPart + 1)) {\n            return '';\n        }\n        return path.slice(startDot, end);\n    },\n    format: _format.bind(null, '\\\\'),\n    parse(path) {\n        validateString(path, 'path');\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n        if (path.length === 0) {\n            return ret;\n        }\n        const len = path.length;\n        let rootEnd = 0;\n        let code = path.charCodeAt(0);\n        if (len === 1) {\n            if (isPathSeparator(code)) {\n                // `path` contains just a path separator, exit early to avoid\n                // unnecessary work\n                ret.root = ret.dir = path;\n                return ret;\n            }\n            ret.base = ret.name = path;\n            return ret;\n        }\n        // Try to match a root\n        if (isPathSeparator(code)) {\n            // Possible UNC root\n            rootEnd = 1;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                // Matched double path separator at beginning\n                let j = 2;\n                let last = j;\n                // Match 1 or more non-path separators\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                    j++;\n                }\n                if (j < len && j !== last) {\n                    // Matched!\n                    last = j;\n                    // Match 1 or more path separators\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        // Matched!\n                        last = j;\n                        // Match 1 or more non-path separators\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j === len) {\n                            // We matched a UNC root only\n                            rootEnd = j;\n                        }\n                        else if (j !== last) {\n                            // We matched a UNC root with leftovers\n                            rootEnd = j + 1;\n                        }\n                    }\n                }\n            }\n        }\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n            // Possible device root\n            if (len <= 2) {\n                // `path` contains just a drive root, exit early to avoid\n                // unnecessary work\n                ret.root = ret.dir = path;\n                return ret;\n            }\n            rootEnd = 2;\n            if (isPathSeparator(path.charCodeAt(2))) {\n                if (len === 3) {\n                    // `path` contains just a drive root, exit early to avoid\n                    // unnecessary work\n                    ret.root = ret.dir = path;\n                    return ret;\n                }\n                rootEnd = 3;\n            }\n        }\n        if (rootEnd > 0) {\n            ret.root = path.slice(0, rootEnd);\n        }\n        let startDot = -1;\n        let startPart = rootEnd;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        // Get non-dir info\n        for (; i >= rootEnd; --i) {\n            code = path.charCodeAt(i);\n            if (isPathSeparator(code)) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (end !== -1) {\n            if (startDot === -1 ||\n                // We saw a non-dot character immediately before the dot\n                preDotState === 0 ||\n                // The (right-most) trimmed path component is exactly '..'\n                (preDotState === 1 &&\n                    startDot === end - 1 &&\n                    startDot === startPart + 1)) {\n                ret.base = ret.name = path.slice(startPart, end);\n            }\n            else {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n                ret.ext = path.slice(startDot, end);\n            }\n        }\n        // If the directory is the root, use the entire root as the `dir` including\n        // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n        // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n        if (startPart > 0 && startPart !== rootEnd) {\n            ret.dir = path.slice(0, startPart - 1);\n        }\n        else {\n            ret.dir = ret.root;\n        }\n        return ret;\n    },\n    sep: '\\\\',\n    delimiter: ';',\n    win32: null,\n    posix: null\n};\nexport const posix = {\n    // path.resolve([from ...], to)\n    resolve(...pathSegments) {\n        let resolvedPath = '';\n        let resolvedAbsolute = false;\n        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n            const path = i >= 0 ? pathSegments[i] : process.cwd();\n            validateString(path, 'path');\n            // Skip empty entries\n            if (path.length === 0) {\n                continue;\n            }\n            resolvedPath = `${path}/${resolvedPath}`;\n            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        }\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        // Normalize the path\n        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n        if (resolvedAbsolute) {\n            return `/${resolvedPath}`;\n        }\n        return resolvedPath.length > 0 ? resolvedPath : '.';\n    },\n    normalize(path) {\n        validateString(path, 'path');\n        if (path.length === 0) {\n            return '.';\n        }\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n        // Normalize the path\n        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n        if (path.length === 0) {\n            if (isAbsolute) {\n                return '/';\n            }\n            return trailingSeparator ? './' : '.';\n        }\n        if (trailingSeparator) {\n            path += '/';\n        }\n        return isAbsolute ? `/${path}` : path;\n    },\n    isAbsolute(path) {\n        validateString(path, 'path');\n        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    },\n    join(...paths) {\n        if (paths.length === 0) {\n            return '.';\n        }\n        let joined;\n        for (let i = 0; i < paths.length; ++i) {\n            const arg = paths[i];\n            validateString(arg, 'path');\n            if (arg.length > 0) {\n                if (joined === undefined) {\n                    joined = arg;\n                }\n                else {\n                    joined += `/${arg}`;\n                }\n            }\n        }\n        if (joined === undefined) {\n            return '.';\n        }\n        return posix.normalize(joined);\n    },\n    relative(from, to) {\n        validateString(from, 'from');\n        validateString(to, 'to');\n        if (from === to) {\n            return '';\n        }\n        // Trim leading forward slashes.\n        from = posix.resolve(from);\n        to = posix.resolve(to);\n        if (from === to) {\n            return '';\n        }\n        const fromStart = 1;\n        const fromEnd = from.length;\n        const fromLen = fromEnd - fromStart;\n        const toStart = 1;\n        const toLen = to.length - toStart;\n        // Compare paths to find the longest common path from root\n        const length = (fromLen < toLen ? fromLen : toLen);\n        let lastCommonSep = -1;\n        let i = 0;\n        for (; i < length; i++) {\n            const fromCode = from.charCodeAt(fromStart + i);\n            if (fromCode !== to.charCodeAt(toStart + i)) {\n                break;\n            }\n            else if (fromCode === CHAR_FORWARD_SLASH) {\n                lastCommonSep = i;\n            }\n        }\n        if (i === length) {\n            if (toLen > length) {\n                if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n                    // We get here if `from` is the exact base path for `to`.\n                    // For example: from='/foo/bar'; to='/foo/bar/baz'\n                    return to.slice(toStart + i + 1);\n                }\n                if (i === 0) {\n                    // We get here if `from` is the root\n                    // For example: from='/'; to='/foo'\n                    return to.slice(toStart + i);\n                }\n            }\n            else if (fromLen > length) {\n                if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n                    // We get here if `to` is the exact base path for `from`.\n                    // For example: from='/foo/bar/baz'; to='/foo/bar'\n                    lastCommonSep = i;\n                }\n                else if (i === 0) {\n                    // We get here if `to` is the root.\n                    // For example: from='/foo/bar'; to='/'\n                    lastCommonSep = 0;\n                }\n            }\n        }\n        let out = '';\n        // Generate the relative path based on the path difference between `to`\n        // and `from`.\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                out += out.length === 0 ? '..' : '/..';\n            }\n        }\n        // Lastly, append the rest of the destination (`to`) path that comes after\n        // the common path parts.\n        return `${out}${to.slice(toStart + lastCommonSep)}`;\n    },\n    toNamespacedPath(path) {\n        // Non-op on posix systems\n        return path;\n    },\n    dirname(path) {\n        validateString(path, 'path');\n        if (path.length === 0) {\n            return '.';\n        }\n        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        let end = -1;\n        let matchedSlash = true;\n        for (let i = path.length - 1; i >= 1; --i) {\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            }\n            else {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n        if (end === -1) {\n            return hasRoot ? '/' : '.';\n        }\n        if (hasRoot && end === 1) {\n            return '//';\n        }\n        return path.slice(0, end);\n    },\n    basename(path, ext) {\n        if (ext !== undefined) {\n            validateString(ext, 'ext');\n        }\n        validateString(path, 'path');\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext === path) {\n                return '';\n            }\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for (i = path.length - 1; i >= 0; --i) {\n                const code = path.charCodeAt(i);\n                if (code === CHAR_FORWARD_SLASH) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else {\n                    if (firstNonSlashEnd === -1) {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) {\n                end = firstNonSlashEnd;\n            }\n            else if (end === -1) {\n                end = path.length;\n            }\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i) {\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) {\n            return '';\n        }\n        return path.slice(start, end);\n    },\n    extname(path) {\n        validateString(path, 'path');\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        for (let i = path.length - 1; i >= 0; --i) {\n            const code = path.charCodeAt(i);\n            if (code === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 ||\n            end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            (preDotState === 1 &&\n                startDot === end - 1 &&\n                startDot === startPart + 1)) {\n            return '';\n        }\n        return path.slice(startDot, end);\n    },\n    format: _format.bind(null, '/'),\n    parse(path) {\n        validateString(path, 'path');\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n        if (path.length === 0) {\n            return ret;\n        }\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        let start;\n        if (isAbsolute) {\n            ret.root = '/';\n            start = 1;\n        }\n        else {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        // Get non-dir info\n        for (; i >= start; --i) {\n            const code = path.charCodeAt(i);\n            if (code === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (end !== -1) {\n            const start = startPart === 0 && isAbsolute ? 1 : startPart;\n            if (startDot === -1 ||\n                // We saw a non-dot character immediately before the dot\n                preDotState === 0 ||\n                // The (right-most) trimmed path component is exactly '..'\n                (preDotState === 1 &&\n                    startDot === end - 1 &&\n                    startDot === startPart + 1)) {\n                ret.base = ret.name = path.slice(start, end);\n            }\n            else {\n                ret.name = path.slice(start, startDot);\n                ret.base = path.slice(start, end);\n                ret.ext = path.slice(startDot, end);\n            }\n        }\n        if (startPart > 0) {\n            ret.dir = path.slice(0, startPart - 1);\n        }\n        else if (isAbsolute) {\n            ret.dir = '/';\n        }\n        return ret;\n    },\n    sep: '/',\n    delimiter: ':',\n    win32: null,\n    posix: null\n};\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nexport const normalize = (process.platform === 'win32' ? win32.normalize : posix.normalize);\nexport const resolve = (process.platform === 'win32' ? win32.resolve : posix.resolve);\nexport const relative = (process.platform === 'win32' ? win32.relative : posix.relative);\nexport const dirname = (process.platform === 'win32' ? win32.dirname : posix.dirname);\nexport const basename = (process.platform === 'win32' ? win32.basename : posix.basename);\nexport const extname = (process.platform === 'win32' ? win32.extname : posix.extname);\nexport const sep = (process.platform === 'win32' ? win32.sep : posix.sep);\n"],"mappings":"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"}]}